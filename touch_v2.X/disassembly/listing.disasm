Disassembly Listing for touch_v2
Generated From:
/root/MPLABXProjects/vtouch_v2/touch_v2.X/dist/default/production/touch_v2.X.production.elf
Jan 16, 2020 4:24:06 PM

---  /tmp/xcXYJo0I5.s  ----------------------------------------------------------------------------------
1A1AE  0E28     MOVLW 0x28
1A1B0  6EF6     MOVWF 0xFF6, ACCESS
1A1B2  0E6B     MOVLW 0x6B
1A1B4  6EF7     MOVWF 0xFF7, ACCESS
1A1B6  0E01     MOVLW 0x1
1A1B8  6EF8     MOVWF 0xFF8, ACCESS
1A1BA  EE01     LFSR 0, 0x4FF
1A1BE  EE20     LFSR 2, 0x32B
1A1C2  0009     TBLRD*+
1A1CA  50DD     MOVF 0xFDD, W, ACCESS
1A1CC  50D9     MOVF 0xFD9, W, ACCESS
1A1CE  E1F9     BNZ 0xA1C2
1A1D0  50DA     MOVF 0xFDA, W, ACCESS
1A1D2  E1F7     BNZ 0xA1C2
1A1D4  0E0C     MOVLW 0xC
1A1D6  6EF6     MOVWF 0xFF6, ACCESS
1A1D8  0E9E     MOVLW 0x9E
1A1DA  6EF7     MOVWF 0xFF7, ACCESS
1A1DC  0E01     MOVLW 0x1
1A1DE  6EF8     MOVWF 0xFF8, ACCESS
1A1E0  EE00     LFSR 0, 0x100
1A1E4  EE20     LFSR 2, 0xEF
1A1E8  0009     TBLRD*+
1A1F0  50DD     MOVF 0xFDD, W, ACCESS
1A1F2  50D9     MOVF 0xFD9, W, ACCESS
1A1F4  E1F9     BNZ 0xA1E8
1A1F6  0E86     MOVLW 0x86
1A1F8  6EF6     MOVWF 0xFF6, ACCESS
1A1FA  0EC0     MOVLW 0xC0
1A1FC  6EF7     MOVWF 0xFF7, ACCESS
1A1FE  0E01     MOVLW 0x1
1A200  6EF8     MOVWF 0xFF8, ACCESS
1A202  EE00     LFSR 0, 0xF0
1A206  EE20     LFSR 2, 0xE
1A20A  0009     TBLRD*+
1A212  50DD     MOVF 0xFDD, W, ACCESS
1A214  50D9     MOVF 0xFD9, W, ACCESS
1A216  E1F9     BNZ 0xA20A
1A218  EE02     LFSR 0, 0x82A
1A21C  EE20     LFSR 2, 0x1E2
1A220  6AEE     CLRF 0xFEE, ACCESS
1A222  50DD     MOVF 0xFDD, W, ACCESS
1A224  50D9     MOVF 0xFD9, W, ACCESS
1A226  E1FC     BNZ 0xA220
1A228  50DA     MOVF 0xFDA, W, ACCESS
1A22A  E1FA     BNZ 0xA220
1A22C  EE01     LFSR 0, 0x400
1A230  EE20     LFSR 2, 0xFF
1A234  6AEE     CLRF 0xFEE, ACCESS
1A236  50DD     MOVF 0xFDD, W, ACCESS
1A238  50D9     MOVF 0xFD9, W, ACCESS
1A23A  E1FC     BNZ 0xA234
1A23C  50DA     MOVF 0xFDA, W, ACCESS
1A23E  E1FA     BNZ 0xA234
1A240  EE00     LFSR 0, 0x300
1A244  0EC6     MOVLW 0xC6
1A246  6AEE     CLRF 0xFEE, ACCESS
1A248  06E8     DECF 0xFE8, F, ACCESS
1A24A  E1FD     BNZ 0xA246
1A24C  EE00     LFSR 0, 0x200
1A250  0EE7     MOVLW 0xE7
1A252  6AEE     CLRF 0xFEE, ACCESS
1A254  06E8     DECF 0xFE8, F, ACCESS
1A256  E1FD     BNZ 0xA252
1A258  EE00     LFSR 0, 0x60
1A25C  0E77     MOVLW 0x77
1A25E  6AEE     CLRF 0xFEE, ACCESS
1A260  06E8     DECF 0xFE8, F, ACCESS
1A262  E1FD     BNZ 0xA25E
1A264  EE00     LFSR 0, 0x3A
1A268  0E0E     MOVLW 0xE
1A26A  6AEE     CLRF 0xFEE, ACCESS
1A26C  06E8     DECF 0xFE8, F, ACCESS
1A26E  E1FD     BNZ 0xA26A
1A270  0E08     MOVLW 0x8
1A272  6ED5     MOVWF 0xFD5, ACCESS
1A274  0E00     MOVLW 0x0
1A276  6ED6     MOVWF 0xFD6, ACCESS
1A278  0E00     MOVLW 0x0
1A27A  6ED7     MOVWF 0xFD7, ACCESS
1A27C  0100     MOVLB 0x0
1A27E  EF22     GOTO 0x11244
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/timers.c  ------------------------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "vconfig.h"
5:             #include "timers.h"
6:             
7:             extern volatile uint16_t tickCount[TMR_COUNT];
8:             
9:             //**********************************************************************************************************************
10:            // Start one of the software timers
11:            
12:            void StartTimer(const uint8_t timer, const uint16_t count)
13:            {
14:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
1B6CA  0EFD     MOVLW 0xFD
1B6CE  FF8C     NOP
1B6D0  F00B     NOP
1B6D2  0EFE     MOVLW 0xFE
1B6D6  FF8C     NOP
1B6D8  F00C     NOP
1B6DA  90D8     BCF 0xFD8, 0, ACCESS
1B6DC  340B     RLCF wtemp5, W, ACCESS
1B6DE  6E09     MOVWF ltemp2, ACCESS
1B6E0  340C     RLCF 0xC, W, ACCESS
1B6E2  6E0A     MOVWF ttemp3, ACCESS
1B6E4  0EFF     MOVLW 0xFF
1B6E6  50E3     MOVF 0xFE3, W, ACCESS
1B6E8  0D02     MULLW 0x2
1B6EA  0E7D     MOVLW 0x7D
1B6EC  24F3     ADDWF 0xFF3, W, ACCESS
1B6EE  6ED9     MOVWF 0xFD9, ACCESS
1B6F0  0E02     MOVLW 0x2
1B6F2  20F4     ADDWFC 0xFF4, W, ACCESS
1B6F4  6EDA     MOVWF 0xFDA, ACCESS
1B6F8  F027     NOP
1B6FA  FFDE     NOP
1B6FE  F02B     NOP
1B700  FFDD     NOP
15:            }
1B702  52E5     MOVF 0xFE5, F, ACCESS
1B704  52E5     MOVF 0xFE5, F, ACCESS
1B706  52E5     MOVF 0xFE5, F, ACCESS
1B708  0012     RETURN 0
16:            
17:            //**********************************************************************************************************************
18:            // Check if one of the software software timers has timed out
19:            
20:            bool TimerDone(const uint8_t timer)
21:            {
22:            	ClrWdt(); // reset the WDT timer
1BB16  0004     CLRWDT
23:            	if (tickCount[timer] == 0) { //Check if counted down to zero
1BB18  0EFF     MOVLW 0xFF
1BB1A  50E3     MOVF 0xFE3, W, ACCESS
1BB1C  0D02     MULLW 0x2
1BB1E  0E7D     MOVLW 0x7D
1BB20  24F3     ADDWF 0xFF3, W, ACCESS
1BB22  6ED9     MOVWF 0xFD9, ACCESS
1BB24  0E02     MOVLW 0x2
1BB26  20F4     ADDWFC 0xFF4, W, ACCESS
1BB28  6EDA     MOVWF 0xFDA, ACCESS
1BB2A  50DE     MOVF 0xFDE, W, ACCESS
1BB2C  10DE     IORWF 0xFDE, W, ACCESS
1BB2E  A4D8     BTFSS 0xFD8, 2, ACCESS
1BB30  D002     BRA 0xBB36
24:            		return true; //then return true
1BB32  0E01     MOVLW 0x1
1BB34  D001     BRA 0xBB38
25:            	}
26:            	return false; //else return false
1BB36  0E00     MOVLW 0x0
1BB38  6E01     MOVWF ltemp0, ACCESS
27:            }
1BB3A  52E5     MOVF 0xFE5, F, ACCESS
1BB3C  0012     RETURN 0
28:            
29:            //**********************************************************************************************************************
30:            // Simple delay for n milliseconds (blocking)
31:            
32:            void WaitMs(const uint16_t numMilliseconds)
33:            {
34:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
1B8B4  0EFE     MOVLW 0xFE
1B8B8  FF8F     NOP
1B8BA  FFE6     NOP
1B8BE  FF8F     NOP
1B8C0  FFE6     NOP
1B8C2  0E00     MOVLW 0x0
1B8C4  6EE6     MOVWF 0xFE6, ACCESS
1B8C6  EC65     CALL 0x1B6CA, 0
1B8C8  F0DB     NOP
35:            	while (!TimerDone(TMR_INTERNAL)) {
1B8CA  D005     BRA 0xB8D6
1B8D6  0E00     MOVLW 0x0
1B8D8  6EE6     MOVWF 0xFE6, ACCESS
1B8DA  EC8B     CALL 0x1BB16, 0
1B8DC  F0DD     NOP
1B8DE  5001     MOVF ltemp0, W, ACCESS
1B8E0  B4D8     BTFSC 0xFD8, 2, ACCESS
1B8E2  D7F4     BRA 0xB8CC
36:            		Nop();
1B8CC  F000     NOP
37:            		Nop();
1B8CE  F000     NOP
38:            		Nop();
1B8D0  F000     NOP
39:            		Nop();
1B8D2  F000     NOP
40:            		ClrWdt(); // reset the WDT timer
1B8D4  0004     CLRWDT
41:            		//		Idle();
42:            	} //Enter idle mode to reduce power while waiting
43:            } //(timer interrupt will wake part from idle)
1B8E4  52E5     MOVF 0xFE5, F, ACCESS
1B8E6  52E5     MOVF 0xFE5, F, ACCESS
1B8E8  0012     RETURN 0
44:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/ringbufs.c  ----------------------------------------------
1:             #include  <string.h>
2:             #include  "ringbufs.h"
3:             
4:             /*
5:              * general ring buffer fuctions from the internet
6:              */
7:             uint8_t modulo_inc(const uint8_t value, const uint8_t modulus)
8:             {
9:             	uint8_t my_value = value + 1;
10:            	if (my_value >= modulus) {
11:            		my_value = 0;
12:            	}
13:            	return my_value;
14:            }
15:            
16:            uint8_t modulo_dec(const uint8_t value, const uint8_t modulus)
17:            {
18:            	uint8_t my_value = (0 == value) ? (modulus - 1) : (value - 1);
19:            	return my_value;
20:            }
21:            
22:            void ringBufS_init(volatile ringBufS_t *_this)
23:            {
24:            	/*****
25:            	  The following clears:
26:            	    -> buf
27:            	    -> head
28:            	    -> tail
29:            	    -> count
30:            	  and sets head = tail
31:            	 ***/
32:            	memset((void*)_this, 0, sizeof(*_this));
1BAEE  0E43     MOVLW 0x43
1BAF0  6EE6     MOVWF 0xFE6, ACCESS
1BAF2  0E00     MOVLW 0x0
1BAF4  6EE6     MOVWF 0xFE6, ACCESS
1BAF6  0E00     MOVLW 0x0
1BAF8  6EE6     MOVWF 0xFE6, ACCESS
1BAFA  0E00     MOVLW 0x0
1BAFC  6EE6     MOVWF 0xFE6, ACCESS
1BAFE  0EFA     MOVLW 0xFA
1BB02  FF8F     NOP
1BB04  FFE6     NOP
1BB08  FF8F     NOP
1BB0A  FFE6     NOP
1BB0C  EC2A     CALL 0x16E54, 0
1BB0E  F0B7     NOP
33:            }
1BB10  52E5     MOVF 0xFE5, F, ACCESS
1BB12  52E5     MOVF 0xFE5, F, ACCESS
1BB14  0012     RETURN 0
34:            
35:            int8_t ringBufS_empty(ringBufS_t *_this)
36:            {
37:            	return(0 == _this->count);
38:            }
39:            
40:            int8_t ringBufS_full(ringBufS_t *_this)
41:            {
42:            	return(_this->count >= RBUF_SIZE);
43:            }
44:            
45:            uint8_t ringBufS_get(ringBufS_t *_this)
46:            {
47:            	uint8_t c;
48:            	if (_this->count > 0) {
49:            		c = _this->buf[_this->tail];
50:            		_this->tail = modulo_inc(_this->tail, RBUF_SIZE);
51:            		--_this->count;
52:            	} else {
53:            		c = 0; // return null with empty buffer
54:            	}
55:            	return(c);
56:            }
57:            
58:            void ringBufS_put(ringBufS_t *_this, const uint8_t c)
59:            {
60:            	if (_this->count < RBUF_SIZE) {
61:            		_this->buf[_this->head] = c;
62:            		_this->head = modulo_inc(_this->head, RBUF_SIZE);
63:            		++_this->count;
64:            	}
65:            }
66:            
67:            void ringBufS_put_dma(ringBufS_t *_this, const uint8_t c)
68:            {
69:            	if (_this->count < RBUF_SIZE) {
1A6E6  0EFE     MOVLW 0xFE
1A6EA  FF8C     NOP
1A6EC  F00B     NOP
1A6EE  0EFF     MOVLW 0xFF
1A6F2  FF8C     NOP
1A6F4  F00C     NOP
1A6F6  0E42     MOVLW 0x42
1A6F8  240B     ADDWF wtemp5, W, ACCESS
1A6FA  6ED9     MOVWF 0xFD9, ACCESS
1A6FC  0E00     MOVLW 0x0
1A6FE  200C     ADDWFC 0xC, W, ACCESS
1A700  6EDA     MOVWF 0xFDA, ACCESS
1A702  0E40     MOVLW 0x40
1A704  60DF     CPFSLT 0xFDF, ACCESS
1A706  D040     BRA 0xA788
70:            		_this->buf[_this->head] = c;
1A708  0EFE     MOVLW 0xFE
1A70C  FF8C     NOP
1A70E  F00B     NOP
1A710  0EFF     MOVLW 0xFF
1A714  FF8C     NOP
1A716  F00C     NOP
1A718  0E40     MOVLW 0x40
1A71A  240B     ADDWF wtemp5, W, ACCESS
1A71C  6ED9     MOVWF 0xFD9, ACCESS
1A71E  0E00     MOVLW 0x0
1A720  200C     ADDWFC 0xC, W, ACCESS
1A722  6EDA     MOVWF 0xFDA, ACCESS
1A724  50DF     MOVF 0xFDF, W, ACCESS
1A726  6E0C     MOVWF 0xC, ACCESS
1A728  0EFE     MOVLW 0xFE
1A72C  FF8C     NOP
1A72E  F009     NOP
1A730  0EFF     MOVLW 0xFF
1A734  FF8C     NOP
1A736  F00A     NOP
1A738  500C     MOVF 0xC, W, ACCESS
1A73A  2409     ADDWF ltemp2, W, ACCESS
1A73C  6ED9     MOVWF 0xFD9, ACCESS
1A73E  0E00     MOVLW 0x0
1A740  200A     ADDWFC ttemp3, W, ACCESS
1A742  6EDA     MOVWF 0xFDA, ACCESS
1A744  0EFD     MOVLW 0xFD
1A748  FF8F     NOP
1A74A  FFDF     NOP
71:            		++_this->head;
1A74C  0EFE     MOVLW 0xFE
1A750  FF8C     NOP
1A752  F00B     NOP
1A754  0EFF     MOVLW 0xFF
1A758  FF8C     NOP
1A75A  F00C     NOP
1A75C  0E40     MOVLW 0x40
1A75E  240B     ADDWF wtemp5, W, ACCESS
1A760  6ED9     MOVWF 0xFD9, ACCESS
1A762  0E00     MOVLW 0x0
1A764  200C     ADDWFC 0xC, W, ACCESS
1A766  6EDA     MOVWF 0xFDA, ACCESS
1A768  2ADF     INCF 0xFDF, F, ACCESS
72:            		++_this->count;
1A76A  0EFE     MOVLW 0xFE
1A76E  FF8C     NOP
1A770  F00B     NOP
1A772  0EFF     MOVLW 0xFF
1A776  FF8C     NOP
1A778  F00C     NOP
1A77A  0E42     MOVLW 0x42
1A77C  240B     ADDWF wtemp5, W, ACCESS
1A77E  6ED9     MOVWF 0xFD9, ACCESS
1A780  0E00     MOVLW 0x0
1A782  200C     ADDWFC 0xC, W, ACCESS
1A784  6EDA     MOVWF 0xFDA, ACCESS
1A786  2ADF     INCF 0xFDF, F, ACCESS
73:            	}
74:            }
1A788  52E5     MOVF 0xFE5, F, ACCESS
1A78A  52E5     MOVF 0xFE5, F, ACCESS
1A78C  52E5     MOVF 0xFE5, F, ACCESS
1A78E  0012     RETURN 0
75:            
76:            void ringBufS_flush(ringBufS_t *_this, const int8_t clearBuffer)
77:            {
78:            	_this->count = 0;
1AA18  0EFE     MOVLW 0xFE
1AA1C  FF8C     NOP
1AA1E  F00B     NOP
1AA20  0EFF     MOVLW 0xFF
1AA24  FF8C     NOP
1AA26  F00C     NOP
1AA28  0E42     MOVLW 0x42
1AA2A  240B     ADDWF wtemp5, W, ACCESS
1AA2C  6ED9     MOVWF 0xFD9, ACCESS
1AA2E  0E00     MOVLW 0x0
1AA30  200C     ADDWFC 0xC, W, ACCESS
1AA32  6EDA     MOVWF 0xFDA, ACCESS
1AA34  0E00     MOVLW 0x0
1AA36  6EDF     MOVWF 0xFDF, ACCESS
79:            	_this->head = 0;
1AA38  0EFE     MOVLW 0xFE
1AA3C  FF8C     NOP
1AA3E  F00B     NOP
1AA40  0EFF     MOVLW 0xFF
1AA44  FF8C     NOP
1AA46  F00C     NOP
1AA48  0E40     MOVLW 0x40
1AA4A  240B     ADDWF wtemp5, W, ACCESS
1AA4C  6ED9     MOVWF 0xFD9, ACCESS
1AA4E  0E00     MOVLW 0x0
1AA50  200C     ADDWFC 0xC, W, ACCESS
1AA52  6EDA     MOVWF 0xFDA, ACCESS
1AA54  0E00     MOVLW 0x0
1AA56  6EDF     MOVWF 0xFDF, ACCESS
80:            	_this->tail = 0;
1AA58  0EFE     MOVLW 0xFE
1AA5C  FF8C     NOP
1AA5E  F00B     NOP
1AA60  0EFF     MOVLW 0xFF
1AA64  FF8C     NOP
1AA66  F00C     NOP
1AA68  0E41     MOVLW 0x41
1AA6A  240B     ADDWF wtemp5, W, ACCESS
1AA6C  6ED9     MOVWF 0xFD9, ACCESS
1AA6E  0E00     MOVLW 0x0
1AA70  200C     ADDWFC 0xC, W, ACCESS
1AA72  6EDA     MOVWF 0xFDA, ACCESS
1AA74  0E00     MOVLW 0x0
1AA76  6EDF     MOVWF 0xFDF, ACCESS
81:            	if (clearBuffer) {
1AA78  0EFD     MOVLW 0xFD
1AA7A  50E3     MOVF 0xFE3, W, ACCESS
1AA7C  B4D8     BTFSC 0xFD8, 2, ACCESS
1AA7E  D011     BRA 0xAAA2
82:            		memset(_this->buf, 0, sizeof(_this->buf));
1AA80  0E40     MOVLW 0x40
1AA82  6EE6     MOVWF 0xFE6, ACCESS
1AA84  0E00     MOVLW 0x0
1AA86  6EE6     MOVWF 0xFE6, ACCESS
1AA88  0E00     MOVLW 0x0
1AA8A  6EE6     MOVWF 0xFE6, ACCESS
1AA8C  0E00     MOVLW 0x0
1AA8E  6EE6     MOVWF 0xFE6, ACCESS
1AA90  0EFA     MOVLW 0xFA
1AA94  FF8F     NOP
1AA96  FFE6     NOP
1AA9A  FF8F     NOP
1AA9C  FFE6     NOP
1AA9E  EC2A     CALL 0x16E54, 0
1AAA0  F0B7     NOP
83:            	}
84:            }
1AAA2  52E5     MOVF 0xFE5, F, ACCESS
1AAA4  52E5     MOVF 0xFE5, F, ACCESS
1AAA6  52E5     MOVF 0xFE5, F, ACCESS
1AAA8  0012     RETURN 0
85:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mconfig.c  -----------------------------------------------
1:             #include "mconfig.h"
2:             #include "mydisplay.h"
3:             #include "msg_text.h"
4:             
5:             extern V_data V;
6:             static D_data D = {0};
7:             
8:             static const char *build_date = __DATE__, *build_time = __TIME__;
9:             
10:            /*
11:             * hardware specific routines
12:             */
13:            void mode_lamp_dim(const uint16_t level)
14:            {
15:            	PWM8_LoadDutyValue(level);
1BFAE  0EFE     MOVLW 0xFE
1BFB2  FF8F     NOP
1BFB4  FFE6     NOP
1BFB8  FF8F     NOP
1BFBA  FFE6     NOP
1BFBC  EC04     CALL 0x1B608, 0
1BFBE  F0DB     NOP
16:            }
1BFC0  52E5     MOVF 0xFE5, F, ACCESS
1BFC2  52E5     MOVF 0xFE5, F, ACCESS
1BFC4  0012     RETURN 0
17:            
18:            void mode_lamp_bright(void)
19:            {
20:            	PWM8_LoadDutyValue(300);
1C0A2  0E2C     MOVLW 0x2C
1C0A4  6EE6     MOVWF 0xFE6, ACCESS
1C0A6  0E01     MOVLW 0x1
1C0A8  6EE6     MOVWF 0xFE6, ACCESS
1C0AA  EC04     CALL 0x1B608, 0
1C0AC  F0DB     NOP
21:            }
1C0AE  0012     RETURN 0
22:            
23:            /*
24:             * mode button help mode select
25:             */
26:            bool help_button(void)
27:            {
28:            	if (!RB0_GetValue()) { // debounce and delay for button press
1B844  B0CB     BTFSC 0xFCB, 0, ACCESS
1B846  D00C     BRA 0xB860
29:            		V.help = true;
1B848  0101     MOVLB 0x1
1B84A  85CB     BSF uart2RxCount, 2, BANKED
30:            		if (TimerDone(TMR_HELP))
1B84C  0E08     MOVLW 0x8
1B84E  6EE6     MOVWF 0xFE6, ACCESS
1B850  EC8B     CALL 0x1BB16, 0
1B852  F0DD     NOP
1B854  5001     MOVF ltemp0, W, ACCESS
1B856  B4D8     BTFSC 0xFD8, 2, ACCESS
1B858  D003     BRA 0xB860
31:            			return true;
1B85A  0E01     MOVLW 0x1
1B85C  6E01     MOVWF ltemp0, ACCESS
1B85E  0012     RETURN 0
32:            	}
33:            
34:            	if (!V.help)
1B860  0101     MOVLB 0x1
1B862  B5CB     BTFSC uart2RxCount, 2, BANKED
1B864  D008     BRA 0xB876
35:            		StartTimer(TMR_HELP, BDELAY);
1B866  0E2C     MOVLW 0x2C
1B868  6EE6     MOVWF 0xFE6, ACCESS
1B86A  0E01     MOVLW 0x1
1B86C  6EE6     MOVWF 0xFE6, ACCESS
1B86E  0E08     MOVLW 0x8
1B870  6EE6     MOVWF 0xFE6, ACCESS
1B872  EC65     CALL 0x1B6CA, 0
1B874  F0DB     NOP
36:            
37:            	return false;
1B876  0E00     MOVLW 0x0
1B878  6E01     MOVWF ltemp0, ACCESS
38:            }
1B87A  0012     RETURN 0
39:            
40:            bool check_help(const bool flipper)
41:            {
42:            	bool estatus=false;
43:            	/*
44:            	 * show help display
45:            	 */
46:            	if (help_button() && display_info() != DIS_HELP) {
18268  EC22     CALL 0x1B844, 0
1826A  F0DC     NOP
1826C  5001     MOVF ltemp0, W, ACCESS
1826E  B4D8     BTFSC 0xFD8, 2, ACCESS
18270  D0D0     BRA 0x8412
18272  EC93     CALL 0x1C126, 0
18274  F0E0     NOP
18276  0401     DECF ltemp0, W, ACCESS
18278  B4D8     BTFSC 0xFD8, 2, ACCESS
1827A  D0CB     BRA 0x8412
47:            		StartTimer(TMR_FLIPPER, DFLIP);
1827C  0EDC     MOVLW 0xDC
1827E  6EE6     MOVWF 0xFE6, ACCESS
18280  0E05     MOVLW 0x5
18282  6EE6     MOVWF 0xFE6, ACCESS
18284  0E0B     MOVLW 0xB
18286  6EE6     MOVWF 0xFE6, ACCESS
18288  EC65     CALL 0x1B6CA, 0
1828A  F0DB     NOP
48:            		if (V.debug)
1828C  0101     MOVLB 0x1
1828E  B3CB     BTFSC uart2RxCount, 1, BANKED
49:            			vterm_dump();
18290  EC39     CALL 0x19672, 0
18292  F0CB     NOP
50:            
51:            		set_vterm(1);
18294  0E01     MOVLW 0x1
18296  6EE6     MOVWF 0xFE6, ACCESS
18298  EC82     CALL 0x1BF04, 0
1829A  F0DF     NOP
52:            		set_temp_display_help(display_info());
1829C  EC93     CALL 0x1C126, 0
1829E  F0E0     NOP
182A0  5001     MOVF ltemp0, W, ACCESS
182A2  6EE6     MOVWF 0xFE6, ACCESS
182A4  EC33     CALL 0x1C066, 0
182A6  F0E0     NOP
53:            		set_display_info(DIS_HELP);
182A8  0E01     MOVLW 0x1
182AA  6EE6     MOVWF 0xFE6, ACCESS
182AC  EC91     CALL 0x1BF22, 0
182AE  F0DF     NOP
54:            		if (flipper) {
182B0  0EFF     MOVLW 0xFF
182B2  50E3     MOVF 0xFE3, W, ACCESS
182B4  B4D8     BTFSC 0xFD8, 2, ACCESS
182B6  D019     BRA 0x82EA
55:            			sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_date);
182B8  0EB3     MOVLW 0xB3
182BA  6EE6     MOVWF 0xFE6, ACCESS
182BC  0EFF     MOVLW 0xFF
182BE  6EE6     MOVWF 0xFE6, ACCESS
182C0  0E5D     MOVLW 0x5D
182C2  6EE6     MOVWF 0xFE6, ACCESS
182C4  0EFF     MOVLW 0xFF
182C6  6EE6     MOVWF 0xFE6, ACCESS
182C8  0E01     MOVLW 0x1
182CA  6EE6     MOVWF 0xFE6, ACCESS
182CC  0E00     MOVLW 0x0
182CE  6EE6     MOVWF 0xFE6, ACCESS
182D0  EC09     CALL 0x1BA12, 0
182D2  F0DD     NOP
182D6  F007     NOP
182D8  FFE6     NOP
182DC  F00B     NOP
182DE  FFE6     NOP
182E0  0E06     MOVLW 0x6
182E2  6EE6     MOVWF 0xFE6, ACCESS
182E4  EC00     CALL 0x19C00, 0
182E6  F0CE     NOP
56:            		} else {
182E8  D018     BRA 0x831A
57:            			sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_time);
182EA  0EC9     MOVLW 0xC9
182EC  6EE6     MOVWF 0xFE6, ACCESS
182EE  0EFF     MOVLW 0xFF
182F0  6EE6     MOVWF 0xFE6, ACCESS
182F2  0E5D     MOVLW 0x5D
182F4  6EE6     MOVWF 0xFE6, ACCESS
182F6  0EFF     MOVLW 0xFF
182F8  6EE6     MOVWF 0xFE6, ACCESS
182FA  0E01     MOVLW 0x1
182FC  6EE6     MOVWF 0xFE6, ACCESS
182FE  0E00     MOVLW 0x0
18300  6EE6     MOVWF 0xFE6, ACCESS
18302  EC09     CALL 0x1BA12, 0
18304  F0DD     NOP
18308  F007     NOP
1830A  FFE6     NOP
1830E  F00B     NOP
18310  FFE6     NOP
18312  0E06     MOVLW 0x6
18314  6EE6     MOVWF 0xFE6, ACCESS
18316  EC00     CALL 0x19C00, 0
18318  F0CE     NOP
58:            		}
59:            		sprintf(get_vterm_ptr(1, 1), "%s       ", T[V.help_id].display);
1831A  0101     MOVLB 0x1
1831C  39CB     SWAPF uart2RxCount, W, BANKED
1831E  32E8     RRCF 0xFE8, F, ACCESS
18320  32E8     RRCF 0xFE8, F, ACCESS
18322  0B03     ANDLW 0x3
18324  0D24     MULLW 0x24
18326  0E12     MOVLW 0x12
18328  26F3     ADDWF 0xFF3, F, ACCESS
1832A  0E00     MOVLW 0x0
1832C  22F4     ADDWFC 0xFF4, F, ACCESS
1832E  0EBB     MOVLW 0xBB
18330  6E0B     MOVWF wtemp5, ACCESS
18332  0EFA     MOVLW 0xFA
18334  6E0C     MOVWF 0xC, ACCESS
18336  50F3     MOVF 0xFF3, W, ACCESS
18338  260B     ADDWF wtemp5, F, ACCESS
1833A  50F4     MOVF 0xFF4, W, ACCESS
1833C  220C     ADDWFC 0xC, F, ACCESS
18340  F02F     NOP
18342  FFE6     NOP
18346  F033     NOP
18348  FFE6     NOP
1834A  0EBF     MOVLW 0xBF
1834C  6EE6     MOVWF 0xFE6, ACCESS
1834E  0EFF     MOVLW 0xFF
18350  6EE6     MOVWF 0xFE6, ACCESS
18352  0E01     MOVLW 0x1
18354  6EE6     MOVWF 0xFE6, ACCESS
18356  0E01     MOVLW 0x1
18358  6EE6     MOVWF 0xFE6, ACCESS
1835A  EC09     CALL 0x1BA12, 0
1835C  F0DD     NOP
18360  F007     NOP
18362  FFE6     NOP
18366  F00B     NOP
18368  FFE6     NOP
1836A  0E06     MOVLW 0x6
1836C  6EE6     MOVWF 0xFE6, ACCESS
1836E  EC00     CALL 0x19C00, 0
18370  F0CE     NOP
60:            		sprintf(get_vterm_ptr(2, 1), "%s       ", T[V.help_id].message);
18372  0101     MOVLB 0x1
18374  39CB     SWAPF uart2RxCount, W, BANKED
18376  32E8     RRCF 0xFE8, F, ACCESS
18378  32E8     RRCF 0xFE8, F, ACCESS
1837A  0B03     ANDLW 0x3
1837C  0D24     MULLW 0x24
1837E  0EBB     MOVLW 0xBB
18380  6E0B     MOVWF wtemp5, ACCESS
18382  0EFA     MOVLW 0xFA
18384  6E0C     MOVWF 0xC, ACCESS
18386  50F3     MOVF 0xFF3, W, ACCESS
18388  260B     ADDWF wtemp5, F, ACCESS
1838A  50F4     MOVF 0xFF4, W, ACCESS
1838C  220C     ADDWFC 0xC, F, ACCESS
18390  F02F     NOP
18392  FFE6     NOP
18396  F033     NOP
18398  FFE6     NOP
1839A  0EBF     MOVLW 0xBF
1839C  6EE6     MOVWF 0xFE6, ACCESS
1839E  0EFF     MOVLW 0xFF
183A0  6EE6     MOVWF 0xFE6, ACCESS
183A2  0E01     MOVLW 0x1
183A4  6EE6     MOVWF 0xFE6, ACCESS
183A6  0E02     MOVLW 0x2
183A8  6EE6     MOVWF 0xFE6, ACCESS
183AA  EC09     CALL 0x1BA12, 0
183AC  F0DD     NOP
183B0  F007     NOP
183B2  FFE6     NOP
183B6  F00B     NOP
183B8  FFE6     NOP
183BA  0E06     MOVLW 0x6
183BC  6EE6     MOVWF 0xFE6, ACCESS
183BE  EC00     CALL 0x19C00, 0
183C0  F0CE     NOP
61:            		V.help_id++; // cycle help text messages to LCD
183C2  EE20     LFSR 2, 0x1CB
183C4  F1CB     NOP
183C6  38DF     SWAPF 0xFDF, W, ACCESS
183C8  6E0C     MOVWF 0xC, ACCESS
183CA  320C     RRCF 0xC, F, ACCESS
183CC  300C     RRCF 0xC, W, ACCESS
183CE  0B03     ANDLW 0x3
183D0  6E0C     MOVWF 0xC, ACCESS
183D2  2A0C     INCF 0xC, F, ACCESS
183D4  3A0C     SWAPF 0xC, F, ACCESS
183D6  360C     RLCF 0xC, F, ACCESS
183D8  360C     RLCF 0xC, F, ACCESS
183DA  50DF     MOVF 0xFDF, W, ACCESS
183DC  180C     XORWF 0xC, W, ACCESS
183DE  0B3F     ANDLW 0x3F
183E0  180C     XORWF 0xC, W, ACCESS
183E2  6EDF     MOVWF 0xFDF, ACCESS
62:            		StartTimer(TMR_HELPDIS, TDELAY);
183E4  0EB8     MOVLW 0xB8
183E6  6EE6     MOVWF 0xFE6, ACCESS
183E8  0E0B     MOVLW 0xB
183EA  6EE6     MOVWF 0xFE6, ACCESS
183EC  0E09     MOVLW 0x9
183EE  6EE6     MOVWF 0xFE6, ACCESS
183F0  EC65     CALL 0x1B6CA, 0
183F2  F0DB     NOP
63:            		StartTimer(TMR_INFO, TDELAY);
183F4  0EB8     MOVLW 0xB8
183F6  6EE6     MOVWF 0xFE6, ACCESS
183F8  0E0B     MOVLW 0xB
183FA  6EE6     MOVWF 0xFE6, ACCESS
183FC  0E07     MOVLW 0x7
183FE  6EE6     MOVWF 0xFE6, ACCESS
18400  EC65     CALL 0x1B6CA, 0
18402  F0DB     NOP
64:            		mode_lamp_bright(); // mode switch indicator lamp 'button' level
18404  EC51     CALL 0x1C0A2, 0
18406  F0E0     NOP
65:            		update_lcd(1);
18408  0E01     MOVLW 0x1
1840A  6EE6     MOVWF 0xFE6, ACCESS
1840C  EC78     CALL 0x19AF0, 0
1840E  F0CD     NOP
66:            		estatus=true;
67:            	} else {
18410  D032     BRA 0x8476
68:            		if (TimerDone(TMR_HELPDIS)) {
18412  0E09     MOVLW 0x9
18414  6EE6     MOVWF 0xFE6, ACCESS
18416  EC8B     CALL 0x1BB16, 0
18418  F0DD     NOP
1841A  5001     MOVF ltemp0, W, ACCESS
1841C  B4D8     BTFSC 0xFD8, 2, ACCESS
1841E  D02B     BRA 0x8476
69:            			set_vterm(0);
18420  0E00     MOVLW 0x0
18422  6EE6     MOVWF 0xFE6, ACCESS
18424  EC82     CALL 0x1BF04, 0
18426  F0DF     NOP
70:            			V.help = false;
18428  0101     MOVLB 0x1
1842A  95CB     BCF uart2RxCount, 2, BANKED
71:            			set_display_info(display_help());
1842C  EC97     CALL 0x1C12E, 0
1842E  F0E0     NOP
18430  5001     MOVF ltemp0, W, ACCESS
18432  6EE6     MOVWF 0xFE6, ACCESS
18434  EC91     CALL 0x1BF22, 0
18436  F0DF     NOP
72:            			mode_lamp_dim(V.mode_pwm);
1843A  F717     NOP
1843C  FFE6     NOP
18440  F71B     NOP
18442  FFE6     NOP
18444  ECD7     CALL 0x1BFAE, 0
18446  F0DF     NOP
73:            			if (TimerDone(TMR_FLIPPER)) {
18448  0E0B     MOVLW 0xB
1844A  6EE6     MOVWF 0xFE6, ACCESS
1844C  EC8B     CALL 0x1BB16, 0
1844E  F0DD     NOP
18450  5001     MOVF ltemp0, W, ACCESS
18452  B4D8     BTFSC 0xFD8, 2, ACCESS
18454  D010     BRA 0x8476
74:            				V.flipper = !V.flipper;
18456  0101     MOVLB 0x1
18458  51DB     MOVF 0xDB, W, BANKED
1845A  A4D8     BTFSS 0xFD8, 2, ACCESS
1845C  D002     BRA 0x8462
1845E  0E01     MOVLW 0x1
18460  D001     BRA 0x8464
18462  0E00     MOVLW 0x0
18464  6FDB     MOVWF 0xDB, BANKED
75:            				StartTimer(TMR_FLIPPER, DFLIP);
18466  0EDC     MOVLW 0xDC
18468  6EE6     MOVWF 0xFE6, ACCESS
1846A  0E05     MOVLW 0x5
1846C  6EE6     MOVWF 0xFE6, ACCESS
1846E  0E0B     MOVLW 0xB
18470  6EE6     MOVWF 0xFE6, ACCESS
18472  EC65     CALL 0x1B6CA, 0
18474  F0DB     NOP
76:            			}
77:            		}
78:            	}
79:            	return estatus;
80:            }
18476  52E5     MOVF 0xFE5, F, ACCESS
18478  0012     RETURN 0
81:            
82:            /*
83:             * write character data to vterm
84:             */
85:            uint8_t update_lcd(uint8_t vterm)
86:            {
87:            	vterm = vterm & 0x03;
19AF0  0EFF     MOVLW 0xFF
19AF4  FF8C     NOP
19AF6  F001     NOP
19AF8  0E03     MOVLW 0x3
19AFA  1601     ANDWF ltemp0, F, ACCESS
19AFC  0EFF     MOVLW 0xFF
19B00  F007     NOP
19B02  FFE3     NOP
88:            
89:            	if (D.vterm >= 1 && vterm == 0)
19B04  EE22     LFSR 2, 0xA0A
19B06  F20A     NOP
19B08  A0DF     BTFSS 0xFDF, 0, ACCESS
19B0A  D004     BRA 0x9B14
19B0C  0EFF     MOVLW 0xFF
19B0E  50E3     MOVF 0xFE3, W, ACCESS
19B10  B4D8     BTFSC 0xFD8, 2, ACCESS
19B12  D074     BRA 0x9BFC
90:            		return D.vterm;
91:            
92:            	D.lcd[vterm][0][MAX_LINE] = 0;
19B14  0EFF     MOVLW 0xFF
19B16  50E3     MOVF 0xFE3, W, ACCESS
19B18  0D78     MULLW 0x78
19B1A  0E3E     MOVLW 0x3E
19B1C  24F3     ADDWF 0xFF3, W, ACCESS
19B1E  6ED9     MOVWF 0xFD9, ACCESS
19B20  0E08     MOVLW 0x8
19B22  20F4     ADDWFC 0xFF4, W, ACCESS
19B24  6EDA     MOVWF 0xFDA, ACCESS
19B26  0E00     MOVLW 0x0
19B28  6EDF     MOVWF 0xFDF, ACCESS
93:            	D.lcd[vterm][1][MAX_LINE] = 0;
19B2A  0EFF     MOVLW 0xFF
19B2C  50E3     MOVF 0xFE3, W, ACCESS
19B2E  0D78     MULLW 0x78
19B30  0E66     MOVLW 0x66
19B32  24F3     ADDWF 0xFF3, W, ACCESS
19B34  6ED9     MOVWF 0xFD9, ACCESS
19B36  0E08     MOVLW 0x8
19B38  20F4     ADDWFC 0xFF4, W, ACCESS
19B3A  6EDA     MOVWF 0xFDA, ACCESS
19B3C  0E00     MOVLW 0x0
19B3E  6EDF     MOVWF 0xFDF, ACCESS
94:            	D.lcd[vterm][2][MAX_LINE] = 0;
19B40  0EFF     MOVLW 0xFF
19B42  50E3     MOVF 0xFE3, W, ACCESS
19B44  0D78     MULLW 0x78
19B46  0E8E     MOVLW 0x8E
19B48  24F3     ADDWF 0xFF3, W, ACCESS
19B4A  6ED9     MOVWF 0xFD9, ACCESS
19B4C  0E08     MOVLW 0x8
19B4E  20F4     ADDWFC 0xFF4, W, ACCESS
19B50  6EDA     MOVWF 0xFDA, ACCESS
19B52  0E00     MOVLW 0x0
19B54  6EDF     MOVWF 0xFDF, ACCESS
95:            	wait_lcd_done();
19B56  ECAF     CALL 0x1BF5E, 0
19B58  F0DF     NOP
96:            	eaDogM_WriteStringAtPos(0, 0, D.lcd[vterm][0]);
19B5A  0EFF     MOVLW 0xFF
19B5C  50E3     MOVF 0xFE3, W, ACCESS
19B5E  0D78     MULLW 0x78
19B60  0E2A     MOVLW 0x2A
19B62  6E0B     MOVWF wtemp5, ACCESS
19B64  0E08     MOVLW 0x8
19B66  6E0C     MOVWF 0xC, ACCESS
19B68  50F3     MOVF 0xFF3, W, ACCESS
19B6A  260B     ADDWF wtemp5, F, ACCESS
19B6C  50F4     MOVF 0xFF4, W, ACCESS
19B6E  220C     ADDWFC 0xC, F, ACCESS
19B72  F02F     NOP
19B74  FFE6     NOP
19B78  F033     NOP
19B7A  FFE6     NOP
19B7C  0E00     MOVLW 0x0
19B7E  6EE6     MOVWF 0xFE6, ACCESS
19B80  0E00     MOVLW 0x0
19B82  6EE6     MOVWF 0xFE6, ACCESS
19B84  ECC8     CALL 0x1A790, 0
19B86  F0D3     NOP
97:            	wait_lcd_done();
19B88  ECAF     CALL 0x1BF5E, 0
19B8A  F0DF     NOP
98:            	eaDogM_WriteStringAtPos(1, 0, D.lcd[vterm][1]);
19B8C  0EFF     MOVLW 0xFF
19B8E  50E3     MOVF 0xFE3, W, ACCESS
19B90  0D78     MULLW 0x78
19B92  0E2A     MOVLW 0x2A
19B94  6E0B     MOVWF wtemp5, ACCESS
19B96  0E08     MOVLW 0x8
19B98  6E0C     MOVWF 0xC, ACCESS
19B9A  0E28     MOVLW 0x28
19B9C  260B     ADDWF wtemp5, F, ACCESS
19B9E  0E00     MOVLW 0x0
19BA0  220C     ADDWFC 0xC, F, ACCESS
19BA2  50F3     MOVF 0xFF3, W, ACCESS
19BA4  260B     ADDWF wtemp5, F, ACCESS
19BA6  50F4     MOVF 0xFF4, W, ACCESS
19BA8  220C     ADDWFC 0xC, F, ACCESS
19BAC  F02F     NOP
19BAE  FFE6     NOP
19BB2  F033     NOP
19BB4  FFE6     NOP
19BB6  0E00     MOVLW 0x0
19BB8  6EE6     MOVWF 0xFE6, ACCESS
19BBA  0E01     MOVLW 0x1
19BBC  6EE6     MOVWF 0xFE6, ACCESS
19BBE  ECC8     CALL 0x1A790, 0
19BC0  F0D3     NOP
99:            	wait_lcd_done();
19BC2  ECAF     CALL 0x1BF5E, 0
19BC4  F0DF     NOP
100:           	eaDogM_WriteStringAtPos(2, 0, D.lcd[vterm][2]);
19BC6  0EFF     MOVLW 0xFF
19BC8  50E3     MOVF 0xFE3, W, ACCESS
19BCA  0D78     MULLW 0x78
19BCC  0E2A     MOVLW 0x2A
19BCE  6E0B     MOVWF wtemp5, ACCESS
19BD0  0E08     MOVLW 0x8
19BD2  6E0C     MOVWF 0xC, ACCESS
19BD4  0E50     MOVLW 0x50
19BD6  260B     ADDWF wtemp5, F, ACCESS
19BD8  0E00     MOVLW 0x0
19BDA  220C     ADDWFC 0xC, F, ACCESS
19BDC  50F3     MOVF 0xFF3, W, ACCESS
19BDE  260B     ADDWF wtemp5, F, ACCESS
19BE0  50F4     MOVF 0xFF4, W, ACCESS
19BE2  220C     ADDWFC 0xC, F, ACCESS
19BE6  F02F     NOP
19BE8  FFE6     NOP
19BEC  F033     NOP
19BEE  FFE6     NOP
19BF0  0E00     MOVLW 0x0
19BF2  6EE6     MOVWF 0xFE6, ACCESS
19BF4  0E02     MOVLW 0x2
19BF6  6EE6     MOVWF 0xFE6, ACCESS
19BF8  ECC8     CALL 0x1A790, 0
19BFA  F0D3     NOP
101:           	return D.vterm;
102:           }
19BFC  52E5     MOVF 0xFE5, F, ACCESS
19BFE  0012     RETURN 0
103:           
104:           /*
105:            * set terminal window to 0..3
106:            */
107:           uint8_t set_vterm(const uint8_t vterm)
108:           {
109:           	D.vterm = vterm & 0x03;
1BF04  0EFF     MOVLW 0xFF
1BF08  FF8C     NOP
1BF0A  F00C     NOP
1BF0C  0E03     MOVLW 0x3
1BF0E  160C     ANDWF 0xC, F, ACCESS
1BF10  EE22     LFSR 2, 0xA0A
1BF12  F20A     NOP
1BF14  50DF     MOVF 0xFDF, W, ACCESS
1BF16  180C     XORWF 0xC, W, ACCESS
1BF18  0BFE     ANDLW 0xFE
1BF1A  180C     XORWF 0xC, W, ACCESS
1BF1C  6EDF     MOVWF 0xFDF, ACCESS
110:           	return D.vterm;
111:           }
1BF1E  52E5     MOVF 0xFE5, F, ACCESS
1BF20  0012     RETURN 0
112:           
113:           /*
114:            * return pointer to vterm line buffer
115:            */
116:           char * get_vterm_ptr(const uint8_t line, const uint8_t vterm)
117:           {
118:           	return D.lcd[vterm & 0x03][line & 0x03];
1BA12  0EFE     MOVLW 0xFE
1BA14  50E3     MOVF 0xFE3, W, ACCESS
1BA16  0B03     ANDLW 0x3
1BA18  0D78     MULLW 0x78
1BA1A  0E2A     MOVLW 0x2A
1BA1C  6E01     MOVWF ltemp0, ACCESS
1BA1E  0E08     MOVLW 0x8
1BA20  6E02     MOVWF ttemp5, ACCESS
1BA22  50F3     MOVF 0xFF3, W, ACCESS
1BA24  2601     ADDWF ltemp0, F, ACCESS
1BA26  50F4     MOVF 0xFF4, W, ACCESS
1BA28  2202     ADDWFC ttemp5, F, ACCESS
1BA2A  0EFF     MOVLW 0xFF
1BA2C  50E3     MOVF 0xFE3, W, ACCESS
1BA2E  0B03     ANDLW 0x3
1BA30  0D28     MULLW 0x28
1BA32  50F3     MOVF 0xFF3, W, ACCESS
1BA34  2601     ADDWF ltemp0, F, ACCESS
1BA36  50F4     MOVF 0xFF4, W, ACCESS
1BA38  2202     ADDWFC ttemp5, F, ACCESS
119:           }
1BA3A  52E5     MOVF 0xFE5, F, ACCESS
1BA3C  52E5     MOVF 0xFE5, F, ACCESS
1BA3E  0012     RETURN 0
120:           
121:           void vterm_dump(void)
122:           {
123:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(0, 0), get_vterm_ptr(0, 1));
19672  0E01     MOVLW 0x1
19674  6EE6     MOVWF 0xFE6, ACCESS
19676  0E00     MOVLW 0x0
19678  6EE6     MOVWF 0xFE6, ACCESS
1967A  EC09     CALL 0x1BA12, 0
1967C  F0DD     NOP
19680  F007     NOP
19682  FFE6     NOP
19686  F00B     NOP
19688  FFE6     NOP
1968A  0E00     MOVLW 0x0
1968C  6EE6     MOVWF 0xFE6, ACCESS
1968E  0E00     MOVLW 0x0
19690  6EE6     MOVWF 0xFE6, ACCESS
19692  EC09     CALL 0x1BA12, 0
19694  F0DD     NOP
19698  F007     NOP
1969A  FFE6     NOP
1969E  F00B     NOP
196A0  FFE6     NOP
196A2  0EA4     MOVLW 0xA4
196A4  6EE6     MOVWF 0xFE6, ACCESS
196A6  0EFF     MOVLW 0xFF
196A8  6EE6     MOVWF 0xFE6, ACCESS
196AA  0E31     MOVLW 0x31
196AC  6EE6     MOVWF 0xFE6, ACCESS
196AE  0E01     MOVLW 0x1
196B0  6EE6     MOVWF 0xFE6, ACCESS
196B2  0E08     MOVLW 0x8
196B4  6EE6     MOVWF 0xFE6, ACCESS
196B6  EC00     CALL 0x19C00, 0
196B8  F0CE     NOP
124:           	wait_lcd_done();
196BA  ECAF     CALL 0x1BF5E, 0
196BC  F0DF     NOP
125:           	eaDogM_WriteStringAtPos(0, 0, V.buf);
196BE  0E31     MOVLW 0x31
196C0  6EE6     MOVWF 0xFE6, ACCESS
196C2  0E01     MOVLW 0x1
196C4  6EE6     MOVWF 0xFE6, ACCESS
196C6  0E00     MOVLW 0x0
196C8  6EE6     MOVWF 0xFE6, ACCESS
196CA  0E00     MOVLW 0x0
196CC  6EE6     MOVWF 0xFE6, ACCESS
196CE  ECC8     CALL 0x1A790, 0
196D0  F0D3     NOP
126:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(1, 0), get_vterm_ptr(1, 1));
196D2  0E01     MOVLW 0x1
196D4  6EE6     MOVWF 0xFE6, ACCESS
196D6  0E01     MOVLW 0x1
196D8  6EE6     MOVWF 0xFE6, ACCESS
196DA  EC09     CALL 0x1BA12, 0
196DC  F0DD     NOP
196E0  F007     NOP
196E2  FFE6     NOP
196E6  F00B     NOP
196E8  FFE6     NOP
196EA  0E00     MOVLW 0x0
196EC  6EE6     MOVWF 0xFE6, ACCESS
196EE  0E01     MOVLW 0x1
196F0  6EE6     MOVWF 0xFE6, ACCESS
196F2  EC09     CALL 0x1BA12, 0
196F4  F0DD     NOP
196F8  F007     NOP
196FA  FFE6     NOP
196FE  F00B     NOP
19700  FFE6     NOP
19702  0EA4     MOVLW 0xA4
19704  6EE6     MOVWF 0xFE6, ACCESS
19706  0EFF     MOVLW 0xFF
19708  6EE6     MOVWF 0xFE6, ACCESS
1970A  0E31     MOVLW 0x31
1970C  6EE6     MOVWF 0xFE6, ACCESS
1970E  0E01     MOVLW 0x1
19710  6EE6     MOVWF 0xFE6, ACCESS
19712  0E08     MOVLW 0x8
19714  6EE6     MOVWF 0xFE6, ACCESS
19716  EC00     CALL 0x19C00, 0
19718  F0CE     NOP
127:           	wait_lcd_done();
1971A  ECAF     CALL 0x1BF5E, 0
1971C  F0DF     NOP
128:           	eaDogM_WriteStringAtPos(1, 0, V.buf);
1971E  0E31     MOVLW 0x31
19720  6EE6     MOVWF 0xFE6, ACCESS
19722  0E01     MOVLW 0x1
19724  6EE6     MOVWF 0xFE6, ACCESS
19726  0E00     MOVLW 0x0
19728  6EE6     MOVWF 0xFE6, ACCESS
1972A  0E01     MOVLW 0x1
1972C  6EE6     MOVWF 0xFE6, ACCESS
1972E  ECC8     CALL 0x1A790, 0
19730  F0D3     NOP
129:           	sprintf(V.buf, "vterm %x:%x   ", get_vterm_ptr(2, 0), get_vterm_ptr(2, 1));
19732  0E01     MOVLW 0x1
19734  6EE6     MOVWF 0xFE6, ACCESS
19736  0E02     MOVLW 0x2
19738  6EE6     MOVWF 0xFE6, ACCESS
1973A  EC09     CALL 0x1BA12, 0
1973C  F0DD     NOP
19740  F007     NOP
19742  FFE6     NOP
19746  F00B     NOP
19748  FFE6     NOP
1974A  0E00     MOVLW 0x0
1974C  6EE6     MOVWF 0xFE6, ACCESS
1974E  0E02     MOVLW 0x2
19750  6EE6     MOVWF 0xFE6, ACCESS
19752  EC09     CALL 0x1BA12, 0
19754  F0DD     NOP
19758  F007     NOP
1975A  FFE6     NOP
1975E  F00B     NOP
19760  FFE6     NOP
19762  0EA4     MOVLW 0xA4
19764  6EE6     MOVWF 0xFE6, ACCESS
19766  0EFF     MOVLW 0xFF
19768  6EE6     MOVWF 0xFE6, ACCESS
1976A  0E31     MOVLW 0x31
1976C  6EE6     MOVWF 0xFE6, ACCESS
1976E  0E01     MOVLW 0x1
19770  6EE6     MOVWF 0xFE6, ACCESS
19772  0E08     MOVLW 0x8
19774  6EE6     MOVWF 0xFE6, ACCESS
19776  EC00     CALL 0x19C00, 0
19778  F0CE     NOP
130:           	wait_lcd_done();
1977A  ECAF     CALL 0x1BF5E, 0
1977C  F0DF     NOP
131:           	eaDogM_WriteStringAtPos(2, 0, V.buf);
1977E  0E31     MOVLW 0x31
19780  6EE6     MOVWF 0xFE6, ACCESS
19782  0E01     MOVLW 0x1
19784  6EE6     MOVWF 0xFE6, ACCESS
19786  0E00     MOVLW 0x0
19788  6EE6     MOVWF 0xFE6, ACCESS
1978A  0E02     MOVLW 0x2
1978C  6EE6     MOVWF 0xFE6, ACCESS
1978E  ECC8     CALL 0x1A790, 0
19790  F0D3     NOP
132:           	WaitMs(3000);
19792  0EB8     MOVLW 0xB8
19794  6EE6     MOVWF 0xFE6, ACCESS
19796  0E0B     MOVLW 0xB
19798  6EE6     MOVWF 0xFE6, ACCESS
1979A  EC5A     CALL 0x1B8B4, 0
1979C  F0DC     NOP
133:           }
1979E  0012     RETURN 0
134:           
135:           void vterm_sequence(void)
136:           {
137:           	sprintf(get_vterm_ptr(2, 2), " Mesg %d Stack %d      ", V.msg_error, V.stack);
138:           	switch (V.response.info) {
139:           	case DIS_HELP:
140:           		sprintf(get_vterm_ptr(0, 1), "HELP %s           ", build_date);
141:           		sprintf(get_vterm_ptr(1, 1), "DISPLAY %s        ", build_time);
142:           		break;
143:           	case DIS_CLEAR:
144:           	default:
145:           		sprintf(get_vterm_ptr(0, 0), "                  ");
146:           		sprintf(get_vterm_ptr(1, 0), "                  ");
147:           		sprintf(get_vterm_ptr(0, 2), "                  ");
148:           		sprintf(get_vterm_ptr(1, 2), "                  ");
149:           		break;
150:           	}
151:           }
152:           
153:           /*
154:            * update possible command messages
155:            */
156:           void MyeaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
157:           {
158:           
159:           	wait_lcd_done();
160:           	if (V.response.info == DIS_STR) {
161:           		eaDogM_WriteStringAtPos(r, c, strPtr);
162:           	} else {
163:           		if (V.response.info == DIS_HELP) {
164:           			sprintf(get_vterm_ptr(2, 1), "%s", V.info);
165:           			update_lcd(1);
166:           		} else {
167:           			if ((V.response.info != DIS_STR)) {
168:           				update_lcd(2);
169:           			} else {
170:           				sprintf(get_vterm_ptr(2, 0), "%s", V.info);
171:           				update_lcd(0);
172:           			}
173:           		}
174:           
175:           		if ((V.response.info != DIS_STR) && TimerDone(TMR_INFO))
176:           			V.response.info = DIS_STR;
177:           	}
178:           
179:           	/*
180:           	 * this is for possible message flipping with the HELP button
181:           	 */
182:           	if (D.last_info == DIS_HELP && V.response.info != DIS_HELP) {
183:           		// show some stuff, maybe
184:           	}
185:           
186:           	D.last_info = V.response.info;
187:           	//	DLED = false;
188:           }
189:           
190:           inline D_CODES display_info(void)
191:           {
192:           	return V.response.info;
1C128  F750     NOP
1C12A  F001     NOP
193:           }
1C12C  0012     RETURN 0
194:           
195:           inline D_CODES display_help(void)
196:           {
197:           	return V.response.help_temp;
1C130  F754     NOP
1C132  F001     NOP
198:           }
1C134  0012     RETURN 0
199:           
200:           D_CODES set_display_info(const D_CODES new_response_info)
201:           {
202:           	static D_CODES old_info = DIS_STR;
203:           
204:           	if (TimerDone(TMR_INFO)) {
1BF22  0E07     MOVLW 0x7
1BF24  6EE6     MOVWF 0xFE6, ACCESS
1BF26  EC8B     CALL 0x1BB16, 0
1BF28  F0DD     NOP
1BF2A  5001     MOVF ltemp0, W, ACCESS
1BF2C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BF2E  D006     BRA 0xBF3C
205:           		old_info = V.response.info;
1BF30  0101     MOVLB 0x1
1BF32  51D4     MOVF 0xD4, W, BANKED
206:           		V.response.info = new_response_info;
1BF34  0EFF     MOVLW 0xFF
1BF38  FF8C     NOP
1BF3A  F1D4     NOP
207:           	}
208:           	return old_info;
209:           }
1BF3C  52E5     MOVF 0xFE5, F, ACCESS
1BF3E  0012     RETURN 0
210:           
211:           D_CODES set_temp_display_help(const D_CODES new_response_info)
212:           {
213:           	static D_CODES old_info;
214:           
215:           	old_info = V.response.help_temp;
1C066  0101     MOVLB 0x1
1C068  51D5     MOVF 0xD5, W, BANKED
216:           	V.response.help_temp = new_response_info;
1C06A  0EFF     MOVLW 0xFF
1C06E  FF8C     NOP
1C070  F1D5     NOP
217:           	return old_info;
218:           }
1C072  52E5     MOVF 0xFE5, F, ACCESS
1C074  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/uart2.c  -----------------------------
1:             /**
2:               UART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.30
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include <xc.h>
51:            #include "uart2.h"
52:            #include "interrupt_manager.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            #define UART2_TX_BUFFER_SIZE 64
58:            #define UART2_RX_BUFFER_SIZE 255
59:            
60:            /**
61:              Section: Global Variables
62:            */
63:            
64:            static volatile uint8_t uart2TxHead = 0;
65:            static volatile uint8_t uart2TxTail = 0;
66:            static volatile uint8_t uart2TxBuffer[UART2_TX_BUFFER_SIZE];
67:            volatile uint8_t uart2TxBufferRemaining;
68:            
69:            static volatile uint8_t uart2RxHead = 0;
70:            static volatile uint8_t uart2RxTail = 0;
71:            static volatile uint8_t uart2RxBuffer[UART2_RX_BUFFER_SIZE];
72:            volatile uint8_t uart2RxCount;
73:            
74:            /**
75:              Section: UART2 APIs
76:            */
77:            
78:            void UART2_Initialize(void)
79:            {
80:                // Disable interrupts before changing states
81:                PIE6bits.U2RXIE = 0;
1B124  0139     MOVLB 0x39
1B126  9596     BCF utctime, 2, BANKED
82:                UART2_SetRxInterruptHandler(UART2_Receive_ISR);
1B128  0EA8     MOVLW 0xA8
1B12A  6EE6     MOVWF 0xFE6, ACCESS
1B12C  0EBE     MOVLW 0xBE
1B12E  6EE6     MOVWF 0xFE6, ACCESS
1B130  0E01     MOVLW 0x1
1B132  6EE6     MOVWF 0xFE6, ACCESS
1B134  ECB3     CALL 0x1BB66, 0
1B136  F0DD     NOP
83:                PIE6bits.U2TXIE = 0;
1B138  0139     MOVLB 0x39
1B13A  9796     BCF utctime, 3, BANKED
84:                UART2_SetTxInterruptHandler(UART2_Transmit_ISR);
1B13C  0E98     MOVLW 0x98
1B13E  6EE6     MOVWF 0xFE6, ACCESS
1B140  0EBA     MOVLW 0xBA
1B142  6EE6     MOVWF 0xFE6, ACCESS
1B144  0E01     MOVLW 0x1
1B146  6EE6     MOVWF 0xFE6, ACCESS
1B148  EC9F     CALL 0x1BB3E, 0
1B14A  F0DD     NOP
85:            
86:                // Set the UART2 module to the options selected in the user interface.
87:            
88:                // P1L 0; 
89:                U2P1L = 0x00;
1B14C  013D     MOVLB 0x3D
1B14E  6BD4     CLRF 0xD4, BANKED
90:            
91:                // P2L 0; 
92:                U2P2L = 0x00;
1B150  6BD6     CLRF 0xD6, BANKED
93:            
94:                // P3L 0; 
95:                U2P3L = 0x00;
1B152  6BD8     CLRF 0xD8, BANKED
96:            
97:                // BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
98:                U2CON0 = 0xB0;
1B154  0EB0     MOVLW 0xB0
1B156  6FDA     MOVWF 0xDA, BANKED
99:            
100:               // RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
101:               U2CON1 = 0x80;
1B158  0E80     MOVLW 0x80
1B15A  6FDB     MOVWF 0xDB, BANKED
102:           
103:               // TXPOL not inverted; FLO off; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
104:               U2CON2 = 0x00;
1B15C  6BDC     CLRF 0xDC, BANKED
105:           
106:               // BRGL 130; 
107:               U2BRGL = 0x82;
1B15E  0E82     MOVLW 0x82
1B160  6FDD     MOVWF 0xDD, BANKED
108:           
109:               // BRGH 6; 
110:               U2BRGH = 0x06;
1B162  0E06     MOVLW 0x6
1B164  6FDE     MOVWF 0xDE, BANKED
111:           
112:               // STPMD in middle of first Stop bit; TXWRE No error; 
113:               U2FIFO = 0x00;
1B166  6BDF     CLRF 0xDF, BANKED
114:           
115:               // ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
116:               U2UIR = 0x00;
1B168  6BE0     CLRF 0xE0, BANKED
117:           
118:               // ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
119:               U2ERRIR = 0x00;
1B16A  6BE1     CLRF 0xE1, BANKED
120:           
121:               // TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
122:               U2ERRIE = 0x00;
1B16C  6BE2     CLRF 0xE2, BANKED
123:           
124:           
125:               // initializing the driver state
126:               uart2TxHead = 0;
1B16E  0100     MOVLB 0x0
1B170  6BCD     CLRF uart2TxHead, BANKED
127:               uart2TxTail = 0;
1B172  6A45     CLRF uart2TxTail, ACCESS
128:               uart2TxBufferRemaining = sizeof(uart2TxBuffer);
1B174  0E40     MOVLW 0x40
1B176  6E44     MOVWF uart2TxBufferRemaining, ACCESS
129:               uart2RxHead = 0;
1B178  6A43     CLRF uart2RxHead, ACCESS
130:               uart2RxTail = 0;
1B17A  6BCC     CLRF uart2RxTail, BANKED
131:               uart2RxCount = 0;
1B17C  6BCB     CLRF uart2RxCount, BANKED
132:           
133:               // enable receive interrupt
134:               PIE6bits.U2RXIE = 1;
1B17E  0139     MOVLB 0x39
1B180  8596     BSF utctime, 2, BANKED
135:           }
1B182  0012     RETURN 0
136:           
137:           uint8_t UART2_is_rx_ready(void)
138:           {
139:               return uart2RxCount;
140:           }
141:           
142:           uint8_t UART2_is_tx_ready(void)
143:           {
144:               return uart2TxBufferRemaining;
145:           }
146:           
147:           bool UART2_is_tx_done(void)
148:           {
149:               return U2ERRIRbits.TXMTIF;
150:           }
151:           
152:           uint8_t UART2_Read(void)
153:           {
154:               uint8_t readValue  = 0;
155:               
156:               while(0 == uart2RxCount)
157:               {
158:               }
159:           
160:               readValue = uart2RxBuffer[uart2RxTail++];
161:              	if(sizeof(uart2RxBuffer) <= uart2RxTail)
162:               {
163:                   uart2RxTail = 0;
164:               }
165:               PIE6bits.U2RXIE = 0;
166:               uart2RxCount--;
167:               PIE6bits.U2RXIE = 1;
168:           
169:               return readValue;
170:           }
171:           
172:           void UART2_Write(uint8_t txData)
173:           {
174:               while(0 == uart2TxBufferRemaining)
175:               {
176:               }
177:           
178:               if(0 == PIE6bits.U2TXIE)
179:               {
180:                   U2TXB = txData;
181:               }
182:               else
183:               {
184:                   PIE6bits.U2TXIE = 0;
185:                   uart2TxBuffer[uart2TxHead++] = txData;
186:                   if(sizeof(uart2TxBuffer) <= uart2TxHead)
187:                   {
188:                       uart2TxHead = 0;
189:                   }
190:                   uart2TxBufferRemaining--;
191:               }
192:               PIE6bits.U2TXIE = 1;
193:           }
194:           
195:           void __interrupt(irq(U2TX),base(8)) UART2_tx_vect_isr()
1BCF8  EE14     LFSR 1, 0x115E
1BCFA  F15E     NOP
196:           {   
197:               if(UART2_TxInterruptHandler)
1BCFC  0100     MOVLB 0x0
1BCFE  51B4     MOVF UART2_TxInterruptHandler, W, BANKED
1BD00  11B5     IORWF 0xB5, W, BANKED
1BD02  11B6     IORWF 0xB6, W, BANKED
1BD04  B4D8     BTFSC 0xFD8, 2, ACCESS
1BD06  0011     RETFIE 1
198:               {
199:                   UART2_TxInterruptHandler();
1BD08  D801     RCALL 0xBD0C
1BD0A  0011     RETFIE 1
1BD0C  0005     PUSH
1BD0E  6EFA     MOVWF 0xFFA, ACCESS
1BD10  51B4     MOVF UART2_TxInterruptHandler, W, BANKED
1BD12  6EFD     MOVWF 0xFFD, ACCESS
1BD14  51B5     MOVF 0xB5, W, BANKED
1BD16  6EFE     MOVWF 0xFFE, ACCESS
1BD18  51B6     MOVF 0xB6, W, BANKED
1BD1A  6EFF     MOVWF 0xFFF, ACCESS
1BD1C  50FA     MOVF 0xFFA, W, ACCESS
1BD1E  0012     RETURN 0
200:               }
201:           }
202:           
203:           void __interrupt(irq(U2RX),base(8)) UART2_rx_vect_isr()
204:           {
205:               if(UART2_RxInterruptHandler)
1BD24  0100     MOVLB 0x0
1BD26  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1BD28  11B8     IORWF 0xB8, W, BANKED
1BD2A  11B9     IORWF 0xB9, W, BANKED
1BD2C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BD2E  0011     RETFIE 1
206:               {
207:                   UART2_RxInterruptHandler();
1BD30  D801     RCALL 0xBD34
208:               }
209:           }
210:           
211:           
212:           
213:           void UART2_Transmit_ISR(void)
214:           {
215:               // use this default transmit interrupt handler code
216:               if(sizeof(uart2TxBuffer) > uart2TxBufferRemaining)
1BA98  0E40     MOVLW 0x40
1BA9A  6044     CPFSLT uart2TxBufferRemaining, ACCESS
1BA9C  D010     BRA 0xBABE
217:               {
218:                   U2TXB = uart2TxBuffer[uart2TxTail++];
1BA9E  0E00     MOVLW 0x0
1BAA0  2445     ADDWF uart2TxTail, W, ACCESS
1BAA2  6ED9     MOVWF 0xFD9, ACCESS
1BAA4  6ADA     CLRF 0xFDA, ACCESS
1BAA6  0E03     MOVLW 0x3
1BAA8  22DA     ADDWFC 0xFDA, F, ACCESS
1BAAA  50DF     MOVF 0xFDF, W, ACCESS
1BAAC  013D     MOVLB 0x3D
1BAAE  6FD2     MOVWF 0xD2, BANKED
1BAB0  2A45     INCF uart2TxTail, F, ACCESS
219:                  if(sizeof(uart2TxBuffer) <= uart2TxTail)
1BAB2  0E3F     MOVLW 0x3F
1BAB4  6445     CPFSGT uart2TxTail, ACCESS
1BAB6  D001     BRA 0xBABA
220:                   {
221:                       uart2TxTail = 0;
1BAB8  6A45     CLRF uart2TxTail, ACCESS
222:                   }
223:                   uart2TxBufferRemaining++;
1BABA  2A44     INCF uart2TxBufferRemaining, F, ACCESS
224:               }
1BABC  0012     RETURN 0
225:               else
226:               {
227:                   PIE6bits.U2TXIE = 0;
1BABE  0139     MOVLB 0x39
1BAC0  9796     BCF utctime, 3, BANKED
228:               }
229:               
230:               // or set custom function using UART2_SetTxInterruptHandler()
231:           }
1BAC2  0012     RETURN 0
1BD20  EE14     LFSR 1, 0x115E
1BD22  F15E     NOP
1BD24  0100     MOVLB 0x0
1BD26  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1BD28  11B8     IORWF 0xB8, W, BANKED
1BD2A  11B9     IORWF 0xB9, W, BANKED
1BD2C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BD2E  0011     RETFIE 1
1BD30  D801     RCALL 0xBD34
1BD32  0011     RETFIE 1
1BD34  0005     PUSH
1BD36  6EFA     MOVWF 0xFFA, ACCESS
1BD38  51B7     MOVF UART2_RxInterruptHandler, W, BANKED
1BD3A  6EFD     MOVWF 0xFFD, ACCESS
1BD3C  51B8     MOVF 0xB8, W, BANKED
1BD3E  6EFE     MOVWF 0xFFE, ACCESS
1BD40  51B9     MOVF 0xB9, W, BANKED
1BD42  6EFF     MOVWF 0xFFF, ACCESS
1BD44  50FA     MOVF 0xFFA, W, ACCESS
1BD46  0012     RETURN 0
232:           
233:           void UART2_Receive_ISR(void)
234:           {
235:               // use this default receive interrupt handler code
236:               uart2RxBuffer[uart2RxHead++] = U2RXB;
1BEA8  0E00     MOVLW 0x0
1BEAA  2443     ADDWF uart2RxHead, W, ACCESS
1BEAC  6ED9     MOVWF 0xFD9, ACCESS
1BEAE  6ADA     CLRF 0xFDA, ACCESS
1BEB0  0E04     MOVLW 0x4
1BEB2  22DA     ADDWFC 0xFDA, F, ACCESS
1BEB6  F743     NOP
1BEB8  FFDF     NOP
1BEBA  2A43     INCF uart2RxHead, F, ACCESS
237:               if(sizeof(uart2RxBuffer) <= uart2RxHead)
1BEBC  2843     INCF uart2RxHead, W, ACCESS
1BEBE  B4D8     BTFSC 0xFD8, 2, ACCESS
238:               {
239:                   uart2RxHead = 0;
1BEC0  6A43     CLRF uart2RxHead, ACCESS
240:               }
241:               uart2RxCount++;
1BEC2  0100     MOVLB 0x0
1BEC4  2BCB     INCF uart2RxCount, F, BANKED
242:               
243:               // or set custom function using UART2_SetRxInterruptHandler()
244:           }
1BEC6  0012     RETURN 0
245:           
246:           
247:           
248:           void UART2_SetRxInterruptHandler(void (* InterruptHandler)(void)){
249:               UART2_RxInterruptHandler = InterruptHandler;
1BB66  50E1     MOVF 0xFE1, W, ACCESS
1BB68  0FFD     ADDLW 0xFD
1BB6A  6ED9     MOVWF 0xFD9, ACCESS
1BB6C  50E2     MOVF 0xFE2, W, ACCESS
1BB6E  6EDA     MOVWF 0xFDA, ACCESS
1BB70  0EFF     MOVLW 0xFF
1BB72  22DA     ADDWFC 0xFDA, F, ACCESS
1BB76  FF78     NOP
1BB78  F0B7     NOP
1BB7C  FF78     NOP
1BB7E  F0B8     NOP
1BB82  FF74     NOP
1BB84  F0B9     NOP
250:           }
1BB86  52E5     MOVF 0xFE5, F, ACCESS
1BB88  52E5     MOVF 0xFE5, F, ACCESS
1BB8A  52E5     MOVF 0xFE5, F, ACCESS
1BB8C  0012     RETURN 0
251:           
252:           void UART2_SetTxInterruptHandler(void (* InterruptHandler)(void)){
253:               UART2_TxInterruptHandler = InterruptHandler;
1BB3E  50E1     MOVF 0xFE1, W, ACCESS
1BB40  0FFD     ADDLW 0xFD
1BB42  6ED9     MOVWF 0xFD9, ACCESS
1BB44  50E2     MOVF 0xFE2, W, ACCESS
1BB46  6EDA     MOVWF 0xFDA, ACCESS
1BB48  0EFF     MOVLW 0xFF
1BB4A  22DA     ADDWFC 0xFDA, F, ACCESS
1BB4E  FF78     NOP
1BB50  F0B4     NOP
1BB54  FF78     NOP
1BB56  F0B5     NOP
1BB5A  FF74     NOP
1BB5C  F0B6     NOP
254:           }
1BB5E  52E5     MOVF 0xFE5, F, ACCESS
1BB60  52E5     MOVF 0xFE5, F, ACCESS
1BB62  52E5     MOVF 0xFE5, F, ACCESS
1BB64  0012     RETURN 0
255:           
256:           /* stuff the uart2 receive buffer with testing data */
257:           void UART2_put_buffer(uint8_t bufData)
258:           {
259:           	PIE6bits.U2RXIE = 0;
260:           	uart2RxBuffer[uart2RxHead++] = bufData;
261:           	if (sizeof(uart2RxBuffer) <= uart2RxHead) {
262:           		uart2RxHead = 0;
263:           	}
264:           
265:           	uart2RxCount++;
266:           	PIE6bits.U2RXIE = 1;
267:           }
268:           /**
269:             End of File
270:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/uart1.c  -----------------------------
1:             /**
2:               UART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 uart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the UART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for UART1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.30
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB             :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include <xc.h>
51:            #include "uart1.h"
52:            #include "interrupt_manager.h"
53:            #include "pin_manager.h"
54:            
55:            /**
56:              Section: Macro Declarations
57:             */
58:            #define UART1_TX_BUFFER_SIZE 8
59:            #define UART1_RX_BUFFER_SIZE 8
60:            
61:            /**
62:              Section: Global Variables
63:             */
64:            
65:            
66:            static volatile uint8_t uart1RxHead = 0;
67:            static volatile uint8_t uart1RxTail = 0;
68:            static volatile uint8_t uart1RxBuffer[UART1_RX_BUFFER_SIZE];
69:            volatile uint8_t uart1RxCount;
70:            
71:            /**
72:              Section: UART1 APIs
73:             */
74:            
75:            void UART1_Initialize(void)
76:            {
77:            	// Disable interrupts before changing states
78:            	PIE3bits.U1RXIE = 0;
1B460  0139     MOVLB 0x39
1B462  9793     BCF 0x93, 3, BANKED
79:            	UART1_SetRxInterruptHandler(UART1_Receive_ISR);
1B464  0E40     MOVLW 0x40
1B466  6EE6     MOVWF 0xFE6, ACCESS
1B468  0EBF     MOVLW 0xBF
1B46A  6EE6     MOVWF 0xFE6, ACCESS
1B46C  0E01     MOVLW 0x1
1B46E  6EE6     MOVWF 0xFE6, ACCESS
1B470  ECC7     CALL 0x1BB8E, 0
1B472  F0DD     NOP
80:            
81:            	// Set the UART1 module to the options selected in the user interface.
82:            
83:            	// P1L 0; 
84:            	U1P1L = 0x00;
1B474  013D     MOVLB 0x3D
1B476  6BEC     CLRF 0xEC, BANKED
85:            
86:            	// P1H 0; 
87:            	U1P1H = 0x00;
1B478  6BED     CLRF 0xED, BANKED
88:            
89:            	// P2L 0; 
90:            	U1P2L = 0x00;
1B47A  6BEE     CLRF 0xEE, BANKED
91:            
92:            	// P2H 0; 
93:            	U1P2H = 0x00;
1B47C  6BEF     CLRF 0xEF, BANKED
94:            
95:            	// P3L 0; 
96:            	U1P3L = 0x00;
1B47E  6BF0     CLRF __pdataBANK0, BANKED
97:            
98:            	// P3H 0; 
99:            	U1P3H = 0x00;
1B480  6BF1     CLRF 0xF1, BANKED
100:           
101:           	// BRGS high speed; MODE Asynchronous 8-bit mode; RXEN enabled; TXEN enabled; ABDEN disabled; 
102:           	U1CON0 = 0xB0;
1B482  0EB0     MOVLW 0xB0
1B484  6FF2     MOVWF 0xF2, BANKED
103:           
104:           	// RXBIMD Set RXBKIF on rising RX input; BRKOVR disabled; WUE disabled; SENDB disabled; ON enabled; 
105:           	U1CON1 = 0x80;
1B486  0E80     MOVLW 0x80
1B488  6FF3     MOVWF 0xF3, BANKED
106:           
107:           	// TXPOL not inverted; FLO off; C0EN Checksum Mode 0; RXPOL not inverted; RUNOVF RX input shifter stops all activity; STP Transmit 1Stop bit, receiver verifies first Stop bit; 
108:           	U1CON2 = 0x00;
1B48A  6BF4     CLRF 0xF4, BANKED
109:           
110:               // BRGL 138; 
111:               U1BRGL = 0x8A;
1B48C  0E8A     MOVLW 0x8A
1B48E  6FF5     MOVWF 0xF5, BANKED
112:           
113:               // BRGH 0; 
114:               U1BRGH = 0x00;
1B490  6BF6     CLRF 0xF6, BANKED
115:           
116:           	// STPMD in middle of first Stop bit; TXWRE No error; 
117:           	U1FIFO = 0x00;
1B492  6BF7     CLRF H, BANKED
118:           
119:           	// ABDIF Auto-baud not enabled or not complete; WUIF WUE not enabled by software; ABDIE disabled; 
120:           	U1UIR = 0x00;
1B494  6BF8     CLRF 0xF8, BANKED
121:           
122:           	// ABDOVF Not overflowed; TXCIF 0; RXBKIF No Break detected; RXFOIF not overflowed; CERIF No Checksum error; 
123:           	U1ERRIR = 0x00;
1B496  6BF9     CLRF 0xF9, BANKED
124:           
125:           	// TXCIE disabled; FERIE disabled; TXMTIE disabled; ABDOVE disabled; CERIE disabled; RXFOIE disabled; PERIE disabled; RXBKIE disabled; 
126:           	U1ERRIE = 0x00;
1B498  6BFA     CLRF 0xFA, BANKED
127:           
128:           
129:           	uart1RxHead = 0;
1B49A  6A47     CLRF uart1RxHead, ACCESS
130:           	uart1RxTail = 0;
1B49C  6A46     CLRF uart1RxTail, ACCESS
131:           	uart1RxCount = 0;
1B49E  0100     MOVLB 0x0
1B4A0  6BCE     CLRF uart1RxCount, BANKED
132:           
133:           	// enable receive interrupt
134:           	PIE3bits.U1RXIE = 1;
1B4A2  0139     MOVLB 0x39
1B4A4  8793     BSF 0x93, 3, BANKED
135:           }
1B4A6  0012     RETURN 0
136:           
137:           uint8_t UART1_is_rx_ready(void)
138:           {
139:           	return uart1RxCount;
140:           }
141:           
142:           bool UART1_is_tx_ready(void)
143:           {
144:               return (bool)(PIR3bits.U1TXIF && U1CON0bits.TXEN);
145:           }
146:           
147:           bool UART1_is_tx_done(void)
148:           {
149:           	return U1ERRIRbits.TXMTIF;
150:           }
151:           
152:           uint8_t UART1_Read(void)
153:           {
154:               uint8_t readValue  = 0;
155:           
156:               while(0 == uart1RxCount)
157:               {
158:           	}
159:           
160:           	readValue = uart1RxBuffer[uart1RxTail++];
161:              	if(sizeof(uart1RxBuffer) <= uart1RxTail)
162:               {
163:           		uart1RxTail = 0;
164:           	}
165:           	PIE3bits.U1RXIE = 0;
166:           	uart1RxCount--;
167:           	PIE3bits.U1RXIE = 1;
168:           
169:           	return readValue;
170:           }
171:           
172:           void UART1_Write(uint8_t txData)
173:           {
174:               while(0 == PIR3bits.U1TXIF)
175:               {
176:           	}
177:           
178:               U1TXB = txData;    // Write the data byte to the USART.
179:           		}
180:           	
181:           void __interrupt(irq(U1RX),base(8)) UART1_rx_vect_isr()
1BCD0  EE14     LFSR 1, 0x115E
182:           {
183:               if(UART1_RxInterruptHandler)
1BCD4  0100     MOVLB 0x0
1BCD6  51B1     MOVF UART1_RxInterruptHandler, W, BANKED
1BCD8  11B2     IORWF 0xB2, W, BANKED
1BCDA  11B3     IORWF 0xB3, W, BANKED
1BCDC  B4D8     BTFSC 0xFD8, 2, ACCESS
1BCDE  0011     RETFIE 1
184:           {
185:           		UART1_RxInterruptHandler();
1BCE0  D801     RCALL 0xBCE4
1BCE2  0011     RETFIE 1
1BCE4  0005     PUSH
1BCE6  6EFA     MOVWF 0xFFA, ACCESS
1BCE8  51B1     MOVF UART1_RxInterruptHandler, W, BANKED
1BCEA  6EFD     MOVWF 0xFFD, ACCESS
1BCEC  51B2     MOVF 0xB2, W, BANKED
1BCEE  6EFE     MOVWF 0xFFE, ACCESS
1BCF0  51B3     MOVF 0xB3, W, BANKED
1BCF2  6EFF     MOVWF 0xFFF, ACCESS
1BCF4  50FA     MOVF 0xFFA, W, ACCESS
1BCF6  0012     RETURN 0
186:           	}
187:           }
188:           
189:           
190:           
191:           
192:           void UART1_Receive_ISR(void)
193:           {
194:           	// use this default receive interrupt handler code
195:           	uart1RxBuffer[uart1RxHead++] = U1RXB;
1BF40  5047     MOVF uart1RxHead, W, ACCESS
1BF42  0F6C     ADDLW 0x6C
1BF44  6ED9     MOVWF 0xFD9, ACCESS
1BF46  6ADA     CLRF 0xFDA, ACCESS
1BF4A  F7A3     NOP
1BF4C  FFDF     NOP
1BF4E  2A47     INCF uart1RxHead, F, ACCESS
196:               if(sizeof(uart1RxBuffer) <= uart1RxHead)
1BF50  0E07     MOVLW 0x7
1BF52  6447     CPFSGT uart1RxHead, ACCESS
1BF54  D001     BRA 0xBF58
197:               {
198:           		uart1RxHead = 0;
1BF56  6A47     CLRF uart1RxHead, ACCESS
199:           	}
200:           	uart1RxCount++;
1BF58  0100     MOVLB 0x0
1BF5A  2BCE     INCF uart1RxCount, F, BANKED
201:           
202:           	// or set custom function using UART1_SetRxInterruptHandler()
203:           }
1BCF8  EE14     LFSR 1, 0x115E
1BF5C  0012     RETURN 0
204:           
205:           
206:           
207:           void UART1_SetRxInterruptHandler(void (* InterruptHandler)(void)){
208:           	UART1_RxInterruptHandler = InterruptHandler;
1BB8E  50E1     MOVF 0xFE1, W, ACCESS
1BB90  0FFD     ADDLW 0xFD
1BB92  6ED9     MOVWF 0xFD9, ACCESS
1BB94  50E2     MOVF 0xFE2, W, ACCESS
1BB96  6EDA     MOVWF 0xFDA, ACCESS
1BB98  0EFF     MOVLW 0xFF
1BB9A  22DA     ADDWFC 0xFDA, F, ACCESS
1BB9E  FF78     NOP
1BBA0  F0B1     NOP
1BBA4  FF78     NOP
1BBA6  F0B2     NOP
1BBAA  FF74     NOP
1BBAC  F0B3     NOP
209:           }
1BBAE  52E5     MOVF 0xFE5, F, ACCESS
1BBB0  52E5     MOVF 0xFE5, F, ACCESS
1BBB2  52E5     MOVF 0xFE5, F, ACCESS
1BBB4  0012     RETURN 0
210:           
211:           
212:           /* stuff the uart1 receive buffer with testing data */
213:           void UART1_put_buffer(uint8_t bufData)
214:           {
215:           	PIE3bits.U1RXIE = 0;
216:           	uart1RxBuffer[uart1RxHead++] = bufData;
217:           	if (sizeof(uart1RxBuffer) <= uart1RxHead) {
218:           		uart1RxHead = 0;
219:           	}
220:           
221:           	uart1RxCount++;
222:           	PIE3bits.U1RXIE = 1;
223:           }
224:           /**
225:             End of File
226:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr6.c  ------------------------------
1:             /**
2:               TMR6 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr6.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR6 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR6.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr6.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            #include "../timers.h"
56:            
57:            extern struct V_data V;
58:            extern volatile uint16_t tickCount[TMR_COUNT];
59:            
60:            /**
61:              Section: Global Variables Definitions
62:            */
63:            
64:            void (*TMR6_InterruptHandler)(void);
65:            
66:            /**
67:              Section: TMR6 APIs
68:            */
69:            
70:            void TMR6_Initialize(void)
71:            {
72:                // Set TMR6 to the options selected in the User Interface
73:            
74:                // T6CS FOSC/4; 
75:                T6CLKCON = 0x01;
1BAC4  0E01     MOVLW 0x1
1BAC6  6E96     MOVWF 0xF96, ACCESS
76:            
77:                // T6PSYNC Not Synchronized; T6MODE Software control; T6CKPOL Rising Edge; T6CKSYNC Not Synchronized; 
78:                T6HLT = 0x00;
1BAC8  6A95     CLRF 0xF95, ACCESS
79:            
80:                // T6RSEL T6CKIPPS pin; 
81:                T6RST = 0x00;
1BACA  6A97     CLRF 0xF97, ACCESS
82:            
83:                // PR6 124; 
84:                T6PR = 0x7C;
1BACC  0E7C     MOVLW 0x7C
1BACE  6E93     MOVWF 0xF93, ACCESS
85:            
86:                // TMR6 0; 
87:                T6TMR = 0x00;
1BAD0  6A92     CLRF 0xF92, ACCESS
88:            
89:                // Clearing IF flag before enabling the interrupt.
90:                PIR9bits.TMR6IF = 0;
1BAD2  0139     MOVLB 0x39
1BAD4  91A9     BCF 0xA9, 0, BANKED
91:            
92:                // Enabling TMR6 interrupt.
93:                PIE9bits.TMR6IE = 1;
1BAD6  8199     BSF 0x99, 0, BANKED
94:            
95:                // Set Default Interrupt Handler
96:                TMR6_SetInterruptHandler(TMR6_DefaultInterruptHandler);
1BAD8  0E36     MOVLW 0x36
1BADA  6EE6     MOVWF 0xFE6, ACCESS
1BADC  0EB3     MOVLW 0xB3
1BADE  6EE6     MOVWF 0xFE6, ACCESS
1BAE0  0E01     MOVLW 0x1
1BAE2  6EE6     MOVWF 0xFE6, ACCESS
1BAE4  ECDB     CALL 0x1BBB6, 0
1BAE6  F0DD     NOP
97:            
98:                // T6CKPS 1:64; T6OUTPS 1:1; TMR6ON on; 
99:                T6CON = 0xE0;
1BAE8  0EE0     MOVLW 0xE0
1BAEA  6E94     MOVWF 0xF94, ACCESS
100:           }
1BAEC  0012     RETURN 0
101:           
102:           void TMR6_ModeSet(TMR6_HLT_MODE mode)
103:           {
104:              // Configure different types HLT mode
105:               T6HLTbits.MODE = mode;
106:           }
107:           
108:           void TMR6_ExtResetSourceSet(TMR6_HLT_EXT_RESET_SOURCE reset)
109:           {
110:               //Configure different types of HLT external reset source
111:               T6RSTbits.RSEL = reset;
112:           }
113:           
114:           void TMR6_Start(void)
115:           {
116:               // Start the Timer by writing to TMRxON bit
117:               T6CONbits.TMR6ON = 1;
118:           }
119:           
120:           void TMR6_StartTimer(void)
121:           {
122:               TMR6_Start();
123:           }
124:           
125:           void TMR6_Stop(void)
126:           {
127:               // Stop the Timer by writing to TMRxON bit
128:               T6CONbits.TMR6ON = 0;
129:           }
130:           
131:           void TMR6_StopTimer(void)
132:           {
133:               TMR6_Stop();
134:           }
135:           
136:           uint8_t TMR6_Counter8BitGet(void)
137:           {
138:               uint8_t readVal;
139:           
140:               readVal = TMR6;
141:           
142:               return readVal;
143:           }
144:           
145:           uint8_t TMR6_ReadTimer(void)
146:           {
147:               return TMR6_Counter8BitGet();
148:           }
149:           
150:           void TMR6_Counter8BitSet(uint8_t timerVal)
151:           {
152:               // Write to the Timer6 register
153:               TMR6 = timerVal;
154:           }
155:           
156:           void TMR6_WriteTimer(uint8_t timerVal)
157:           {
158:               TMR6_Counter8BitSet(timerVal);
159:           }
160:           
161:           void TMR6_Period8BitSet(uint8_t periodVal)
162:           {
163:              PR6 = periodVal;
164:           }
165:           
166:           void TMR6_LoadPeriodRegister(uint8_t periodVal)
167:           {
168:              TMR6_Period8BitSet(periodVal);
169:           }
170:           
171:           void __interrupt(irq(TMR6),base(8)) TMR6_ISR()
1BF96  F004     NOP
1BF98  F026     NOP
1BF9A  EE14     LFSR 1, 0x115E
1BF9C  F15E     NOP
172:           {
173:           
174:               // clear the TMR6 interrupt flag
175:               PIR9bits.TMR6IF = 0;
1BF9E  0139     MOVLB 0x39
1BFA0  91A9     BCF 0xA9, 0, BANKED
176:           
177:               // ticker function call;
178:               // ticker is 1 -> Callback function gets called everytime this ISR executes
179:               TMR6_CallBack();
1BFA2  EC10     CALL 0x1BE20, 0
1BFA4  F0DF     NOP
180:           }
1BFA8  F098     NOP
1BFAA  F001     NOP
1BFAC  0011     RETFIE 1
181:           
182:           void TMR6_CallBack(void)
183:           {
184:               // Add your custom callback code here
185:               // this code executes every TMR6_INTERRUPT_TICKER_FACTOR periods of TMR6
186:               if(TMR6_InterruptHandler)
1BE20  0100     MOVLB 0x0
1BE22  51A8     MOVF TMR6_InterruptHandler, W, BANKED
1BE24  11A9     IORWF 0xA9, W, BANKED
1BE26  11AA     IORWF 0xAA, W, BANKED
1BE28  B4D8     BTFSC 0xFD8, 2, ACCESS
1BE2A  0012     RETURN 0
187:               {
188:                   TMR6_InterruptHandler();
1BE2C  D801     RCALL 0xBE30
1BE2E  0012     RETURN 0
1BE30  0005     PUSH
1BE32  6EFA     MOVWF 0xFFA, ACCESS
1BE34  51A8     MOVF TMR6_InterruptHandler, W, BANKED
1BE36  6EFD     MOVWF 0xFFD, ACCESS
1BE38  51A9     MOVF 0xA9, W, BANKED
1BE3A  6EFE     MOVWF 0xFFE, ACCESS
1BE3C  51AA     MOVF 0xAA, W, BANKED
1BE3E  6EFF     MOVWF 0xFFF, ACCESS
1BE40  50FA     MOVF 0xFFA, W, ACCESS
1BE42  0012     RETURN 0
189:               }
190:           }
191:           
192:           void TMR6_SetInterruptHandler(void (* InterruptHandler)(void)){
193:               TMR6_InterruptHandler = InterruptHandler;
1BBB6  50E1     MOVF 0xFE1, W, ACCESS
1BBB8  0FFD     ADDLW 0xFD
1BBBA  6ED9     MOVWF 0xFD9, ACCESS
1BBBC  50E2     MOVF 0xFE2, W, ACCESS
1BBBE  6EDA     MOVWF 0xFDA, ACCESS
1BBC0  0EFF     MOVLW 0xFF
1BBC2  22DA     ADDWFC 0xFDA, F, ACCESS
1BBC6  FF78     NOP
1BBC8  F0A8     NOP
1BBCC  FF78     NOP
1BBCE  F0A9     NOP
1BBD2  FF74     NOP
1BBD4  F0AA     NOP
194:           }
1BBD6  52E5     MOVF 0xFE5, F, ACCESS
1BBD8  52E5     MOVF 0xFE5, F, ACCESS
1BBDA  52E5     MOVF 0xFE5, F, ACCESS
1BBDC  0012     RETURN 0
195:           
196:           void TMR6_DefaultInterruptHandler(void)
1B336  52E6     MOVF 0xFE6, F, ACCESS
197:           {
198:           	uint8_t i;
199:               // add your TMR6 interrupt custom code
200:               // or set custom function using TMR6_SetInterruptHandler()
201:           
202:           	//Decrement each software timer
203:           	for (i = 0; i < TMR_COUNT; i++) {
1B338  0EFF     MOVLW 0xFF
1B33A  6AE3     CLRF 0xFE3, ACCESS
204:           		if (tickCount[i] != 0) {
1B33C  0EFF     MOVLW 0xFF
1B33E  50E3     MOVF 0xFE3, W, ACCESS
1B340  0D02     MULLW 0x2
1B342  0E7D     MOVLW 0x7D
1B344  24F3     ADDWF 0xFF3, W, ACCESS
1B346  6ED9     MOVWF 0xFD9, ACCESS
1B348  0E02     MOVLW 0x2
1B34A  20F4     ADDWFC 0xFF4, W, ACCESS
1B34C  6EDA     MOVWF 0xFDA, ACCESS
1B34E  50DE     MOVF 0xFDE, W, ACCESS
1B350  10DE     IORWF 0xFDE, W, ACCESS
1B352  B4D8     BTFSC 0xFD8, 2, ACCESS
1B354  D00C     BRA 0xB36E
205:           			tickCount[i]--;
1B356  0EFF     MOVLW 0xFF
1B358  50E3     MOVF 0xFE3, W, ACCESS
1B35A  0D02     MULLW 0x2
1B35C  0E7D     MOVLW 0x7D
1B35E  24F3     ADDWF 0xFF3, W, ACCESS
1B360  6ED9     MOVWF 0xFD9, ACCESS
1B362  0E02     MOVLW 0x2
1B364  20F4     ADDWFC 0xFF4, W, ACCESS
1B366  6EDA     MOVWF 0xFDA, ACCESS
1B368  06DE     DECF 0xFDE, F, ACCESS
1B36A  0E00     MOVLW 0x0
1B36C  5ADD     SUBWFB 0xFDD, F, ACCESS
206:           }
207:           	}
1B36E  0EFF     MOVLW 0xFF
1B370  2AE3     INCF 0xFE3, F, ACCESS
1B372  0EFF     MOVLW 0xFF
1B376  FF8C     NOP
1B378  F001     NOP
1B37A  0E0C     MOVLW 0xC
1B37C  6401     CPFSGT ltemp0, ACCESS
1B37E  D7DE     BRA 0xB33C
208:           }
1B380  52E5     MOVF 0xFE5, F, ACCESS
1C0D0  EE14     LFSR 1, 0x115E
209:           
210:           /**
211:             End of File
212:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr5.c  ------------------------------
1:             /**
2:               TMR5 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr5.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR5 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR5.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr5.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            #include "../mbmc.h"
56:            
57:            /**
58:              Section: Global Variables Definitions
59:             */
60:            volatile uint16_t timer5ReloadVal;
61:            void (*TMR5_InterruptHandler)(void);
62:            extern V_data V;
63:            extern C_data C;
64:            
65:            /**
66:              Section: TMR5 APIs
67:             */
68:            
69:            void TMR5_Initialize(void)
70:            {
71:            	//Set the Timer to the options selected in the GUI
72:            
73:            	//T5GE disabled; T5GTM disabled; T5GPOL low; T5GGO done; T5GSPM disabled; 
74:            	T5GCON = 0x00;
1B4A8  6A9B     CLRF 0xF9B, ACCESS
75:            
76:            	//GSS T5G_pin; 
77:            	T5GATE = 0x00;
1B4AA  6A9C     CLRF 0xF9C, ACCESS
78:            
79:            	//CS FOSC/4; 
80:            	T5CLK = 0x01;
1B4AC  0E01     MOVLW 0x1
1B4AE  6E9D     MOVWF 0xF9D, ACCESS
81:            
82:            	//TMR5H 99; 
83:            	TMR5H = 0x63;
1B4B0  0E63     MOVLW 0x63
1B4B2  6E99     MOVWF 0xF99, ACCESS
84:            
85:            	//TMR5L 192; 
86:            	TMR5L = 0xC0;
1B4B4  0EC0     MOVLW 0xC0
1B4B6  6E98     MOVWF 0xF98, ACCESS
87:            
88:            	// Load the TMR value to reload variable
89:            	timer5ReloadVal = (uint16_t) ((TMR5H << 8) | TMR5L);
1B4B8  5098     MOVF 0xF98, W, ACCESS
1B4BC  FE64     NOP
1B4BE  F001     NOP
1B4C0  6A02     CLRF ttemp5, ACCESS
1B4C4  F004     NOP
1B4C6  F002     NOP
1B4C8  6A01     CLRF ltemp0, ACCESS
1B4CA  1001     IORWF ltemp0, W, ACCESS
1B4CC  0100     MOVLB 0x0
1B4CE  6FC8     MOVWF timer5ReloadVal, BANKED
1B4D0  5002     MOVF ttemp5, W, ACCESS
1B4D2  6FC9     MOVWF 0xC9, BANKED
90:            
91:            	// Clearing IF flag before enabling the interrupt.
92:            	PIR8bits.TMR5IF = 0;
1B4D4  0139     MOVLB 0x39
1B4D6  9DA8     BCF TMR6_InterruptHandler, 6, BANKED
93:            
94:            	// Enabling TMR5 interrupt.
95:            	PIE8bits.TMR5IE = 1;
1B4D8  8D98     BSF 0x98, 6, BANKED
96:            
97:            	// Set Default Interrupt Handler
98:            	TMR5_SetInterruptHandler(TMR5_DefaultInterruptHandler);
1B4DA  0E7C     MOVLW 0x7C
1B4DC  6EE6     MOVWF 0xFE6, ACCESS
1B4DE  0EB8     MOVLW 0xB8
1B4E0  6EE6     MOVWF 0xFE6, ACCESS
1B4E2  0E01     MOVLW 0x1
1B4E4  6EE6     MOVWF 0xFE6, ACCESS
1B4E6  ECEF     CALL 0x1BBDE, 0
1B4E8  F0DD     NOP
99:            
100:           	// CKPS 1:8; NOT_SYNC synchronize; TMR5ON enabled; T5RD16 disabled; 
101:           	T5CON = 0x31;
1B4EA  0E31     MOVLW 0x31
1B4EC  6E9A     MOVWF 0xF9A, ACCESS
102:           }
1B4EE  0012     RETURN 0
103:           
104:           void TMR5_StartTimer(void)
105:           {
106:           	// Start the Timer by writing to TMRxON bit
107:           	T5CONbits.TMR5ON = 1;
108:           }
109:           
110:           void TMR5_StopTimer(void)
111:           {
112:           	// Stop the Timer by writing to TMRxON bit
113:           	T5CONbits.TMR5ON = 0;
114:           }
115:           
116:           uint16_t TMR5_ReadTimer(void)
117:           {
118:           	uint16_t readVal;
119:           	uint8_t readValHigh;
120:           	uint8_t readValLow;
121:           
122:           	T5CONbits.T5RD16 = 1;
123:           
124:           	readValLow = TMR5L;
125:           	readValHigh = TMR5H;
126:           
127:           	readVal = ((uint16_t) readValHigh << 8) | readValLow;
128:           
129:           	return readVal;
130:           }
131:           
132:           void TMR5_WriteTimer(uint16_t timerVal)
133:           {
134:           	if (T5CONbits.NOT_SYNC == 1) {
1B74A  A49A     BTFSS 0xF9A, 2, ACCESS
1B74C  D00F     BRA 0xB76C
135:           		// Stop the Timer by writing to TMRxON bit
136:           		T5CONbits.TMR5ON = 0;
1B74E  909A     BCF 0xF9A, 0, ACCESS
137:           
138:           		// Write to the Timer5 register
139:           		TMR5H = (timerVal >> 8);
1B750  0EFF     MOVLW 0xFF
1B752  24E1     ADDWF 0xFE1, W, ACCESS
1B754  6ED9     MOVWF 0xFD9, ACCESS
1B756  0EFF     MOVLW 0xFF
1B758  20E2     ADDWFC 0xFE2, W, ACCESS
1B75A  6EDA     MOVWF 0xFDA, ACCESS
1B75C  50DF     MOVF 0xFDF, W, ACCESS
1B75E  6E99     MOVWF 0xF99, ACCESS
140:           		TMR5L = timerVal;
1B760  0EFE     MOVLW 0xFE
1B764  FF8F     NOP
1B766  FF98     NOP
141:           
142:           		// Start the Timer after writing to the register
143:           		T5CONbits.TMR5ON = 1;
1B768  809A     BSF 0xF9A, 0, ACCESS
144:           	} else {
1B76A  D00C     BRA 0xB784
145:           		// Write to the Timer5 register
146:           		TMR5H = (timerVal >> 8);
1B76C  0EFF     MOVLW 0xFF
1B76E  24E1     ADDWF 0xFE1, W, ACCESS
1B770  6ED9     MOVWF 0xFD9, ACCESS
1B772  0EFF     MOVLW 0xFF
1B774  20E2     ADDWFC 0xFE2, W, ACCESS
1B776  6EDA     MOVWF 0xFDA, ACCESS
1B778  50DF     MOVF 0xFDF, W, ACCESS
1B77A  6E99     MOVWF 0xF99, ACCESS
147:           		TMR5L = timerVal;
1B77C  0EFE     MOVLW 0xFE
1B780  FF8F     NOP
1B782  FF98     NOP
148:           	}
149:           }
1B784  52E5     MOVF 0xFE5, F, ACCESS
1B786  52E5     MOVF 0xFE5, F, ACCESS
1B788  0012     RETURN 0
150:           
151:           void TMR5_Reload(void)
152:           {
153:           	TMR5_WriteTimer(timer5ReloadVal);
154:           }
155:           
156:           void TMR5_StartSinglePulseAcquisition(void)
157:           {
158:           	T5GCONbits.T5GGO = 1;
159:           }
160:           
161:           uint8_t TMR5_CheckGateValueStatus(void)
162:           {
163:           	return(T5GCONbits.T5GVAL);
164:           }
165:           
166:           void __interrupt(irq(TMR5),base(8),low_priority) TMR5_ISR()
1A0CE  FF60     NOP
1A0D0  F02D     NOP
1A0D4  F004     NOP
1A0D6  F02E     NOP
1A0DA  F008     NOP
1A0DC  F02F     NOP
1A0E0  F00C     NOP
1A0E2  F030     NOP
1A0E6  F010     NOP
1A0E8  F031     NOP
1A0EC  F014     NOP
1A0EE  F032     NOP
1A0F2  F018     NOP
1A0F4  F033     NOP
1A0F8  F01C     NOP
1A0FA  F034     NOP
1A0FE  F020     NOP
1A100  F035     NOP
1A104  F024     NOP
1A106  F036     NOP
1A10A  F028     NOP
1A10C  F037     NOP
1A110  F02C     NOP
1A112  F038     NOP
1A116  F030     NOP
1A118  F039     NOP
1A11A  EE16     LFSR 1, 0x18AF
1A11C  F0AF     NOP
167:           {
168:           	static volatile unsigned int CountCallBack = 0;
169:           
170:           	// Clear the TMR5 interrupt flag
171:           	PIR8bits.TMR5IF = 0;
1A11E  0139     MOVLB 0x39
1A120  9DA8     BCF TMR6_InterruptHandler, 6, BANKED
172:           	TMR5_WriteTimer(timer5ReloadVal);
1A124  F323     NOP
1A126  FFE6     NOP
1A12A  F327     NOP
1A12C  FFE6     NOP
1A12E  ECA5     CALL 0x1B74A, 0
1A130  F0DB     NOP
173:           
174:           	// callback function - called every 100th pass
175:           	if (++CountCallBack >= (TMR5_INTERRUPT_TICKER_FACTOR+V.ticker)) {
1A132  0101     MOVLB 0x1
1A134  51DA     MOVF 0xDA, W, BANKED
1A136  6E2B     MOVWF 0x2B, ACCESS
1A138  6A2C     CLRF 0x2C, ACCESS
1A13A  0E05     MOVLW 0x5
1A13C  262B     ADDWF 0x2B, F, ACCESS
1A13E  0E00     MOVLW 0x0
1A140  222C     ADDWFC 0x2C, F, ACCESS
1A142  0100     MOVLB 0x0
1A144  4BC6     INFSNZ CountCallBack, F, BANKED
1A146  2BC7     INCF 0xC7, F, BANKED
1A148  502B     MOVF 0x2B, W, ACCESS
1A14A  5DC6     SUBWF CountCallBack, W, BANKED
1A14C  502C     MOVF 0x2C, W, ACCESS
1A14E  59C7     SUBWFB 0xC7, W, BANKED
1A150  A0D8     BTFSS 0xFD8, 0, ACCESS
1A152  D005     BRA 0xA15E
176:           		// ticker function call
177:           		TMR5_CallBack();
1A154  ECDA     CALL 0x1BDB4, 0
1A156  F0DE     NOP
178:           
179:           		// reset ticker counter
180:           		CountCallBack = 0;
1A158  0100     MOVLB 0x0
1A15A  6BC6     CLRF CountCallBack, BANKED
1A15C  6BC7     CLRF 0xC7, BANKED
181:           	}
182:           }
1A160  F0E4     NOP
1A162  F00C     NOP
1A166  F0E0     NOP
1A168  F00B     NOP
1A16C  F0DC     NOP
1A16E  F00A     NOP
1A172  F0D8     NOP
1A174  F009     NOP
1A178  F0D4     NOP
1A17A  F008     NOP
1A17E  F0D0     NOP
1A180  F007     NOP
1A184  F0CC     NOP
1A186  F006     NOP
1A18A  F0C8     NOP
1A18C  F005     NOP
1A190  F0C4     NOP
1A192  F004     NOP
1A196  F0C0     NOP
1A198  F003     NOP
1A19C  F0BC     NOP
1A19E  F002     NOP
1A1A2  F0B8     NOP
1A1A4  F001     NOP
1A1A8  F0B7     NOP
1A1AA  FFD8     NOP
1A1AC  0011     RETFIE 1
183:           
184:           void TMR5_CallBack(void)
185:           {
186:           	// Add your custom callback code here
187:           	if (TMR5_InterruptHandler) {
1BDB4  0100     MOVLB 0x0
1BDB6  51A5     MOVF TMR5_InterruptHandler, W, BANKED
1BDB8  11A6     IORWF 0xA6, W, BANKED
1BDBA  11A7     IORWF 0xA7, W, BANKED
1BDBC  B4D8     BTFSC 0xFD8, 2, ACCESS
1BDBE  0012     RETURN 0
188:           		TMR5_InterruptHandler();
1BDC0  D801     RCALL 0xBDC4
1BDC2  0012     RETURN 0
1BDC4  0005     PUSH
1BDC6  6EFA     MOVWF 0xFFA, ACCESS
1BDC8  51A5     MOVF TMR5_InterruptHandler, W, BANKED
1BDCA  6EFD     MOVWF 0xFFD, ACCESS
1BDCC  51A6     MOVF 0xA6, W, BANKED
1BDCE  6EFE     MOVWF 0xFFE, ACCESS
1BDD0  51A7     MOVF 0xA7, W, BANKED
1BDD2  6EFF     MOVWF 0xFFF, ACCESS
1BDD4  50FA     MOVF 0xFFA, W, ACCESS
1BDD6  0012     RETURN 0
189:           	}
190:           }
191:           
192:           void TMR5_SetInterruptHandler(void (* InterruptHandler)(void))
193:           {
194:           	TMR5_InterruptHandler = InterruptHandler;
1BBDE  50E1     MOVF 0xFE1, W, ACCESS
1BBE0  0FFD     ADDLW 0xFD
1BBE2  6ED9     MOVWF 0xFD9, ACCESS
1BBE4  50E2     MOVF 0xFE2, W, ACCESS
1BBE6  6EDA     MOVWF 0xFDA, ACCESS
1BBE8  0EFF     MOVLW 0xFF
1BBEA  22DA     ADDWFC 0xFDA, F, ACCESS
1BBEE  FF78     NOP
1BBF0  F0A5     NOP
1BBF4  FF78     NOP
1BBF6  F0A6     NOP
1BBFA  FF74     NOP
1BBFC  F0A7     NOP
195:           }
1BBFE  52E5     MOVF 0xFE5, F, ACCESS
1BC00  52E5     MOVF 0xFE5, F, ACCESS
1BC02  52E5     MOVF 0xFE5, F, ACCESS
1BC04  0012     RETURN 0
196:           
197:           void TMR5_DefaultInterruptHandler(void)
198:           {
199:           	// add your TMR5 interrupt custom code
200:           	// or set custom function using TMR5_SetInterruptHandler()
201:           	SLED = (uint8_t) ~SLED;
1B87C  A0BE     BTFSS 0xFBE, 0, ACCESS
1B87E  D002     BRA 0xB884
1B880  0E01     MOVLW 0x1
1B882  D001     BRA 0xB886
1B884  0E00     MOVLW 0x0
1B886  0AFF     XORLW 0xFF
1B888  6E0C     MOVWF 0xC, ACCESS
1B88A  50BE     MOVF 0xFBE, W, ACCESS
1B88C  180C     XORWF 0xC, W, ACCESS
1B88E  0BFE     ANDLW 0xFE
1B890  180C     XORWF 0xC, W, ACCESS
1B892  6EBE     MOVWF 0xFBE, ACCESS
202:           	V.timerint_count++;
1B894  0E01     MOVLW 0x1
1B896  0101     MOVLB 0x1
1B898  27EB     ADDWF 0xEB, F, BANKED
1B89A  0E00     MOVLW 0x0
1B89C  23EC     ADDWFC 0xEC, F, BANKED
1B89E  23ED     ADDWFC 0xED, F, BANKED
1B8A0  23EE     ADDWFC 0xEE, F, BANKED
203:           	V.ticks++;
1B8A2  0E01     MOVLW 0x1
1B8A4  27B1     ADDWF UART1_RxInterruptHandler, F, BANKED
1B8A6  0E00     MOVLW 0x0
1B8A8  23B2     ADDWFC 0xB2, F, BANKED
1B8AA  23B3     ADDWFC 0xB3, F, BANKED
1B8AC  23B4     ADDWFC UART2_TxInterruptHandler, F, BANKED
204:           	check_day_time();
1B8AE  EC1D     CALL 0x1883A, 0
1B8B0  F0C4     NOP
205:           }
1B8B2  0012     RETURN 0
206:           
207:           /**
208:             End of File
209:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr3.c  ------------------------------
1:             /**
2:               TMR3 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr3.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR3 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR3.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr3.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer3ReloadVal;
59:            void (*TMR3_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR3 APIs
63:            */
64:            
65:            void TMR3_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T3GE disabled; T3GTM disabled; T3GPOL low; T3GGO done; T3GSPM disabled; 
70:                T3GCON = 0x00;
1B4F0  6AA7     CLRF 0xFA7, ACCESS
71:            
72:                //GSS T3G_pin; 
73:                T3GATE = 0x00;
1B4F2  6AA8     CLRF 0xFA8, ACCESS
74:            
75:                //CS FOSC/4; 
76:                T3CLK = 0x01;
1B4F4  0E01     MOVLW 0x1
1B4F6  6EA9     MOVWF 0xFA9, ACCESS
77:            
78:                //TMR3H 60; 
79:                TMR3H = 0x3C;
1B4F8  0E3C     MOVLW 0x3C
1B4FA  6EA5     MOVWF 0xFA5, ACCESS
80:            
81:                //TMR3L 176; 
82:                TMR3L = 0xB0;
1B4FC  0EB0     MOVLW 0xB0
1B4FE  6EA4     MOVWF 0xFA4, ACCESS
83:            
84:                // Load the TMR value to reload variable
85:                timer3ReloadVal=(uint16_t)((TMR3H << 8) | TMR3L);
1B500  50A4     MOVF 0xFA4, W, ACCESS
1B504  FE94     NOP
1B506  F001     NOP
1B508  6A02     CLRF ttemp5, ACCESS
1B50C  F004     NOP
1B50E  F002     NOP
1B510  6A01     CLRF ltemp0, ACCESS
1B512  1001     IORWF ltemp0, W, ACCESS
1B514  0100     MOVLB 0x0
1B516  6FC4     MOVWF timer3ReloadVal, BANKED
1B518  5002     MOVF ttemp5, W, ACCESS
1B51A  6FC5     MOVWF 0xC5, BANKED
86:            
87:                // Clearing IF flag before enabling the interrupt.
88:                PIR6bits.TMR3IF = 0;
1B51C  0139     MOVLB 0x39
1B51E  9DA6     BCF 0xA6, 6, BANKED
89:            
90:                // Enabling TMR3 interrupt.
91:                PIE6bits.TMR3IE = 1;
1B520  8D96     BSF utctime, 6, BANKED
92:            
93:                // Set Default Interrupt Handler
94:                TMR3_SetInterruptHandler(TMR3_DefaultInterruptHandler);
1B522  0E60     MOVLW 0x60
1B524  6EE6     MOVWF 0xFE6, ACCESS
1B526  0EC1     MOVLW 0xC1
1B528  6EE6     MOVWF 0xFE6, ACCESS
1B52A  0E01     MOVLW 0x1
1B52C  6EE6     MOVWF 0xFE6, ACCESS
1B52E  EC03     CALL 0x1BC06, 0
1B530  F0DE     NOP
95:            
96:                // CKPS 1:8; NOT_SYNC synchronize; TMR3ON enabled; T3RD16 disabled; 
97:                T3CON = 0x31;
1B532  0E31     MOVLW 0x31
1B534  6EA6     MOVWF 0xFA6, ACCESS
98:            }
1B536  0012     RETURN 0
99:            
100:           void TMR3_StartTimer(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T3CONbits.TMR3ON = 1;
104:           }
105:           
106:           void TMR3_StopTimer(void)
107:           {
108:               // Stop the Timer by writing to TMRxON bit
109:               T3CONbits.TMR3ON = 0;
110:           }
111:           
112:           uint16_t TMR3_ReadTimer(void)
113:           {
114:               uint16_t readVal;
115:               uint8_t readValHigh;
116:               uint8_t readValLow;
117:               
118:               T3CONbits.T3RD16 = 1;
119:           	
120:               readValLow = TMR3L;
121:               readValHigh = TMR3H;
122:               
123:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
124:           
125:               return readVal;
126:           }
127:           
128:           void TMR3_WriteTimer(uint16_t timerVal)
129:           {
130:               if (T3CONbits.NOT_SYNC == 1)
1B78A  A4A6     BTFSS 0xFA6, 2, ACCESS
1B78C  D00F     BRA 0xB7AC
131:               {
132:                   // Stop the Timer by writing to TMRxON bit
133:                   T3CONbits.TMR3ON = 0;
1B78E  90A6     BCF 0xFA6, 0, ACCESS
134:           
135:                   // Write to the Timer3 register
136:                   TMR3H = (timerVal >> 8);
1B790  0EFF     MOVLW 0xFF
1B792  24E1     ADDWF 0xFE1, W, ACCESS
1B794  6ED9     MOVWF 0xFD9, ACCESS
1B796  0EFF     MOVLW 0xFF
1B798  20E2     ADDWFC 0xFE2, W, ACCESS
1B79A  6EDA     MOVWF 0xFDA, ACCESS
1B79C  50DF     MOVF 0xFDF, W, ACCESS
1B79E  6EA5     MOVWF 0xFA5, ACCESS
137:                   TMR3L = timerVal;
1B7A0  0EFE     MOVLW 0xFE
1B7A4  FF8F     NOP
1B7A6  FFA4     NOP
138:           
139:                   // Start the Timer after writing to the register
140:                   T3CONbits.TMR3ON =1;
1B7A8  80A6     BSF 0xFA6, 0, ACCESS
141:               }
1B7AA  D00C     BRA 0xB7C4
142:               else
143:               {
144:                   // Write to the Timer3 register
145:                   TMR3H = (timerVal >> 8);
1B7AC  0EFF     MOVLW 0xFF
1B7AE  24E1     ADDWF 0xFE1, W, ACCESS
1B7B0  6ED9     MOVWF 0xFD9, ACCESS
1B7B2  0EFF     MOVLW 0xFF
1B7B4  20E2     ADDWFC 0xFE2, W, ACCESS
1B7B6  6EDA     MOVWF 0xFDA, ACCESS
1B7B8  50DF     MOVF 0xFDF, W, ACCESS
1B7BA  6EA5     MOVWF 0xFA5, ACCESS
146:                   TMR3L = timerVal;
1B7BC  0EFE     MOVLW 0xFE
1B7C0  FF8F     NOP
1B7C2  FFA4     NOP
147:               }
148:           }
1B7C4  52E5     MOVF 0xFE5, F, ACCESS
1B7C6  52E5     MOVF 0xFE5, F, ACCESS
1B7C8  0012     RETURN 0
149:           
150:           void TMR3_Reload(void)
151:           {
152:               TMR3_WriteTimer(timer3ReloadVal);
153:           }
154:           
155:           void TMR3_StartSinglePulseAcquisition(void)
156:           {
157:               T3GCONbits.T3GGO = 1;
158:           }
159:           
160:           uint8_t TMR3_CheckGateValueStatus(void)
161:           {
162:               return (T3GCONbits.T3GVAL);
163:           }
164:           
165:           void __interrupt(irq(TMR3),base(8),low_priority) TMR3_ISR()
1914E  FF60     NOP
19150  F0D7     NOP
19154  FFD8     NOP
19156  F0D8     NOP
1915A  FFDC     NOP
1915C  F0D9     NOP
19160  FFE0     NOP
19162  F0DA     NOP
19166  FFD4     NOP
19168  F0DB     NOP
1916C  F004     NOP
1916E  F0DC     NOP
19172  F008     NOP
19174  F0DD     NOP
19178  F00C     NOP
1917A  F0DE     NOP
1917E  F010     NOP
19180  F0DF     NOP
19184  F014     NOP
19186  F0E0     NOP
1918A  F018     NOP
1918C  F0E1     NOP
19190  F01C     NOP
19192  F0E2     NOP
19196  F020     NOP
19198  F0E3     NOP
1919C  F024     NOP
1919E  F0E4     NOP
191A2  F028     NOP
191A4  F0E5     NOP
191A8  F02C     NOP
191AA  F0E6     NOP
191AE  F030     NOP
191B0  F0E7     NOP
191B4  F044     NOP
191B6  F0E8     NOP
191BA  F048     NOP
191BC  F0E9     NOP
191C0  F04C     NOP
191C2  F0EA     NOP
191C6  F050     NOP
191C8  F0EB     NOP
191CC  F054     NOP
191CE  F0EC     NOP
191D2  F058     NOP
191D4  F0ED     NOP
191D8  F05C     NOP
191DA  F0EE     NOP
191DE  F060     NOP
191E0  F0EF     NOP
191E2  EE16     LFSR 1, 0x18AF
191E4  F0AF     NOP
166:           {
167:               static volatile unsigned int CountCallBack = 0;
168:           
169:               // Clear the TMR3 interrupt flag
170:               PIR6bits.TMR3IF = 0;
191E6  0139     MOVLB 0x39
191E8  9DA6     BCF 0xA6, 6, BANKED
171:               TMR3_WriteTimer(timer3ReloadVal);
191EC  F313     NOP
191EE  FFE6     NOP
191F2  F317     NOP
191F4  FFE6     NOP
191F6  ECC5     CALL 0x1B78A, 0
191F8  F0DB     NOP
172:           
173:               // callback function - called every 40th pass
174:               if (++CountCallBack >= TMR3_INTERRUPT_TICKER_FACTOR)
191FA  0100     MOVLB 0x0
191FC  4BC2     INFSNZ CountCallBack, F, BANKED
191FE  2BC3     INCF 0xC3, F, BANKED
19200  51C3     MOVF 0xC3, W, BANKED
19202  E104     BNZ 0x920C
19204  0E28     MOVLW 0x28
19206  5DC2     SUBWF CountCallBack, W, BANKED
19208  A0D8     BTFSS 0xFD8, 0, ACCESS
1920A  D005     BRA 0x9216
175:               {
176:                   // ticker function call
177:                   TMR3_CallBack();
1920C  ECEC     CALL 0x1BDD8, 0
1920E  F0DE     NOP
178:           
179:                   // reset ticker counter
180:                   CountCallBack = 0;
19210  0100     MOVLB 0x0
19212  6BC2     CLRF CountCallBack, BANKED
19214  6BC3     CLRF 0xC3, BANKED
181:               }
182:           }
19218  F3BC     NOP
1921A  F018     NOP
1921E  F3B8     NOP
19220  F017     NOP
19224  F3B4     NOP
19226  F016     NOP
1922A  F3B0     NOP
1922C  F015     NOP
19230  F3AC     NOP
19232  F014     NOP
19236  F3A8     NOP
19238  F013     NOP
1923C  F3A4     NOP
1923E  F012     NOP
19242  F3A0     NOP
19244  F011     NOP
19248  F39C     NOP
1924A  F00C     NOP
1924E  F398     NOP
19250  F00B     NOP
19254  F394     NOP
19256  F00A     NOP
1925A  F390     NOP
1925C  F009     NOP
19260  F38C     NOP
19262  F008     NOP
19266  F388     NOP
19268  F007     NOP
1926C  F384     NOP
1926E  F006     NOP
19272  F380     NOP
19274  F005     NOP
19278  F37C     NOP
1927A  F004     NOP
1927E  F378     NOP
19280  F003     NOP
19284  F374     NOP
19286  F002     NOP
1928A  F370     NOP
1928C  F001     NOP
19290  F36F     NOP
19292  FFF5     NOP
19296  F36B     NOP
19298  FFF8     NOP
1929C  F367     NOP
1929E  FFF7     NOP
192A2  F363     NOP
192A4  FFF6     NOP
192A8  F35F     NOP
192AA  FFD8     NOP
192AC  0011     RETFIE 1
183:           
184:           void TMR3_CallBack(void)
185:           {
186:               // Add your custom callback code here
187:               if(TMR3_InterruptHandler)
1BDD8  0100     MOVLB 0x0
1BDDA  51A2     MOVF TMR3_InterruptHandler, W, BANKED
1BDDC  11A3     IORWF 0xA3, W, BANKED
1BDDE  11A4     IORWF 0xA4, W, BANKED
1BDE0  B4D8     BTFSC 0xFD8, 2, ACCESS
1BDE2  0012     RETURN 0
188:               {
189:                   TMR3_InterruptHandler();
1BDE4  D801     RCALL 0xBDE8
1BDE6  0012     RETURN 0
1BDE8  0005     PUSH
1BDEA  6EFA     MOVWF 0xFFA, ACCESS
1BDEC  51A2     MOVF TMR3_InterruptHandler, W, BANKED
1BDEE  6EFD     MOVWF 0xFFD, ACCESS
1BDF0  51A3     MOVF 0xA3, W, BANKED
1BDF2  6EFE     MOVWF 0xFFE, ACCESS
1BDF4  51A4     MOVF 0xA4, W, BANKED
1BDF6  6EFF     MOVWF 0xFFF, ACCESS
1BDF8  50FA     MOVF 0xFFA, W, ACCESS
1BDFA  0012     RETURN 0
190:               }
191:           }
192:           
193:           void TMR3_SetInterruptHandler(void (* InterruptHandler)(void)){
194:               TMR3_InterruptHandler = InterruptHandler;
1BC06  50E1     MOVF 0xFE1, W, ACCESS
1BC08  0FFD     ADDLW 0xFD
1BC0A  6ED9     MOVWF 0xFD9, ACCESS
1BC0C  50E2     MOVF 0xFE2, W, ACCESS
1BC0E  6EDA     MOVWF 0xFDA, ACCESS
1BC10  0EFF     MOVLW 0xFF
1BC12  22DA     ADDWFC 0xFDA, F, ACCESS
1BC16  FF78     NOP
1BC18  F0A2     NOP
1BC1C  FF78     NOP
1BC1E  F0A3     NOP
1BC22  FF74     NOP
1BC24  F0A4     NOP
195:           }
1BC26  52E5     MOVF 0xFE5, F, ACCESS
1BC28  52E5     MOVF 0xFE5, F, ACCESS
1BC2A  52E5     MOVF 0xFE5, F, ACCESS
1BC2C  0012     RETURN 0
196:           
197:           void TMR3_DefaultInterruptHandler(void){
198:               // add your TMR3 interrupt custom code
199:               // or set custom function using TMR3_SetInterruptHandler()
200:           }
1C160  0012     RETURN 0
201:           
202:           /**
203:             End of File
204:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/tmr2.c  ------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // T2CS FOSC/4; 
67:                T2CLKCON = 0x01;
1BFC6  0E01     MOVLW 0x1
1BFC8  6EAE     MOVWF 0xFAE, ACCESS
68:            
69:                // T2PSYNC Not Synchronized; T2MODE Software control; T2CKPOL Rising Edge; T2CKSYNC Not Synchronized; 
70:                T2HLT = 0x00;
1BFCA  6AAD     CLRF 0xFAD, ACCESS
71:            
72:                // T2RSEL T2CKIPPS pin; 
73:                T2RST = 0x00;
1BFCC  6AAF     CLRF 0xFAF, ACCESS
74:            
75:                // PR2 99; 
76:                T2PR = 0x63;
1BFCE  0E63     MOVLW 0x63
1BFD0  6EAB     MOVWF 0xFAB, ACCESS
77:            
78:                // TMR2 0; 
79:                T2TMR = 0x00;
1BFD2  6AAA     CLRF 0xFAA, ACCESS
80:            
81:                // Clearing IF flag.
82:                PIR4bits.TMR2IF = 0;
1BFD4  0139     MOVLB 0x39
1BFD6  95A4     BCF 0xA4, 2, BANKED
83:            
84:                // T2CKPS 1:16; T2OUTPS 1:1; TMR2ON on; 
85:                T2CON = 0xC0;
1BFD8  0EC0     MOVLW 0xC0
1BFDA  6EAC     MOVWF 0xFAC, ACCESS
86:            }
1BFDC  0012     RETURN 0
87:            
88:            void TMR2_ModeSet(TMR2_HLT_MODE mode)
89:            {
90:               // Configure different types HLT mode
91:                T2HLTbits.MODE = mode;
92:            }
93:            
94:            void TMR2_ExtResetSourceSet(TMR2_HLT_EXT_RESET_SOURCE reset)
95:            {
96:                //Configure different types of HLT external reset source
97:                T2RSTbits.RSEL = reset;
98:            }
99:            
100:           void TMR2_Start(void)
101:           {
102:               // Start the Timer by writing to TMRxON bit
103:               T2CONbits.TMR2ON = 1;
104:           }
105:           
106:           void TMR2_StartTimer(void)
107:           {
108:               TMR2_Start();
109:           }
110:           
111:           void TMR2_Stop(void)
112:           {
113:               // Stop the Timer by writing to TMRxON bit
114:               T2CONbits.TMR2ON = 0;
115:           }
116:           
117:           void TMR2_StopTimer(void)
118:           {
119:               TMR2_Stop();
120:           }
121:           
122:           uint8_t TMR2_Counter8BitGet(void)
123:           {
124:               uint8_t readVal;
125:           
126:               readVal = TMR2;
127:           
128:               return readVal;
129:           }
130:           
131:           uint8_t TMR2_ReadTimer(void)
132:           {
133:               return TMR2_Counter8BitGet();
134:           }
135:           
136:           void TMR2_Counter8BitSet(uint8_t timerVal)
137:           {
138:               // Write to the Timer2 register
139:               TMR2 = timerVal;
140:           }
141:           
142:           void TMR2_WriteTimer(uint8_t timerVal)
143:           {
144:               TMR2_Counter8BitSet(timerVal);
145:           }
146:           
147:           void TMR2_Period8BitSet(uint8_t periodVal)
148:           {
149:              PR2 = periodVal;
150:           }
151:           
152:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
153:           {
154:              TMR2_Period8BitSet(periodVal);
155:           }
156:           
157:           bool TMR2_HasOverflowOccured(void)
158:           {
159:               // check if  overflow has occurred by checking the TMRIF bit
160:               bool status = PIR4bits.TMR2IF;
161:               if(status)
162:               {
163:                   // Clearing IF flag.
164:                   PIR4bits.TMR2IF = 0;
165:               }
166:               return status;
167:           }
168:           /**
169:             End of File
170:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/spi1.c  ------------------------------
1:             /**
2:               SPI1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the SPI1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for SPI1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15	
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "spi1.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:            */
57:            
58:            #define SPI_RX_IN_PROGRESS 0x0
59:            
60:            /**
61:              Section: Module APIs
62:            */
63:            
64:            void SPI1_Initialize(void)
65:            {
66:                // Set the SPI1 module to the options selected in the User Interface
67:            		// SSP active high; SDOP active high; FST disabled; SMP Middle; CKP Idle:Low, Active:High; CKE Active to idle; SDIP active high; 
68:            		SPI1CON1 = 0x40;
1BFDE  0E40     MOVLW 0x40
1BFE0  013D     MOVLB 0x3D
1BFE2  6F15     MOVWF 0x15, BANKED
69:            		// SSET disabled; RXR suspended if the RxFIFO is full; TXR required for a transfer; 
70:            		SPI1CON2 = 0x03;
1BFE4  0E03     MOVLW 0x3
1BFE6  6F16     MOVWF 0x16, BANKED
71:            		// BAUD 0; 
72:            		SPI1BAUD = 0x4F;
1BFE8  0E4F     MOVLW 0x4F
1BFEA  6F19     MOVWF lltemp3, BANKED
73:            		// CLKSEL FOSC; 
74:            		SPI1CLK = 0x00;
1BFEC  6B1C     CLRF 0x1C, BANKED
75:            		// BMODE every byte; LSBF MSb first; EN enabled; MST bus master; 
76:            		SPI1CON0 = 0x83;
1BFEE  0E83     MOVLW 0x83
1BFF0  6F14     MOVWF 0x14, BANKED
77:            }
1BFF2  0012     RETURN 0
78:            
79:            uint8_t SPI1_Exchange8bit(uint8_t data)
80:            {
81:                //One byte transfer count
82:                SPI1TCNTL = 1;
1BEC8  0E01     MOVLW 0x1
1BECA  013D     MOVLB 0x3D
1BECC  6F12     MOVWF 0x12, BANKED
83:                SPI1TXB = data;
1BECE  0EFF     MOVLW 0xFF
1BED2  FF8F     NOP
1BED4  FD11     NOP
84:            
85:                while(PIR2bits.SPI1RXIF == SPI_RX_IN_PROGRESS)
86:                {
87:                }
1BED6  0139     MOVLB 0x39
1BED8  A9A2     BTFSS TMR3_InterruptHandler, 4, BANKED
1BEDA  D7FD     BRA 0xBED6
88:            
89:                return (SPI1RXB);
1BEDE  F440     NOP
1BEE0  F001     NOP
90:            }
1BEE2  52E5     MOVF 0xFE5, F, ACCESS
1BEE4  0012     RETURN 0
91:            
92:            uint8_t SPI1_Exchange8bitBuffer(uint8_t *dataIn, uint8_t bufLen, uint8_t *dataOut)
93:            {
94:                uint8_t bytesWritten = 0;
95:            
96:                if(bufLen != 0)
97:                {
98:                    if(dataIn != NULL)
99:                    {
100:                       while(bytesWritten < bufLen)
101:                       {
102:                           if(dataOut == NULL)
103:                           {
104:                               SPI1_Exchange8bit(dataIn[bytesWritten]);
105:                           }
106:                           else
107:                           {
108:                               dataOut[bytesWritten] = SPI1_Exchange8bit(dataIn[bytesWritten]);
109:                           }
110:           
111:                           bytesWritten++;
112:                       }
113:                   }
114:                   else
115:                   {
116:                       if(dataOut != NULL)
117:                       {
118:                           while(bytesWritten < bufLen )
119:                           {
120:                               dataOut[bytesWritten] = SPI1_Exchange8bit(DUMMY_DATA);
121:           
122:                               bytesWritten++;
123:                           }
124:                       }
125:                   }
126:               }
127:           
128:               return bytesWritten;
129:           }
130:           
131:           /**
132:            End of File
133:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/pwm8.c  ------------------------------
1:              /**
2:                PWM8 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm8.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM8 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM8.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                     Device            :  PIC18F57K42
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 1.45 or later
21:                     MPLAB             :  MPLAB X 4.15
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm8.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM8_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM8POL active_hi; PWM8EN enabled; 
62:                PWM8CON = 0x80;   
1BFF4  0E80     MOVLW 0x80
1BFF6  6E62     MOVWF 0xF62, ACCESS
63:            
64:                // DC 0; 
65:                PWM8DCH = 0x00;   
1BFF8  6A61     CLRF 0xF61, ACCESS
66:            
67:                // DC 1; 
68:                PWM8DCL = 0x40;   
1BFFA  0E40     MOVLW 0x40
1BFFC  6E60     MOVWF 0xF60, ACCESS
69:            
70:                // Select timer
71:                CCPTMRS1bits.P8TSEL = 1;
1BFFE  013F     MOVLB 0x3F
1C000  515F     MOVF 0x5F, W, BANKED
1C002  0B3F     ANDLW 0x3F
1C004  0940     IORLW 0x40
1C006  6F5F     MOVWF 0x5F, BANKED
72:             }
1C008  0012     RETURN 0
73:            
74:             void PWM8_LoadDutyValue(uint16_t dutyValue)
75:             {
76:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
77:                 PWM8DCH = (dutyValue & 0x03FC)>>2;
1B608  0EFE     MOVLW 0xFE
1B60C  FF8C     NOP
1B60E  F00B     NOP
1B610  0EFF     MOVLW 0xFF
1B614  FF8C     NOP
1B616  F00C     NOP
1B618  90D8     BCF 0xFD8, 0, ACCESS
1B61A  320C     RRCF 0xC, F, ACCESS
1B61C  320B     RRCF wtemp5, F, ACCESS
1B61E  90D8     BCF 0xFD8, 0, ACCESS
1B620  320C     RRCF 0xC, F, ACCESS
1B622  320B     RRCF wtemp5, F, ACCESS
1B624  500B     MOVF wtemp5, W, ACCESS
1B626  6E61     MOVWF 0xF61, ACCESS
78:                 
79:                 // Writing to 2 LSBs of PWM duty cycle in PWMDCL register
80:                 PWM8DCL = (dutyValue & 0x0003)<<6;
1B628  0EFE     MOVLW 0xFE
1B62C  FF8C     NOP
1B62E  F00C     NOP
1B630  0E03     MOVLW 0x3
1B632  160C     ANDWF 0xC, F, ACCESS
1B634  0E06     MOVLW 0x6
1B636  6E01     MOVWF ltemp0, ACCESS
1B638  90D8     BCF 0xFD8, 0, ACCESS
1B63A  360C     RLCF 0xC, F, ACCESS
1B63C  2E01     DECFSZ ltemp0, F, ACCESS
1B63E  D7FC     BRA 0xB638
1B640  500C     MOVF 0xC, W, ACCESS
1B642  6E60     MOVWF 0xF60, ACCESS
81:             }
1B644  52E5     MOVF 0xFE5, F, ACCESS
1B646  52E5     MOVF 0xFE5, F, ACCESS
1B648  0012     RETURN 0
82:             /**
83:              End of File
84:             */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/pin_manager.c  -----------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include <xc.h>
50:            #include "pin_manager.h"
51:            #include "stdbool.h"
52:            
53:            
54:            
55:            
56:            
57:            void PIN_MANAGER_Initialize(void)
58:            {
59:                /**
60:                LATx registers
61:                */
62:                LATE = 0x07;
1AAAA  0E07     MOVLW 0x7
1AAAC  6EBE     MOVWF 0xFBE, ACCESS
63:                LATD = 0x00;
1AAAE  6ABD     CLRF 0xFBD, ACCESS
64:                LATA = 0x00;
1AAB0  6ABA     CLRF 0xFBA, ACCESS
65:                LATF = 0x23;
1AAB2  0E23     MOVLW 0x23
1AAB4  6EBF     MOVWF 0xFBF, ACCESS
66:                LATB = 0x00;
1AAB6  6ABB     CLRF 0xFBB, ACCESS
67:                LATC = 0x07;
1AAB8  0E07     MOVLW 0x7
1AABA  6EBC     MOVWF 0xFBC, ACCESS
68:            
69:                /**
70:                TRISx registers
71:                */
72:                TRISE = 0x00;
1AABC  6AC6     CLRF 0xFC6, ACCESS
73:                TRISF = 0x0C;
1AABE  0E0C     MOVLW 0xC
1AAC0  6EC7     MOVWF 0xFC7, ACCESS
74:                TRISA = 0xFF;
1AAC2  68C2     SETF 0xFC2, ACCESS
75:                TRISB = 0xBF;
1AAC4  0EBF     MOVLW 0xBF
1AAC6  6EC3     MOVWF 0xFC3, ACCESS
76:                TRISC = 0x90;
1AAC8  0E90     MOVLW 0x90
1AACA  6EC4     MOVWF 0xFC4, ACCESS
77:                TRISD = 0x0C;
1AACC  0E0C     MOVLW 0xC
1AACE  6EC5     MOVWF 0xFC5, ACCESS
78:            
79:                /**
80:                ANSELx registers
81:                */
82:                ANSELD = 0x00;
1AAD0  013A     MOVLB 0x3A
1AAD2  6B70     CLRF 0x70, BANKED
83:                ANSELC = 0x00;
1AAD4  6B60     CLRF spi_link, BANKED
84:                ANSELB = 0x3C;
1AAD6  0E3C     MOVLW 0x3C
1AAD8  6F50     MOVWF 0x50, BANKED
85:                ANSELE = 0x00;
1AADA  6B80     CLRF 0x80, BANKED
86:                ANSELF = 0x00;
1AADC  6B90     CLRF 0x90, BANKED
87:                ANSELA = 0xFF;
1AADE  6940     SETF esr_state, BANKED
88:            
89:                /**
90:                WPUx registers
91:                */
92:                WPUD = 0x0C;
1AAE0  0E0C     MOVLW 0xC
1AAE2  6F71     MOVWF 0x71, BANKED
93:                WPUF = 0x0C;
1AAE4  0E0C     MOVLW 0xC
1AAE6  6F91     MOVWF 0x91, BANKED
94:                WPUE = 0x00;
1AAE8  6B81     CLRF 0x81, BANKED
95:                WPUB = 0x83;
1AAEA  0E83     MOVLW 0x83
1AAEC  6F51     MOVWF 0x51, BANKED
96:                WPUA = 0x00;
1AAEE  6B41     CLRF log_update_wait, BANKED
97:                WPUC = 0x97;
1AAF0  0E97     MOVLW 0x97
1AAF2  6F61     MOVWF 0x61, BANKED
98:            
99:                /**
100:               ODx registers
101:               */
102:               ODCONE = 0x00;
1AAF4  6B82     CLRF F463, BANKED
103:               ODCONF = 0x00;
1AAF6  6B92     CLRF bvror, BANKED
104:               ODCONA = 0x00;
1AAF8  6B42     CLRF day_delay, BANKED
105:               ODCONB = 0x00;
1AAFA  6B52     CLRF 0x52, BANKED
106:               ODCONC = 0x00;
1AAFC  6B62     CLRF 0x62, BANKED
107:               ODCOND = 0x00;
1AAFE  6B72     CLRF 0x72, BANKED
108:           
109:               /**
110:               SLRCONx registers
111:               */
112:               SLRCONA = 0xFF;
1AB00  6943     SETF uart2RxHead, BANKED
113:               SLRCONB = 0xFF;
1AB02  6953     SETF 0x53, BANKED
114:               SLRCONC = 0xFF;
1AB04  6963     SETF 0x63, BANKED
115:               SLRCOND = 0xFF;
1AB06  6973     SETF 0x73, BANKED
116:               SLRCONE = 0x07;
1AB08  0E07     MOVLW 0x7
1AB0A  6F83     MOVWF 0x83, BANKED
117:               SLRCONF = 0xFF;
1AB0C  6993     SETF 0x93, BANKED
118:           
119:           
120:           
121:           
122:           
123:              
124:               
125:           	
126:               U2RXPPS = 0x0F;   //RB7->UART2:RX2;    
1AB0E  0E0F     MOVLW 0xF
1AB10  6FE8     MOVWF 0xE8, BANKED
127:               SPI1SCKPPS = 0x13;   //RC3->SPI1:SCK1;    
1AB12  0E13     MOVLW 0x13
1AB14  6FDE     MOVWF 0xDE, BANKED
128:               RB6PPS = 0x16;   //RB6->UART2:TX2;    
1AB16  0E16     MOVLW 0x16
1AB18  6F0E     MOVWF 0xE, BANKED
129:               RC3PPS = 0x1E;   //RC3->SPI1:SCK1;    
1AB1A  0E1E     MOVLW 0x1E
1AB1C  6F13     MOVWF 0x13, BANKED
130:               INT0PPS = 0x08;   //RB0->EXT_INT:INT0;    
1AB1E  0E08     MOVLW 0x8
1AB20  6FC0     MOVWF nout, BANKED
131:               RD1PPS = 0x10;   //RD1->PWM8:PWM8;    
1AB22  0E10     MOVLW 0x10
1AB24  6F19     MOVWF lltemp3, BANKED
132:               INT1PPS = 0x09;   //RB1->EXT_INT:INT1;    
1AB26  0E09     MOVLW 0x9
1AB28  6FC1     MOVWF 0xC1, BANKED
133:               RC5PPS = 0x1F;   //RC5->SPI1:SDO1;    
1AB2A  0E1F     MOVLW 0x1F
1AB2C  6F15     MOVWF 0x15, BANKED
134:               RC6PPS = 0x13;   //RC6->UART1:TX1;    
1AB2E  0E13     MOVLW 0x13
1AB30  6F16     MOVWF 0x16, BANKED
135:               U1RXPPS = 0x17;   //RC7->UART1:RX1;    
1AB32  0E17     MOVLW 0x17
1AB34  6FE5     MOVWF 0xE5, BANKED
136:               SPI1SDIPPS = 0x14;   //RC4->SPI1:SDI1;    
1AB36  0E14     MOVLW 0x14
1AB38  6FDF     MOVWF 0xDF, BANKED
137:           }
1AB3A  0012     RETURN 0
138:             
139:           void PIN_MANAGER_IOC(void)
140:           {   
141:           }
142:           
143:           /**
144:            End of File
145:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/mcc.c  -------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 or later
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:                INTERRUPT_Initialize();
1B3CE  ECCB     CALL 0x1AF96, 0
1B3D0  F0D7     NOP
53:                PMD_Initialize();
1B3D2  EC10     CALL 0x1C020, 0
1B3D4  F0E0     NOP
54:                PIN_MANAGER_Initialize();
1B3D6  EC55     CALL 0x1AAAA, 0
1B3D8  F0D5     NOP
55:                OSCILLATOR_Initialize();
1B3DA  EC05     CALL 0x1C00A, 0
1B3DC  F0E0     NOP
56:                FVR_Initialize();
1B3DE  EC9B     CALL 0x1C136, 0
1B3E0  F0E0     NOP
57:                ADCC_Initialize();
1B3E2  EC60     CALL 0x1AEC0, 0
1B3E4  F0D7     NOP
58:                TMR2_Initialize();
1B3E6  ECE3     CALL 0x1BFC6, 0
1B3E8  F0DF     NOP
59:                PWM8_Initialize();
1B3EA  ECFA     CALL 0x1BFF4, 0
1B3EC  F0DF     NOP
60:                EXT_INT_Initialize();
1B3EE  EC8F     CALL 0x1B91E, 0
1B3F0  F0DC     NOP
61:                TMR6_Initialize();
1B3F2  EC62     CALL 0x1BAC4, 0
1B3F4  F0DD     NOP
62:                TMR3_Initialize();
1B3F6  EC78     CALL 0x1B4F0, 0
1B3F8  F0DA     NOP
63:                TMR5_Initialize();
1B3FA  EC54     CALL 0x1B4A8, 0
1B3FC  F0DA     NOP
64:                UART1_Initialize();
1B3FE  EC30     CALL 0x1B460, 0
1B400  F0DA     NOP
65:                UART2_Initialize();
1B402  EC92     CALL 0x1B124, 0
1B404  F0D8     NOP
66:                SPI1_Initialize();
1B406  ECEF     CALL 0x1BFDE, 0
1B408  F0DF     NOP
67:                DMA2_Initialize();
1B40A  EC1C     CALL 0x1B238, 0
1B40C  F0D9     NOP
68:                DMA1_Initialize();
1B40E  EC2B     CALL 0x1AE56, 0
1B410  F0D7     NOP
69:                CLKREF_Initialize();
1B412  EC6F     CALL 0x1C0DE, 0
1B414  F0E0     NOP
70:            }
1B416  0012     RETURN 0
71:            
72:            void OSCILLATOR_Initialize(void)
73:            {
74:                // NOSC EXTOSC   with 4x PLL; NDIV 1; 
75:                OSCCON1 = 0x20;
1C00A  0E20     MOVLW 0x20
1C00C  0139     MOVLB 0x39
1C00E  6FD9     MOVWF 0xD9, BANKED
76:                // CSWHOLD may proceed; SOSCPWR Low power; 
77:                OSCCON3 = 0x00;
1C010  6BDB     CLRF 0xDB, BANKED
78:                // MFOEN disabled; LFOEN disabled; ADOEN disabled; SOSCEN disabled; EXTOEN disabled; HFOEN disabled; 
79:                OSCEN = 0x00;
1C012  6BDD     CLRF 0xDD, BANKED
80:                // HFFRQ 4_MHz; 
81:                OSCFRQ = 0x02;
1C014  0E02     MOVLW 0x2
1C016  6FDF     MOVWF 0xDF, BANKED
82:                // TUN 0; 
83:                OSCTUNE = 0x00;
1C018  6BDE     CLRF 0xDE, BANKED
84:                // Wait for PLL to stabilize
85:                while(PLLR == 0)
86:                {
87:                }
1C01A  B1DC     BTFSC 0xDC, 0, BANKED
1C01C  0012     RETURN 0
1C01E  D7FD     BRA 0xC01A
88:            }
89:            
90:            void PMD_Initialize(void)
91:            {
92:                // CLKRMD CLKR enabled; SYSCMD SYSCLK enabled; SCANMD SCANNER enabled; FVRMD FVR enabled; IOCMD IOC enabled; CRCMD CRC enabled; HLVDMD HLVD enabled; NVMMD NVM enabled; 
93:                PMD0 = 0x00;
1C020  0139     MOVLB 0x39
1C022  6BC0     CLRF nout, BANKED
94:                // NCO1MD DDS(NCO1) enabled; TMR0MD TMR0 enabled; TMR1MD TMR1 enabled; TMR4MD TMR4 enabled; TMR5MD TMR5 enabled; TMR2MD TMR2 enabled; TMR3MD TMR3 enabled; TMR6MD TMR6 enabled; 
95:                PMD1 = 0x00;
1C024  6BC1     CLRF 0xC1, BANKED
96:                // ZCDMD ZCD enabled; DACMD DAC enabled; CMP1MD CMP1 enabled; ADCMD ADC enabled; CMP2MD CMP2 enabled; 
97:                PMD2 = 0x00;
1C026  6BC2     CLRF CountCallBack, BANKED
98:                // CCP2MD CCP2 enabled; CCP1MD CCP1 enabled; CCP4MD CCP4 enabled; CCP3MD CCP3 enabled; PWM6MD PWM6 enabled; PWM5MD PWM5 enabled; PWM8MD PWM8 enabled; PWM7MD PWM7 enabled; 
99:                PMD3 = 0x00;
1C028  6BC3     CLRF 0xC3, BANKED
100:               // CWG3MD CWG3 enabled; CWG2MD CWG2 enabled; CWG1MD CWG1 enabled; 
101:               PMD4 = 0x00;
1C02A  6BC4     CLRF timer3ReloadVal, BANKED
102:               // U2MD UART2 enabled; U1MD UART1 enabled; SPI1MD SPI1 enabled; I2C2MD I2C2 enabled; I2C1MD I2C1 enabled; 
103:               PMD5 = 0x00;
1C02C  6BC5     CLRF 0xC5, BANKED
104:               // DSMMD DSM1 enabled; CLC3MD CLC3 enabled; CLC4MD CLC4 enabled; SMT1MD SMT1 enabled; CLC1MD CLC1 enabled; CLC2MD CLC2 enabled; 
105:               PMD6 = 0x00;
1C02E  6BC6     CLRF CountCallBack, BANKED
106:               // DMA1MD DMA1 enabled; DMA2MD DMA2 enabled; 
107:               PMD7 = 0x00;
1C030  6BC7     CLRF 0xC7, BANKED
108:           }
1C032  0012     RETURN 0
109:           
110:           
111:           /**
112:            End of File
113:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/interrupt_manager.c  -----------------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
19:                    Device            :  PIC18F57K42
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.45 or later
23:                    MPLAB 	          :  MPLAB X 4.15
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
1AF96  52E6     MOVF 0xFE6, F, ACCESS
53:            {
54:                INTCON0bits.IPEN = 1;
1AF98  8AD2     BSF 0xFD2, 5, ACCESS
55:            
56:                bool state = (unsigned char)GIE;
1AF9A  AED2     BTFSS 0xFD2, 7, ACCESS
1AF9C  D003     BRA 0xAFA4
1AF9E  6A0C     CLRF 0xC, ACCESS
1AFA0  2A0C     INCF 0xC, F, ACCESS
1AFA2  D001     BRA 0xAFA6
1AFA4  6A0C     CLRF 0xC, ACCESS
1AFA6  0EFF     MOVLW 0xFF
1AFAA  F033     NOP
1AFAC  FFE3     NOP
57:                GIE = 0;
1AFAE  9ED2     BCF 0xFD2, 7, ACCESS
58:                IVTLOCK = 0x55;
1AFB0  0E55     MOVLW 0x55
1AFB2  6ED4     MOVWF 0xFD4, ACCESS
59:                IVTLOCK = 0xAA;
1AFB4  0EAA     MOVLW 0xAA
1AFB6  6ED4     MOVWF 0xFD4, ACCESS
60:                IVTLOCKbits.IVTLOCKED = 0x00; // unlock IVT
1AFB8  90D4     BCF 0xFD4, 0, ACCESS
61:            
62:                IVTADU = 0;
1AFBA  0138     MOVLB 0x38
1AFBC  6B9F     CLRF 0x9F, BANKED
63:                IVTADH = 0;
1AFBE  6B9E     CLRF P, BANKED
64:                IVTADL = 8;
1AFC0  0E08     MOVLW 0x8
1AFC2  6F9D     MOVWF 0x9D, BANKED
65:            
66:                IVTLOCK = 0x55;
1AFC4  0E55     MOVLW 0x55
1AFC6  6ED4     MOVWF 0xFD4, ACCESS
67:                IVTLOCK = 0xAA;
1AFC8  0EAA     MOVLW 0xAA
1AFCA  6ED4     MOVWF 0xFD4, ACCESS
68:                IVTLOCKbits.IVTLOCKED = 0x01; // lock IVT
1AFCC  80D4     BSF 0xFD4, 0, ACCESS
69:            
70:                GIE = state;
1AFCE  0EFF     MOVLW 0xFF
1AFD0  B0E3     BTFSC 0xFE3, 0, ACCESS
1AFD2  D002     BRA 0xAFD8
1AFD4  9ED2     BCF 0xFD2, 7, ACCESS
1AFD6  D001     BRA 0xAFDA
1AFD8  8ED2     BSF 0xFD2, 7, ACCESS
71:                // Assign peripheral interrupt priority vectors
72:                IPR2bits.DMA1AIP = 1;
1AFDA  0139     MOVLB 0x39
1AFDC  8782     BSF F463, 3, BANKED
73:                IPR2bits.DMA1DCNTIP = 1;
1AFDE  8382     BSF F463, 1, BANKED
74:                IPR2bits.DMA1SCNTIP = 1;
1AFE0  8182     BSF F463, 0, BANKED
75:                IPR2bits.DMA1ORIP = 1;
1AFE2  8582     BSF F463, 2, BANKED
76:                IPR6bits.U2TXIP = 1;
1AFE4  8786     BSF bcror, 3, BANKED
77:                IPR6bits.U2RXIP = 1;
1AFE6  8586     BSF bcror, 2, BANKED
78:                IPR3bits.U1RXIP = 1;
1AFE8  8783     BSF 0x83, 3, BANKED
79:                IPR1bits.INT0IP = 1;
1AFEA  8181     BSF 0x81, 0, BANKED
80:                IPR5bits.INT1IP = 0;
1AFEC  9185     BCF 0x85, 0, BANKED
81:                IPR9bits.TMR6IP = 1;
1AFEE  8189     BSF 0x89, 0, BANKED
82:                IPR8bits.TMR5IP = 0;
1AFF0  9D88     BCF 0x88, 6, BANKED
83:                IPR6bits.TMR3IP = 0;
1AFF2  9D86     BCF bcror, 6, BANKED
84:                IPR1bits.ADIP = 1;
1AFF4  8581     BSF 0x81, 2, BANKED
85:                IPR1bits.ADTIP = 1;
1AFF6  8781     BSF 0x81, 3, BANKED
86:            }
1AFF8  52E5     MOVF 0xFE5, F, ACCESS
1AFFA  0012     RETURN 0
87:            
88:            void __interrupt(irq(default),base(8)) Default_ISR()
1C158  EE14     LFSR 1, 0x115E
1C15A  F15E     NOP
1C15C  0011     RETFIE 1
89:            {
90:            }
1BA6C  EE14     LFSR 1, 0x115E
1BA6E  F15E     NOP
1C15C  0011     RETFIE 1
91:            
92:            /**
93:             End of File
94:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/fvr.c  -------------------------------
1:             /**
2:               FVR Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 fvr.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the FVR driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for FVR.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "fvr.h"
53:            
54:            /**
55:              Section: FVR APIs
56:            */
57:            
58:            void FVR_Initialize(void)
59:            {
60:                // CDAFVR 4x; FVREN enabled; TSRNG Lo_range; ADFVR 4x; TSEN enabled; 
61:                FVRCON = 0xAF;
1C136  0EAF     MOVLW 0xAF
1C138  013E     MOVLB 0x3E
1C13A  6FC1     MOVWF 0xC1, BANKED
62:            }
1C13C  0012     RETURN 0
63:            
64:            bool FVR_IsOutputReady(void)
65:            {
66:                return (FVRCONbits.FVRRDY);
67:            }
68:            /**
69:             End of File
70:            */
71:            
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/ext_int.c  ---------------------------
1:             /**
2:                EXT_INT Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  ext_int.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the EXT_INT driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for EXT_INT.
15:                 Generation Information :
16:            	 Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	 Device            :  PIC18F57K42
18:            	 Driver Version    :  1.11
19:                 The generated drivers are tested against the following:
20:            	 Compiler          :  XC8 1.45
21:            	 MPLAB             :  MPLAB X 4.15
22:             */
23:            
24:            /**
25:              Section: Includes
26:             */
27:            #include <xc.h>
28:            #include "ext_int.h"
29:            #include "interrupt_manager.h"
30:            #include "pin_manager.h"
31:            #include "../vconfig.h"
32:            
33:            void (*INT0_InterruptHandler)(void);
34:            void (*INT1_InterruptHandler)(void);
35:            
36:            void __interrupt(irq(INT0), base(8)) INT0_ISR()
1C0C0  EE14     LFSR 1, 0x115E
1C0C2  F15E     NOP
37:            {
38:            	EXT_INT0_InterruptFlagClear();
1C0C4  0139     MOVLB 0x39
1C0C6  91A1     BCF 0xA1, 0, BANKED
39:            
40:            	// Callback function gets called everytime this ISR executes
41:            	INT0_CallBack();
1C0C8  ECFE     CALL 0x1BDFC, 0
1C0CA  F0DE     NOP
42:            }
1C0CC  0011     RETFIE 1
43:            
44:            void INT0_CallBack(void)
45:            {
46:            	// Add your custom callback code here
47:            	if (INT0_InterruptHandler) {
1BDFC  0100     MOVLB 0x0
1BDFE  51BD     MOVF INT0_InterruptHandler, W, BANKED
1BE00  11BE     IORWF 0xBE, W, BANKED
1BE02  11BF     IORWF 0xBF, W, BANKED
1BE04  B4D8     BTFSC 0xFD8, 2, ACCESS
1BE06  0012     RETURN 0
48:            		INT0_InterruptHandler();
1BE08  D801     RCALL 0xBE0C
1BE0A  0012     RETURN 0
1BE0C  0005     PUSH
1BE0E  6EFA     MOVWF 0xFFA, ACCESS
1BE10  51BD     MOVF INT0_InterruptHandler, W, BANKED
1BE12  6EFD     MOVWF 0xFFD, ACCESS
1BE14  51BE     MOVF 0xBE, W, BANKED
1BE16  6EFE     MOVWF 0xFFE, ACCESS
1BE18  51BF     MOVF 0xBF, W, BANKED
1BE1A  6EFF     MOVWF 0xFFF, ACCESS
1BE1C  50FA     MOVF 0xFFA, W, ACCESS
1BE1E  0012     RETURN 0
49:            	}
50:            }
51:            
52:            void INT0_SetInterruptHandler(void (* InterruptHandler)(void))
53:            {
54:            	INT0_InterruptHandler = InterruptHandler;
1BC56  50E1     MOVF 0xFE1, W, ACCESS
1BC58  0FFD     ADDLW 0xFD
1BC5A  6ED9     MOVWF 0xFD9, ACCESS
1BC5C  50E2     MOVF 0xFE2, W, ACCESS
1BC5E  6EDA     MOVWF 0xFDA, ACCESS
1BC60  0EFF     MOVLW 0xFF
1BC62  22DA     ADDWFC 0xFDA, F, ACCESS
1BC66  FF78     NOP
1BC68  F0BD     NOP
1BC6C  FF78     NOP
1BC6E  F0BE     NOP
1BC72  FF74     NOP
1BC74  F0BF     NOP
55:            }
1BC76  52E5     MOVF 0xFE5, F, ACCESS
1BC78  52E5     MOVF 0xFE5, F, ACCESS
1BC7A  52E5     MOVF 0xFE5, F, ACCESS
1BC7C  0012     RETURN 0
56:            
57:            void INT0_DefaultInterruptHandler(void)
58:            {
59:            	// add your INT0 interrupt custom code
60:            	// or set custom function using INT0_SetInterruptHandler()
61:            }
1C158  EE14     LFSR 1, 0x115E
1C162  0012     RETURN 0
62:            void __interrupt(irq(INT1),base(8),low_priority) INT1_ISR()
1B7CE  FF60     NOP
1B7D0  F027     NOP
1B7D4  F004     NOP
1B7D6  F028     NOP
1B7DA  F02C     NOP
1B7DC  F029     NOP
1B7E0  F030     NOP
1B7E2  F02A     NOP
1B7E4  EE16     LFSR 1, 0x18AF
1B7E6  F0AF     NOP
63:            {
64:            	EXT_INT1_InterruptFlagClear();
1B7E8  0139     MOVLB 0x39
1B7EA  91A5     BCF TMR5_InterruptHandler, 0, BANKED
65:            
66:            	// Callback function gets called everytime this ISR executes
67:            	INT1_CallBack();
1B7EC  ECC8     CALL 0x1BD90, 0
1B7EE  F0DE     NOP
68:            }
1B7F2  F0A8     NOP
1B7F4  F00C     NOP
1B7F8  F0A4     NOP
1B7FA  F00B     NOP
1B7FE  F0A0     NOP
1B800  F001     NOP
1B804  F09F     NOP
1B806  FFD8     NOP
1B808  0011     RETFIE 1
69:            
70:            void INT1_CallBack(void)
71:            {
72:            	// Add your custom callback code here
73:            	if (INT1_InterruptHandler) {
1BD90  0100     MOVLB 0x0
1BD92  51BA     MOVF INT1_InterruptHandler, W, BANKED
1BD94  11BB     IORWF 0xBB, W, BANKED
1BD96  11BC     IORWF 0xBC, W, BANKED
1BD98  B4D8     BTFSC 0xFD8, 2, ACCESS
1BD9A  0012     RETURN 0
74:            		INT1_InterruptHandler();
1BD9C  D801     RCALL 0xBDA0
1BD9E  0012     RETURN 0
1BDA0  0005     PUSH
1BDA2  6EFA     MOVWF 0xFFA, ACCESS
1BDA4  51BA     MOVF INT1_InterruptHandler, W, BANKED
1BDA6  6EFD     MOVWF 0xFFD, ACCESS
1BDA8  51BB     MOVF 0xBB, W, BANKED
1BDAA  6EFE     MOVWF 0xFFE, ACCESS
1BDAC  51BC     MOVF 0xBC, W, BANKED
1BDAE  6EFF     MOVWF 0xFFF, ACCESS
1BDB0  50FA     MOVF 0xFFA, W, ACCESS
1BDB2  0012     RETURN 0
75:            	}
76:            }
77:            
78:            void INT1_SetInterruptHandler(void (* InterruptHandler)(void))
79:            {
80:            	INT1_InterruptHandler = InterruptHandler;
1BC2E  50E1     MOVF 0xFE1, W, ACCESS
1BC30  0FFD     ADDLW 0xFD
1BC32  6ED9     MOVWF 0xFD9, ACCESS
1BC34  50E2     MOVF 0xFE2, W, ACCESS
1BC36  6EDA     MOVWF 0xFDA, ACCESS
1BC38  0EFF     MOVLW 0xFF
1BC3A  22DA     ADDWFC 0xFDA, F, ACCESS
1BC3E  FF78     NOP
1BC40  F0BA     NOP
1BC44  FF78     NOP
1BC46  F0BB     NOP
1BC4A  FF74     NOP
1BC4C  F0BC     NOP
81:            }
1BC4E  52E5     MOVF 0xFE5, F, ACCESS
1BC50  52E5     MOVF 0xFE5, F, ACCESS
1BC52  52E5     MOVF 0xFE5, F, ACCESS
1BC54  0012     RETURN 0
82:            
83:            void INT1_DefaultInterruptHandler(void)
84:            {
85:            	// add your INT1 interrupt custom code
86:            	// or set custom function using INT1_SetInterruptHandler()
87:            }
1C15E  0012     RETURN 0
88:            
89:            void EXT_INT_Initialize(void)
90:            {
91:            
92:            	// Clear the interrupt flag
93:            	// Set the external interrupt edge detect
94:            	EXT_INT0_InterruptFlagClear();
1B91E  0139     MOVLB 0x39
1B920  91A1     BCF 0xA1, 0, BANKED
95:            	EXT_INT0_fallingEdgeSet();
1B922  90D2     BCF 0xFD2, 0, ACCESS
96:            	// Set Default Interrupt Handler
97:            	INT0_SetInterruptHandler(INT0_DefaultInterruptHandler);
1B924  0E62     MOVLW 0x62
1B926  6EE6     MOVWF 0xFE6, ACCESS
1B928  0EC1     MOVLW 0xC1
1B92A  6EE6     MOVWF 0xFE6, ACCESS
1B92C  0E01     MOVLW 0x1
1B92E  6EE6     MOVWF 0xFE6, ACCESS
1B930  EC2B     CALL 0x1BC56, 0
1B932  F0DE     NOP
98:            	EXT_INT0_InterruptEnable();
1B934  0139     MOVLB 0x39
1B936  8191     BSF 0x91, 0, BANKED
99:            
100:           
101:           	// Clear the interrupt flag
102:           	// Set the external interrupt edge detect
103:           	EXT_INT1_InterruptFlagClear();
1B938  91A5     BCF TMR5_InterruptHandler, 0, BANKED
104:           	EXT_INT1_fallingEdgeSet();
1B93A  92D2     BCF 0xFD2, 1, ACCESS
105:           	// Set Default Interrupt Handler
106:           	INT1_SetInterruptHandler(INT1_DefaultInterruptHandler);
1B93C  0E5E     MOVLW 0x5E
1B93E  6EE6     MOVWF 0xFE6, ACCESS
1B940  0EC1     MOVLW 0xC1
1B942  6EE6     MOVWF 0xFE6, ACCESS
1B944  0E01     MOVLW 0x1
1B946  6EE6     MOVWF 0xFE6, ACCESS
1B948  EC17     CALL 0x1BC2E, 0
1B94A  F0DE     NOP
107:           	EXT_INT1_InterruptEnable();
1B94C  0139     MOVLB 0x39
1B94E  8195     BSF 0x95, 0, BANKED
108:           
109:           }
1B950  0012     RETURN 0
110:           
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/dma2.c  ------------------------------
1:             /**
2:               DMA Generated Driver File
3:               
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for DMA CHANNEL2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.10
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "dma2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: DMA APIs
60:            */
61:            void DMA2_Initialize(void)
62:            {
63:                DMA2SSA = 0x001000; //set source start address
1B238  0E00     MOVLW 0x0
1B23A  013B     MOVLB 0x3B
1B23C  6FD9     MOVWF 0xD9, BANKED
1B23E  0E10     MOVLW 0x10
1B240  6FDA     MOVWF 0xDA, BANKED
1B242  0E00     MOVLW 0x0
1B244  6FDB     MOVWF 0xDB, BANKED
64:                DMA2DSA = 0x3FBB; //set destination start address 
1B246  0E3F     MOVLW 0x3F
1B248  6FD1     MOVWF 0xD1, BANKED
1B24A  0EBB     MOVLW 0xBB
1B24C  6FD0     MOVWF 0xD0, BANKED
65:                DMA2CON1 = 0x03; //set control register1 
1B24E  0E03     MOVLW 0x3
1B250  6FDD     MOVWF 0xDD, BANKED
66:                DMA2SSZ = 0x0001; //set source size
1B252  0E00     MOVLW 0x0
1B254  6FD8     MOVWF 0xD8, BANKED
1B256  0E01     MOVLW 0x1
1B258  6FD7     MOVWF __pcstackBANK0, BANKED
67:                DMA2DSZ = 0x0001; //set destination size
1B25A  0E00     MOVLW 0x0
1B25C  6FCF     MOVWF seed, BANKED
1B25E  0E01     MOVLW 0x1
1B260  6FCE     MOVWF uart1RxCount, BANKED
68:                DMA2SIRQ = 0x1C; //set DMA Transfer Trigger Source
1B262  0E1C     MOVLW 0x1C
1B264  6FDF     MOVWF 0xDF, BANKED
69:                DMA2AIRQ = 0x3D; //set DMA Transfer abort Source
1B266  0E3D     MOVLW 0x3D
1B268  6FDE     MOVWF 0xDE, BANKED
70:                
71:                PIR5bits.DMA2DCNTIF =0; // clear Destination Count Interrupt Flag bit
1B26A  0139     MOVLB 0x39
1B26C  97A5     BCF TMR5_InterruptHandler, 3, BANKED
72:                PIR5bits.DMA2SCNTIF =0; // clear Source Count Interrupt Flag bit
1B26E  95A5     BCF TMR5_InterruptHandler, 2, BANKED
73:                PIR5bits.DMA2AIF =0; // clear abort Interrupt Flag bit
1B270  9BA5     BCF TMR5_InterruptHandler, 5, BANKED
74:            	PIR5bits.DMA2ORIF =0; // clear overrun Interrupt Flag bit
1B272  99A5     BCF TMR5_InterruptHandler, 4, BANKED
75:                
76:                PIE5bits.DMA2DCNTIE =0; // disable Destination Count 0 Interrupt
1B274  9795     BCF 0x95, 3, BANKED
77:                PIE5bits.DMA2SCNTIE =0; // disable Source Count Interrupt
1B276  9595     BCF 0x95, 2, BANKED
78:                PIE5bits.DMA2AIE =0; // disable abort Interrupt
1B278  9B95     BCF 0x95, 5, BANKED
79:                PIE5bits.DMA2ORIE =0; // disable overrun Interrupt 
1B27A  9995     BCF 0x95, 4, BANKED
80:            	
81:            	asm("BCF INTCON0,7");
1B27C  9ED2     BCF 0xFD2, 7, ACCESS
82:            	
83:            	asm ("BANKSEL PRLOCK");
1B27E  0139     MOVLB 0x39
84:                asm ("MOVLW 0x55");
1B280  0E55     MOVLW 0x55
85:                asm ("MOVWF PRLOCK");
1B282  6FEF     MOVWF 0xEF, BANKED
86:                asm ("MOVLW 0xAA");
1B284  0EAA     MOVLW 0xAA
87:                asm ("MOVWF PRLOCK");
1B286  6FEF     MOVWF 0xEF, BANKED
88:                asm ("BSF PRLOCK, 0");
1B288  81EF     BSF 0xEF, 0, BANKED
89:            	
90:            	asm("BSF INTCON0,7");
1B28A  8ED2     BSF 0xFD2, 7, ACCESS
91:                    
92:                DMA2CON0 = 0x00; //set control register0
1B28C  013B     MOVLB 0x3B
1B28E  6BDC     CLRF 0xDC, BANKED
93:            }
1B290  0012     RETURN 0
94:            
95:            
96:            
97:            
98:            /**
99:              End of File
100:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/dma1.c  ------------------------------
1:             /**
2:               DMA Generated Driver File
3:               
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 dma1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the DMA driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This header file provides implementations for driver APIs for DMA CHANNEL1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.10
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "dma1.h"
53:            #include "interrupt_manager.h"
54:            #include "../vconfig.h"
55:            
56:            /**
57:              Section: Global Variables Definitions
58:             */
59:            
60:            extern struct spi_link_type spi_link;
61:            
62:            //------------------------------------------------------------------------------
63:            #define m_ARBITER_LOCK()    \
64:                  do{ \
65:                       asm("BANKSEL PRLOCK");\
66:                       asm("MOVLW   0x55");\
67:                       asm("MOVWF   (PRLOCK & 0xFF)");\
68:                       asm("MOVLW   0xAA");\
69:                       asm("MOVWF   (PRLOCK & 0xFF)");\
70:                       asm("BSF     (PRLOCK & 0xFF),0");\
71:                    }while(0)
72:            //------------------------------------------------------------------------------
73:            #define m_ARBITER_UNLOCK()  \
74:                  do{ \
75:                       asm("BANKSEL PRLOCK");\
76:                       asm("MOVLW   0x55");\
77:                       asm("MOVWF   (PRLOCK & 0xFF)");\
78:                       asm("MOVLW   0xAA");\
79:                       asm("MOVWF   (PRLOCK & 0xFF)");\
80:                       asm("BCF     (PRLOCK & 0xFF),0");\
81:                    }while(0)
82:            
83:            /**
84:              Section: DMA APIs
85:             */
86:            void DMA1_Initialize(void)
87:            {
88:            	DMA1SSA = 0x001000; //set source start address
1AE56  0E00     MOVLW 0x0
1AE58  013B     MOVLB 0x3B
1AE5A  6FF9     MOVWF 0xF9, BANKED
1AE5C  0E10     MOVLW 0x10
1AE5E  6FFA     MOVWF 0xFA, BANKED
1AE60  0E00     MOVLW 0x0
1AE62  6FFB     MOVWF 0xFB, BANKED
89:            	DMA1DSA = 0x3D11; //set destination start address 
1AE64  0E3D     MOVLW 0x3D
1AE66  6FF1     MOVWF 0xF1, BANKED
1AE68  0E11     MOVLW 0x11
1AE6A  6FF0     MOVWF __pdataBANK0, BANKED
90:            	DMA1CON1 = 0x03; //set control register1 
1AE6C  0E03     MOVLW 0x3
1AE6E  6FFD     MOVWF 0xFD, BANKED
91:            	DMA1SSZ = 0x0001; //set source size
1AE70  0E00     MOVLW 0x0
1AE72  6FF8     MOVWF 0xF8, BANKED
1AE74  0E01     MOVLW 0x1
1AE76  6FF7     MOVWF H, BANKED
92:            	DMA1DSZ = 0x0001; //set destination size
1AE78  0E00     MOVLW 0x0
1AE7A  6FEF     MOVWF 0xEF, BANKED
1AE7C  0E01     MOVLW 0x1
1AE7E  6FEE     MOVWF 0xEE, BANKED
93:            	DMA1SIRQ = 0x15; //set DMA Transfer Trigger Source
1AE80  0E15     MOVLW 0x15
1AE82  6FFF     MOVWF 0xFF, BANKED
94:            	DMA1AIRQ = 0x0; //set DMA Transfer abort Source
1AE84  6BFE     CLRF 0xFE, BANKED
95:            
96:            	PIR2bits.DMA1DCNTIF = 0; // clear Destination Count Interrupt Flag bit
1AE86  0139     MOVLB 0x39
1AE88  93A2     BCF TMR3_InterruptHandler, 1, BANKED
97:            	PIR2bits.DMA1SCNTIF = 0; // clear Source Count Interrupt Flag bit
1AE8A  91A2     BCF TMR3_InterruptHandler, 0, BANKED
98:            	PIR2bits.DMA1AIF = 0; // clear abort Interrupt Flag bit
1AE8C  97A2     BCF TMR3_InterruptHandler, 3, BANKED
99:            	PIR2bits.DMA1ORIF = 0; // clear overrun Interrupt Flag bit
1AE8E  95A2     BCF TMR3_InterruptHandler, 2, BANKED
100:           
101:           	PIE2bits.DMA1DCNTIE = 1; // enable Destination Count 0 Interrupt
1AE90  8392     BSF bvror, 1, BANKED
102:           	PIE2bits.DMA1SCNTIE = 1; // enable Source Count Interrupt
1AE92  8192     BSF bvror, 0, BANKED
103:           	PIE2bits.DMA1AIE = 1; // enable abort Interrupt
1AE94  8792     BSF bvror, 3, BANKED
104:           	PIE2bits.DMA1ORIE = 1; // enable overrun Interrupt 
1AE96  8592     BSF bvror, 2, BANKED
105:           
106:           	ISRPR = 0;
1AE98  6BF1     CLRF 0xF1, BANKED
107:           	MAINPR = 1;
1AE9A  0E01     MOVLW 0x1
1AE9C  6FF2     MOVWF 0xF2, BANKED
108:           	DMA1PR = 4;
1AE9E  0E04     MOVLW 0x4
1AEA0  6FF3     MOVWF 0xF3, BANKED
109:           	DMA2PR = 2;
1AEA2  0E02     MOVLW 0x2
1AEA4  6FF4     MOVWF 0xF4, BANKED
110:           	SCANPR = 3;
1AEA6  0E03     MOVLW 0x3
1AEA8  6FF7     MOVWF H, BANKED
111:           
112:           	asm("BCF INTCON0,7");
1AEAA  9ED2     BCF 0xFD2, 7, ACCESS
113:           
114:           	asm("BANKSEL PRLOCK");
1AEAC  0139     MOVLB 0x39
115:           	asm("MOVLW 0x55");
1AEAE  0E55     MOVLW 0x55
116:           	asm("MOVWF PRLOCK");
1AEB0  6FEF     MOVWF 0xEF, BANKED
117:           	asm("MOVLW 0xAA");
1AEB2  0EAA     MOVLW 0xAA
118:           	asm("MOVWF PRLOCK");
1AEB4  6FEF     MOVWF 0xEF, BANKED
119:           	asm("BSF PRLOCK, 0");
1AEB6  81EF     BSF 0xEF, 0, BANKED
120:           
121:           	asm("BSF INTCON0,7");
1AEB8  8ED2     BSF 0xFD2, 7, ACCESS
122:           
123:           	DMA1CON0 = 0x00; //set control register0
1AEBA  013B     MOVLB 0x3B
1AEBC  6BFC     CLRF 0xFC, BANKED
124:           }
1AEBE  0012     RETURN 0
125:           
126:           void __interrupt(irq(DMA1SCNT), base(8)) DMA1_DMASCNT_ISR()
1C0D0  EE14     LFSR 1, 0x115E
1C0D2  F15E     NOP
127:           {
128:           	PIR2bits.DMA1SCNTIF = 0; // clear Source Count Interrupt Flag 
1C0D4  0139     MOVLB 0x39
1C0D6  91A2     BCF TMR3_InterruptHandler, 0, BANKED
129:           	// add your DMA channel 1 source count 0 interrupt custom code
130:           	spi_link.LCD_DATA = 0;
1C0D8  0100     MOVLB 0x0
1C0DA  9760     BCF spi_link, 3, BANKED
131:           }
1C0DC  0011     RETFIE 1
132:           
133:           void __interrupt(irq(DMA1DCNT), base(8)) DMA1_DMADCNT_ISR()
1C0F4  EE14     LFSR 1, 0x115E
1C0F6  F15E     NOP
134:           {
135:           	PIR2bits.DMA1DCNTIF = 0; // clear Destination Count Interrupt Flag 
1C0F8  0139     MOVLB 0x39
1C0FA  93A2     BCF TMR3_InterruptHandler, 1, BANKED
136:           	// add your DMA channel 1 destination count 0 interrupt custom code
137:           }
1C0FC  0011     RETFIE 1
138:           
139:           #if (__XC8_VERSION <= 1400)
140:           void __interrupt(irq(DMA1ARBT), base(8)) DMA1_DMAA_ISR()
141:           #else   // __XC8_VERSION
142:           
143:           void __interrupt(irq(DMA1A), base(8)) DMA1_DMAA_ISR()
1C100  EE14     LFSR 1, 0x115E
1C102  F15E     NOP
144:           #endif // __XC8_VERSION
145:           {
146:           	PIR2bits.DMA1AIF = 0; // clear abort Interrupt Flag 
1C104  0139     MOVLB 0x39
1C106  97A2     BCF TMR3_InterruptHandler, 3, BANKED
147:           	// add your DMA channel 1 abort interrupt custom code
148:           }
1C108  0011     RETFIE 1
149:           
150:           #if (__XC8_VERSION <= 1400)
151:           void __interrupt(irq(IRQ_DMA1OVR), base(8)) DMA1_DMAOR_ISR()
152:           #else // __XC8_VERSION
153:           
154:           void __interrupt(irq(DMA1OR), base(8)) DMA1_DMAOR_ISR()
1C10C  EE14     LFSR 1, 0x115E
1C10E  F15E     NOP
155:           #endif // __XC8_VERSION
156:           {
157:           	PIR2bits.DMA1ORIF = 0; // clear overrun Interrupt Flag 
1C110  0139     MOVLB 0x39
1C112  95A2     BCF TMR3_InterruptHandler, 2, BANKED
158:           	// add your DMA channel 1 overrun interrupt custom code
159:           }
1C114  0011     RETFIE 1
160:           /**
161:             End of File
162:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/clkref.c  ----------------------------
1:             /**
2:               CLKREF Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 clkref.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the CLKREF driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for CLKREF.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "clkref.h"
53:            
54:            /**
55:              Section: CLKREF APIs
56:            */
57:            
58:            void CLKREF_Initialize(void)
59:            {
60:                // CLK FOSC; 
61:                CLKRCLK = 0x00;
1C0DE  013C     MOVLB 0x3C
1C0E0  6BE6     CLRF 0xE6, BANKED
62:                // DC 50% Duty Cycle; DIV BaseClock/16; CLKREN enabled; 
63:                CLKRCON = 0x94;
1C0E2  0E94     MOVLW 0x94
1C0E4  6FE5     MOVWF 0xE5, BANKED
64:            }
1C0E6  0012     RETURN 0
65:            /**
66:             End of File
67:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mcc_generated_files/adcc.c  ------------------------------
1:             /**
2:               ADCC Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 adcc.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the ADCC driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides implementations for driver APIs for ADCC.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F57K42
18:                    Driver Version    :  2.13
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "adcc.h"
53:            #include "interrupt_manager.h"
54:            
55:            /**
56:              Section: ADCC Module Variables
57:            */
58:            void (*ADCC_ADI_InterruptHandler)(void);
59:            void (*ADCC_ADTI_InterruptHandler)(void);
60:            
61:            /**
62:              Section: ADCC Module APIs
63:            */
64:            
65:            void ADCC_Initialize(void)
66:            {
67:                // set the ADCC to the options selected in the User Interface
68:                // ADLTH 0; 
69:                ADLTHL = 0x00;
1AEC0  013E     MOVLB 0x3E
1AEC2  6BDE     CLRF 0xDE, BANKED
70:                // ADLTH 0; 
71:                ADLTHH = 0x00;
1AEC4  6BDF     CLRF 0xDF, BANKED
72:                // ADUTH 0; 
73:                ADUTHL = 0x00;
1AEC6  6BE0     CLRF 0xE0, BANKED
74:                // ADUTH 0; 
75:                ADUTHH = 0x00;
1AEC8  6BE1     CLRF 0xE1, BANKED
76:                // ADSTPT 0; 
77:                ADSTPTL = 0x00;
1AECA  6BE4     CLRF 0xE4, BANKED
78:                // ADSTPT 0; 
79:                ADSTPTH = 0x00;
1AECC  6BE5     CLRF 0xE5, BANKED
80:                // ADACC 0; 
81:                ADACCU = 0x00;
1AECE  6BEA     CLRF 0xEA, BANKED
82:                // ADRPT 64; 
83:                ADRPT = 0x40;
1AED0  0E40     MOVLW 0x40
1AED2  6FEC     MOVWF 0xEC, BANKED
84:                // ADPCH ANA0; 
85:                ADPCH = 0x00;
1AED4  6BF1     CLRF 0xF1, BANKED
86:                // ADACQ 32; 
87:                ADACQL = 0x20;
1AED6  0E20     MOVLW 0x20
1AED8  6FF3     MOVWF 0xF3, BANKED
88:                // ADACQ 0; 
89:                ADACQH = 0x00;
1AEDA  6BF4     CLRF 0xF4, BANKED
90:                // ADCAP Additional uC disabled; 
91:                ADCAP = 0x00;
1AEDC  6BF5     CLRF 0xF5, BANKED
92:                // ADPRE 0; 
93:                ADPREL = 0x00;
1AEDE  6BF6     CLRF 0xF6, BANKED
94:                // ADPRE 0; 
95:                ADPREH = 0x00;
1AEE0  6BF7     CLRF H, BANKED
96:                // ADDSEN disabled; ADGPOL digital_low; ADIPEN disabled; ADPPOL Vss; 
97:                ADCON1 = 0x00;
1AEE2  6BF9     CLRF 0xF9, BANKED
98:                // ADCRS 5; ADMD Burst_average_mode; ADACLR enabled; ADPSIS RES; 
99:                ADCON2 = 0x5B;
1AEE4  0E5B     MOVLW 0x5B
1AEE6  6FFA     MOVWF 0xFA, BANKED
100:               // ADCALC Actual result vs filtered value; ADTMD enabled; ADSOI ADGO not cleared; 
101:               ADCON3 = 0x27;
1AEE8  0E27     MOVLW 0x27
1AEEA  6FFB     MOVWF 0xFB, BANKED
102:               // ADMATH registers not updated; 
103:               ADSTAT = 0x00;
1AEEC  6BFC     CLRF 0xFC, BANKED
104:               // ADNREF VSS; ADPREF external; 
105:               ADREF = 0x02;
1AEEE  0E02     MOVLW 0x2
1AEF0  6FFD     MOVWF 0xFD, BANKED
106:               // ADACT disabled; 
107:               ADACT = 0x00;
1AEF2  6BFE     CLRF 0xFE, BANKED
108:               // ADCS FOSC/16; 
109:               ADCLK = 0x07;
1AEF4  0E07     MOVLW 0x7
1AEF6  6FFF     MOVWF 0xFF, BANKED
110:               // ADGO stop; ADFM right; ADON enabled; ADCS FOSC/ADCLK; ADCONT disabled; 
111:               ADCON0 = 0x84;
1AEF8  0E84     MOVLW 0x84
1AEFA  6FF8     MOVWF 0xF8, BANKED
112:               
113:               // Clear the ADC interrupt flag
114:               PIR1bits.ADIF = 0;
1AEFC  0139     MOVLB 0x39
1AEFE  95A1     BCF 0xA1, 2, BANKED
115:               // Enabling ADCC interrupt.
116:               PIE1bits.ADIE = 1;
1AF00  8591     BSF 0x91, 2, BANKED
117:           
118:               ADCC_SetADIInterruptHandler(ADCC_DefaultInterruptHandler);
1AF02  0E64     MOVLW 0x64
1AF04  6EE6     MOVWF 0xFE6, ACCESS
1AF06  0EC1     MOVLW 0xC1
1AF08  6EE6     MOVWF 0xFE6, ACCESS
1AF0A  0E01     MOVLW 0x1
1AF0C  6EE6     MOVWF 0xFE6, ACCESS
1AF0E  EC53     CALL 0x1BCA6, 0
1AF10  F0DE     NOP
119:           
120:               // Clear the ADC Threshold interrupt flag
121:               PIR1bits.ADTIF = 0;
1AF12  0139     MOVLB 0x39
1AF14  97A1     BCF 0xA1, 3, BANKED
122:               // Enabling ADCC threshold interrupt.
123:               PIE1bits.ADTIE = 1;
1AF16  8791     BSF 0x91, 3, BANKED
124:           
125:               ADCC_SetADTIInterruptHandler(ADCC_DefaultInterruptHandler);
1AF18  0E64     MOVLW 0x64
1AF1A  6EE6     MOVWF 0xFE6, ACCESS
1AF1C  0EC1     MOVLW 0xC1
1AF1E  6EE6     MOVWF 0xFE6, ACCESS
1AF20  0E01     MOVLW 0x1
1AF22  6EE6     MOVWF 0xFE6, ACCESS
1AF24  EC3F     CALL 0x1BC7E, 0
1AF26  F0DE     NOP
126:           }
1AF28  0012     RETURN 0
127:           
128:           void ADCC_StartConversion(adcc_channel_t channel)
129:           {
130:               // select the A/D channel
131:               ADPCH = channel;      
1C034  0EFF     MOVLW 0xFF
1C038  FF8F     NOP
1C03A  FEF1     NOP
132:             
133:               // Turn on the ADC module
134:               ADCON0bits.ADON = 1;
1C03C  013E     MOVLB 0x3E
1C03E  8FF8     BSF 0xF8, 7, BANKED
135:           
136:               // Start the conversion
137:               ADCON0bits.ADGO = 1;
1C040  81F8     BSF 0xF8, 0, BANKED
138:           }
1C042  52E5     MOVF 0xFE5, F, ACCESS
1C044  0012     RETURN 0
139:           
140:           bool ADCC_IsConversionDone()
141:           {
142:               // Start the conversion
143:               return ((unsigned char)(!ADCON0bits.ADGO));
144:           }
145:           
146:           adc_result_t ADCC_GetConversionResult(void)
147:           {
148:               // Return the result
149:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
150:           }
151:           
152:           adc_result_t ADCC_GetSingleConversion(adcc_channel_t channel)
153:           {
154:               // select the A/D channel
155:               ADPCH = channel;  
156:           
157:               // Turn on the ADC module
158:               ADCON0bits.ADON = 1;
159:           	
160:               //Disable the continuous mode.
161:               ADCON0bits.ADCONT = 0;    
162:           
163:               // Start the conversion
164:               ADCON0bits.ADGO = 1;
165:           
166:           
167:               // Wait for the conversion to finish
168:               while (ADCON0bits.ADGO)
169:               {
170:               }
171:               
172:               
173:               // Conversion finished, return the result
174:               return ((adc_result_t)((ADRESH << 8) + ADRESL));
175:           }
176:           
177:           void ADCC_StopConversion(void)
178:           {
179:               //Reset the ADGO bit.
180:               ADCON0bits.ADGO = 0;
181:           }
182:           
183:           void ADCC_SetStopOnInterrupt(void)
184:           {
185:               //Set the ADSOI bit.
186:               ADCON3bits.ADSOI = 1;
187:           }
188:           
189:           void ADCC_DischargeSampleCapacitor(void)
190:           {
191:               //Set the ADC channel to AVss.
192:               ADPCH = 0x3b;   
1C116  0E3B     MOVLW 0x3B
1C118  013E     MOVLB 0x3E
1C11A  6FF1     MOVWF 0xF1, BANKED
193:           }
1C11C  0012     RETURN 0
194:           
195:           void ADCC_LoadAcquisitionRegister(uint16_t acquisitionValue)
196:           {
197:               //Load the ADACQH and ADACQL registers.
198:               ADACQH = acquisitionValue >> 8; 
199:               ADACQL = acquisitionValue;  
200:           }
201:           
202:           void ADCC_SetPrechargeTime(uint16_t prechargeTime)
203:           {
204:               //Load the ADPREH and ADPREL registers.
205:               ADPREH = prechargeTime >> 8;  
206:               ADPREL = prechargeTime;
207:           }
208:           
209:           void ADCC_SetRepeatCount(uint8_t repeatCount)
210:           {
211:               //Load the ADRPT register.
212:               ADRPT = repeatCount;   
213:           }
214:           
215:           uint8_t ADCC_GetCurrentCountofConversions(void)
216:           {
217:               //Return the contents of ADCNT register
218:               return ADCNT;
219:           }
220:           
221:           void ADCC_ClearAccumulator(void)
222:           {
223:               //Reset the ADCON2bits.ADACLR bit.
224:               ADCON2bits.ADACLR = 1;
225:           }
226:           
227:           int24_t ADCC_GetAccumulatorValue(void)
228:           {
229:               //Return the contents of ADACCU, ADACCH and ADACCL registers
230:               return (((int24_t)ADACCU << 16)+((int24_t)ADACCH << 8) + ADACCL);
231:           }
232:           
233:           bool ADCC_HasAccumulatorOverflowed(void)
234:           {
235:               //Return the status of ADSTATbits.ADAOV
236:               return ADSTATbits.ADAOV;
237:           }
238:           
239:           uint16_t ADCC_GetFilterValue(void)
240:           {
241:               //Return the contents of ADFLTRH and ADFLTRL registers
242:               return ((uint16_t)((ADFLTRH << 8) + ADFLTRL));
243:           }
244:           
245:           uint16_t ADCC_GetPreviousResult(void)
246:           {
247:               //Return the contents of ADPREVH and ADPREVL registers
248:               return ((uint16_t)((ADPREVH << 8) + ADPREVL));
249:           }
250:           
251:           void ADCC_DefineSetPoint(uint16_t setPoint)
252:           {
253:               //Sets the ADSTPTH and ADSTPTL registers
254:               ADSTPTH = setPoint >> 8;
255:               ADSTPTL = setPoint;
256:           }
257:           
258:           void ADCC_SetUpperThreshold(uint16_t upperThreshold)
259:           {
260:               //Sets the ADUTHH and ADUTHL registers
261:               ADUTHH = upperThreshold >> 8;
262:               ADUTHL = upperThreshold;
263:           }
264:           
265:           void ADCC_SetLowerThreshold(uint16_t lowerThreshold)
266:           {
267:               //Sets the ADLTHH and ADLTHL registers
268:               ADLTHH = lowerThreshold >> 8;
269:               ADLTHL = lowerThreshold;
270:           }
271:           
272:           uint16_t ADCC_GetErrorCalculation(void)
273:           {
274:           	//Return the contents of ADERRH and ADERRL registers
275:           	return ((uint16_t)((ADERRH << 8) + ADERRL));
276:           }
277:           
278:           void ADCC_EnableDoubleSampling(void)
279:           {
280:               //Sets the ADCON1bits.ADDSEN
281:               ADCON1bits.ADDSEN = 1;
282:           }
283:           
284:           void ADCC_EnableContinuousConversion(void)
285:           {
286:               //Sets the ADCON0bits.ADCONT
287:               ADCON0bits.ADCONT = 1;
288:           }
289:           
290:           void ADCC_DisableContinuousConversion(void)
291:           {
292:               //Resets the ADCON0bits.ADCONT
293:               ADCON0bits.ADCONT = 0;
294:           }
295:           
296:           bool ADCC_HasErrorCrossedUpperThreshold(void)
297:           {
298:               //Returns the value of ADSTATbits.ADUTHR bit.
299:               return ADSTATbits.ADUTHR;
300:           }
301:           
302:           bool ADCC_HasErrorCrossedLowerThreshold(void)
303:           {
304:               //Returns the value of ADSTATbits.ADLTHR bit.
305:               return ADSTATbits.ADLTHR;
306:           }
307:           
308:           uint8_t ADCC_GetConversionStageStatus(void)
309:           {
310:               //Returns the contents of ADSTATbits.ADSTAT field.
311:               return ADSTATbits.ADSTAT;
312:           }
313:           
314:           void __interrupt(irq(AD),base(8)) ADCC_ISR()
1BA6C  EE14     LFSR 1, 0x115E
315:           {
316:               // Clear the ADCC interrupt flag
317:               PIR1bits.ADIF = 0;
1BA70  0139     MOVLB 0x39
1BA72  95A1     BCF 0xA1, 2, BANKED
318:           
319:               if (ADCC_ADI_InterruptHandler)
1BA74  0100     MOVLB 0x0
1BA76  51AE     MOVF ADCC_ADI_InterruptHandler, W, BANKED
1BA78  11AF     IORWF 0xAF, W, BANKED
1BA7A  11B0     IORWF 0xB0, W, BANKED
1BA7C  B4D8     BTFSC 0xFD8, 2, ACCESS
1BA7E  0011     RETFIE 1
320:                       ADCC_ADI_InterruptHandler();
1BA80  D801     RCALL 0xBA84
1BA82  0011     RETFIE 1
1BA84  0005     PUSH
1BA86  6EFA     MOVWF 0xFFA, ACCESS
1BA88  51AE     MOVF ADCC_ADI_InterruptHandler, W, BANKED
1BA8A  6EFD     MOVWF 0xFFD, ACCESS
1BA8C  51AF     MOVF 0xAF, W, BANKED
1BA8E  6EFE     MOVWF 0xFFE, ACCESS
1BA90  51B0     MOVF 0xB0, W, BANKED
1BA92  6EFF     MOVWF 0xFFF, ACCESS
1BA94  50FA     MOVF 0xFFA, W, ACCESS
1BA96  0012     RETURN 0
321:           }
322:           
323:           void ADCC_SetADIInterruptHandler(void (* InterruptHandler)(void)){
324:               ADCC_ADI_InterruptHandler = InterruptHandler;
1BCA6  50E1     MOVF 0xFE1, W, ACCESS
1BCA8  0FFD     ADDLW 0xFD
1BCAA  6ED9     MOVWF 0xFD9, ACCESS
1BCAC  50E2     MOVF 0xFE2, W, ACCESS
1BCAE  6EDA     MOVWF 0xFDA, ACCESS
1BCB0  0EFF     MOVLW 0xFF
1BCB2  22DA     ADDWFC 0xFDA, F, ACCESS
1BCB6  FF78     NOP
1BCB8  F0AE     NOP
1BCBC  FF78     NOP
1BCBE  F0AF     NOP
1BCC2  FF74     NOP
1BCC4  F0B0     NOP
325:           }
1BCC6  52E5     MOVF 0xFE5, F, ACCESS
1BCC8  52E5     MOVF 0xFE5, F, ACCESS
1BCCA  52E5     MOVF 0xFE5, F, ACCESS
1BCCC  0012     RETURN 0
326:           
327:           void __interrupt(irq(ADT),base(8)) ADCC_ThresholdISR()
1AF2E  F004     NOP
1AF30  F021     NOP
1AF34  F008     NOP
1AF36  F022     NOP
1AF3A  F024     NOP
1AF3C  F023     NOP
1AF40  F028     NOP
1AF42  F024     NOP
1AF46  F030     NOP
1AF48  F025     NOP
1AF4A  EE14     LFSR 1, 0x115E
1AF4C  F15E     NOP
328:           {
329:               // Clear the ADCC Threshold interrupt flag
330:               PIR1bits.ADTIF = 0;
1AF4E  0139     MOVLB 0x39
1AF50  97A1     BCF 0xA1, 3, BANKED
331:           
332:               if (ADCC_ADTI_InterruptHandler)
1AF52  0100     MOVLB 0x0
1AF54  51AB     MOVF ADCC_ADTI_InterruptHandler, W, BANKED
1AF56  11AC     IORWF 0xAC, W, BANKED
1AF58  11AD     IORWF 0xAD, W, BANKED
1AF5A  B4D8     BTFSC 0xFD8, 2, ACCESS
1AF5C  D00C     BRA 0xAF76
333:                   ADCC_ADTI_InterruptHandler();
1AF5E  D801     RCALL 0xAF62
1AF60  D00A     BRA 0xAF76
1AF62  0005     PUSH
1AF64  6EFA     MOVWF 0xFFA, ACCESS
1AF66  51AB     MOVF ADCC_ADTI_InterruptHandler, W, BANKED
1AF68  6EFD     MOVWF 0xFFD, ACCESS
1AF6A  51AC     MOVF 0xAC, W, BANKED
1AF6C  6EFE     MOVWF 0xFFE, ACCESS
1AF6E  51AD     MOVF 0xAD, W, BANKED
1AF70  6EFF     MOVWF 0xFFF, ACCESS
1AF72  50FA     MOVF 0xFFA, W, ACCESS
1AF74  0012     RETURN 0
334:           }
1BCD0  EE14     LFSR 1, 0x115E
1BCD2  F15E     NOP
335:           
336:           void ADCC_SetADTIInterruptHandler(void (* InterruptHandler)(void)){
337:               ADCC_ADTI_InterruptHandler = InterruptHandler;
1BC7E  50E1     MOVF 0xFE1, W, ACCESS
1BC80  0FFD     ADDLW 0xFD
1BC82  6ED9     MOVWF 0xFD9, ACCESS
1BC84  50E2     MOVF 0xFE2, W, ACCESS
1BC86  6EDA     MOVWF 0xFDA, ACCESS
1BC88  0EFF     MOVLW 0xFF
1BC8A  22DA     ADDWFC 0xFDA, F, ACCESS
1BC8E  FF78     NOP
1BC90  F0AB     NOP
1BC94  FF78     NOP
1BC96  F0AC     NOP
1BC9A  FF74     NOP
1BC9C  F0AD     NOP
338:           }
1BC9E  52E5     MOVF 0xFE5, F, ACCESS
1BCA0  52E5     MOVF 0xFE5, F, ACCESS
1BCA2  52E5     MOVF 0xFE5, F, ACCESS
1BCA4  0012     RETURN 0
339:           void ADCC_DefaultInterruptHandler(void){
340:               // add your ADCC interrupt custom code
341:               // or set custom function using ADCC_SetADIInterruptHandler() or ADCC_SetADTIInterruptHandler()
342:           }
1C164  0012     RETURN 0
343:           /**
344:            End of File
345:           */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/mbmc.c  --------------------------------------------------
1:             #include "mbmc.h"
2:             #include "mcc_generated_files/ext_int.h"
3:             #include "bsoc.h"
4:             
5:             extern C_data C;
6:             extern V_data V;
7:             
8:             struct tm t_mbmc; // don't use the xc8 clock function
9:             volatile uint32_t utctime = 0; // utctime set from remote ntp server
10:            volatile struct P_data P = {
11:            	.SYSTEM_STABLE = false,
12:            };
13:            
14:            /* spinner defines */
15:            #define MAX_SHAPES  6
16:            const char spin[MAX_SHAPES][20] = {
17:            	"||//--", // classic LCD version with no \ character
18:            	"||//--\\\\", // classic
19:            	"OOOOOO--__-", // eye blink
20:            	"vv<<^^>>", // point spinner
21:            	"..**x#x#XX||--", // warp portal
22:            	"..ooOOoo" // ball bouncer
23:            };
24:            
25:            /*
26:             * floating point low pass filter, 
27:             * slow/fast select, use (-1) to zero buffer channel and return new
28:             */
29:            float lp_filter(const float new, const uint8_t bn, const int8_t slow)
1867E  52E6     MOVF 0xFE6, F, ACCESS
18680  52E6     MOVF 0xFE6, F, ACCESS
18682  52E6     MOVF 0xFE6, F, ACCESS
18684  52E6     MOVF 0xFE6, F, ACCESS
30:            {
31:            	static float smooth[LP_BUFFER_SIZE];
32:            	float lp_speed;
33:            
34:            	if (bn >= LP_BUFFER_SIZE) // buffer index check
18686  0EF7     MOVLW 0xF7
1868A  FF8C     NOP
1868C  F001     NOP
1868E  0E14     MOVLW 0x14
18690  6401     CPFSGT ltemp0, ACCESS
18692  D011     BRA 0x86B6
35:            		return new;
18694  0EF8     MOVLW 0xF8
18698  FF8C     NOP
1869A  F001     NOP
1869C  0EF9     MOVLW 0xF9
186A0  FF8C     NOP
186A2  F002     NOP
186A4  0EFA     MOVLW 0xFA
186A8  FF8C     NOP
186AA  F003     NOP
186AC  0EFB     MOVLW 0xFB
186B0  FF8C     NOP
186B2  F004     NOP
186B4  D0BD     BRA 0x8830
36:            
37:            	if (slow == (-1)) { // reset smooth buffer and return original value
186B6  0EF6     MOVLW 0xF6
186B8  28E3     INCF 0xFE3, W, ACCESS
186BA  A4D8     BTFSS 0xFD8, 2, ACCESS
186BC  D012     BRA 0x86E2
38:            		smooth[bn] = 0.0;
186BE  0EF7     MOVLW 0xF7
186C0  50E3     MOVF 0xFE3, W, ACCESS
186C2  0D04     MULLW 0x4
186C4  0E00     MOVLW 0x0
186C6  24F3     ADDWF 0xFF3, W, ACCESS
186C8  6ED9     MOVWF 0xFD9, ACCESS
186CA  0E02     MOVLW 0x2
186CC  20F4     ADDWFC 0xFF4, W, ACCESS
186CE  6EDA     MOVWF 0xFDA, ACCESS
186D0  0E00     MOVLW 0x0
186D2  6EDE     MOVWF 0xFDE, ACCESS
186D4  0E00     MOVLW 0x0
186D6  6EDE     MOVWF 0xFDE, ACCESS
186D8  0E00     MOVLW 0x0
186DA  6EDE     MOVWF 0xFDE, ACCESS
186DC  0E00     MOVLW 0x0
186DE  6EDD     MOVWF 0xFDD, ACCESS
186E0  D7D9     BRA 0x8694
39:            		return new;
40:            	}
41:            
42:            	if (slow) { // some random filter cutoffs beta values
186E2  0EF6     MOVLW 0xF6
186E4  50E3     MOVF 0xFE3, W, ACCESS
186E6  B4D8     BTFSC 0xFD8, 2, ACCESS
186E8  D006     BRA 0x86F6
43:            		lp_speed = 0.033;
186EA  0E02     MOVLW 0x2
186EC  6E09     MOVWF ltemp2, ACCESS
186EE  0E2B     MOVLW 0x2B
186F0  6E0A     MOVWF ttemp3, ACCESS
186F2  0E07     MOVLW 0x7
186F4  D005     BRA 0x8700
44:            	} else {
45:            		lp_speed = 0.066;
186F6  0E02     MOVLW 0x2
186F8  6E09     MOVWF ltemp2, ACCESS
186FA  0E2B     MOVLW 0x2B
186FC  6E0A     MOVWF ttemp3, ACCESS
186FE  0E87     MOVLW 0x87
18700  6E0B     MOVWF wtemp5, ACCESS
18702  0E3D     MOVLW 0x3D
18704  6E0C     MOVWF 0xC, ACCESS
18706  0EFC     MOVLW 0xFC
1870A  F027     NOP
1870C  FFE3     NOP
1870E  0EFD     MOVLW 0xFD
18712  F02B     NOP
18714  FFE3     NOP
18716  0EFE     MOVLW 0xFE
1871A  F02F     NOP
1871C  FFE3     NOP
1871E  0EFF     MOVLW 0xFF
18722  F033     NOP
18724  FFE3     NOP
46:            	}
47:            	// exponentially weighted moving average
48:            	return smooth[bn] = smooth[bn] + ((new - smooth[bn]) * lp_speed);
18726  0EF7     MOVLW 0xF7
18728  50E3     MOVF 0xFE3, W, ACCESS
1872A  0D04     MULLW 0x4
1872C  0E00     MOVLW 0x0
1872E  24F3     ADDWF 0xFF3, W, ACCESS
18730  6ED9     MOVWF 0xFD9, ACCESS
18732  0E02     MOVLW 0x2
18734  20F4     ADDWFC 0xFF4, W, ACCESS
18736  6EDA     MOVWF 0xFDA, ACCESS
1873A  FF7B     NOP
1873C  FFE6     NOP
18740  FF7B     NOP
18742  FFE6     NOP
18746  FF7B     NOP
18748  FFE6     NOP
1874C  FF7B     NOP
1874E  FFE6     NOP
18750  0EF8     MOVLW 0xF8
18754  FF8F     NOP
18756  FFE6     NOP
1875A  FF8F     NOP
1875C  FFE6     NOP
18760  FF8F     NOP
18762  FFE6     NOP
18766  FF8F     NOP
18768  FFE6     NOP
1876A  0EEF     MOVLW 0xEF
1876C  50E3     MOVF 0xFE3, W, ACCESS
1876E  0D04     MULLW 0x4
18770  0E00     MOVLW 0x0
18772  24F3     ADDWF 0xFF3, W, ACCESS
18774  6ED9     MOVWF 0xFD9, ACCESS
18776  0E02     MOVLW 0x2
18778  20F4     ADDWFC 0xFF4, W, ACCESS
1877A  6EDA     MOVWF 0xFDA, ACCESS
1877E  FF7B     NOP
18780  FFE6     NOP
18784  FF7B     NOP
18786  FFE6     NOP
1878A  FF7B     NOP
1878C  FFE6     NOP
18790  FF7B     NOP
18792  FFE6     NOP
18794  0EEC     MOVLW 0xEC
18798  FF8F     NOP
1879A  FFE6     NOP
1879E  FF8F     NOP
187A0  FFE6     NOP
187A4  FF8F     NOP
187A6  FFE6     NOP
187AA  FF8F     NOP
187AC  FFE6     NOP
187AE  ECBF     CALL 0x1B57E, 0
187B0  F0DA     NOP
187B4  F007     NOP
187B6  FFE6     NOP
187BA  F00B     NOP
187BC  FFE6     NOP
187C0  F00F     NOP
187C2  FFE6     NOP
187C6  F013     NOP
187C8  FFE6     NOP
187CA  ECC1     CALL 0x13D82, 0
187CC  F09E     NOP
187D0  F007     NOP
187D2  FFE6     NOP
187D6  F00B     NOP
187D8  FFE6     NOP
187DC  F00F     NOP
187DE  FFE6     NOP
187E2  F013     NOP
187E4  FFE6     NOP
187E6  ECD6     CALL 0x145AC, 0
187E8  F0A2     NOP
187EA  0EF7     MOVLW 0xF7
187EC  50E3     MOVF 0xFE3, W, ACCESS
187EE  0D04     MULLW 0x4
187F0  0E00     MOVLW 0x0
187F2  24F3     ADDWF 0xFF3, W, ACCESS
187F4  6ED9     MOVWF 0xFD9, ACCESS
187F6  0E02     MOVLW 0x2
187F8  20F4     ADDWFC 0xFF4, W, ACCESS
187FA  6EDA     MOVWF 0xFDA, ACCESS
187FE  F007     NOP
18800  FFDE     NOP
18804  F00B     NOP
18806  FFDE     NOP
1880A  F00F     NOP
1880C  FFDE     NOP
18810  F013     NOP
18812  FFDD     NOP
18814  52DD     MOVF 0xFDD, F, ACCESS
18816  52DD     MOVF 0xFDD, F, ACCESS
1881A  FF78     NOP
1881C  F001     NOP
18820  FF78     NOP
18822  F002     NOP
18826  FF78     NOP
18828  F003     NOP
1882C  FF78     NOP
1882E  F004     NOP
49:            }
18830  0EF6     MOVLW 0xF6
18832  26E1     ADDWF 0xFE1, F, ACCESS
18834  0EFF     MOVLW 0xFF
18836  22E2     ADDWFC 0xFE2, F, ACCESS
18838  0012     RETURN 0
50:            
51:            void convert_adc_data(void)
1A4D4  52E6     MOVF 0xFE6, F, ACCESS
52:            {
53:            	uint8_t i = 0;
1A4D6  0EFF     MOVLW 0xFF
1A4D8  6AE3     CLRF 0xFE3, ACCESS
54:            
55:            	do {
56:            		if (V.calib) {
1A4DA  0101     MOVLB 0x1
1A4DC  51DC     MOVF 0xDC, W, BANKED
1A4DE  B4D8     BTFSC 0xFD8, 2, ACCESS
1A4E0  D01B     BRA 0xA518
57:            			C.calc[i] = lp_filter(conv_raw_result(i, O_CONV), i, true);
1A4E2  0E01     MOVLW 0x1
1A4E4  6EE6     MOVWF 0xFE6, ACCESS
1A4E6  0EFE     MOVLW 0xFE
1A4E8  50E3     MOVF 0xFE3, W, ACCESS
1A4EA  6EE6     MOVWF 0xFE6, ACCESS
1A4EC  0E01     MOVLW 0x1
1A4EE  6EE6     MOVWF 0xFE6, ACCESS
1A4F0  0EFC     MOVLW 0xFC
1A4F2  50E3     MOVF 0xFE3, W, ACCESS
1A4F4  6EE6     MOVWF 0xFE6, ACCESS
1A4F6  EC71     CALL 0x152E2, 0
1A4F8  F0A9     NOP
1A4FC  F007     NOP
1A4FE  FFE6     NOP
1A502  F00B     NOP
1A504  FFE6     NOP
1A508  F00F     NOP
1A50A  FFE6     NOP
1A50E  F013     NOP
1A510  FFE6     NOP
1A512  EC3F     CALL 0x1867E, 0
1A514  F0C3     NOP
1A516  D01A     BRA 0xA54C
58:            		} else {
59:            			C.calc[i] = lp_filter(conv_raw_result(i, CONV), i, false);
1A518  0E00     MOVLW 0x0
1A51A  6EE6     MOVWF 0xFE6, ACCESS
1A51C  0EFE     MOVLW 0xFE
1A51E  50E3     MOVF 0xFE3, W, ACCESS
1A520  6EE6     MOVWF 0xFE6, ACCESS
1A522  0E00     MOVLW 0x0
1A524  6EE6     MOVWF 0xFE6, ACCESS
1A526  0EFC     MOVLW 0xFC
1A528  50E3     MOVF 0xFE3, W, ACCESS
1A52A  6EE6     MOVWF 0xFE6, ACCESS
1A52C  EC71     CALL 0x152E2, 0
1A52E  F0A9     NOP
1A532  F007     NOP
1A534  FFE6     NOP
1A538  F00B     NOP
1A53A  FFE6     NOP
1A53E  F00F     NOP
1A540  FFE6     NOP
1A544  F013     NOP
1A546  FFE6     NOP
1A548  EC3F     CALL 0x1867E, 0
1A54A  F0C3     NOP
1A54C  0EFF     MOVLW 0xFF
1A54E  50E3     MOVF 0xFE3, W, ACCESS
1A550  0D04     MULLW 0x4
1A552  0EFF     MOVLW 0xFF
1A554  24F3     ADDWF 0xFF3, W, ACCESS
1A556  6ED9     MOVWF 0xFD9, ACCESS
1A558  0E06     MOVLW 0x6
1A55A  20F4     ADDWFC 0xFF4, W, ACCESS
1A55C  6EDA     MOVWF 0xFDA, ACCESS
1A560  F007     NOP
1A562  FFDE     NOP
1A566  F00B     NOP
1A568  FFDE     NOP
1A56C  F00F     NOP
1A56E  FFDE     NOP
1A572  F013     NOP
1A574  FFDE     NOP
60:            		}
61:            	} while (++i < ADC_BUFFER_SIZE);
1A576  0EFF     MOVLW 0xFF
1A578  2AE3     INCF 0xFE3, F, ACCESS
1A57A  0EFF     MOVLW 0xFF
1A57E  FF8C     NOP
1A580  F001     NOP
1A582  0E0F     MOVLW 0xF
1A584  6401     CPFSGT ltemp0, ACCESS
1A586  D7A9     BRA 0xA4DA
62:            }
1A588  52E5     MOVF 0xFE5, F, ACCESS
1A58A  0012     RETURN 0
63:            
64:            /*
65:             * buffer model data from DAQ
66:             */
67:            void calc_model_data(void)
68:            {
69:            	static float bvror = 0.0, bcror = 0.0;
70:            	stop_bsoc();
15C76  ECA8     CALL 0x1C150, 0
15C78  F0E0     NOP
71:            
72:            	if (!V.calib) {
15C7A  0101     MOVLB 0x1
15C7C  51DC     MOVF 0xDC, W, BANKED
15C7E  A4D8     BTFSS 0xFD8, 2, ACCESS
15C80  D219     BRA 0x60B4
73:            		C.c_bat = C.calc[C_BATT];
15C82  EE21     LFSR 2, 0x6FF
15C84  F2FF     NOP
15C88  FF78     NOP
15C8A  F743     NOP
15C8E  FF78     NOP
15C90  F744     NOP
15C94  FF78     NOP
15C96  F745     NOP
15C9A  FF74     NOP
15C9C  F746     NOP
74:            		C.bc_ror = C.c_bat - bcror;
15CA0  F23B     NOP
15CA2  FFE6     NOP
15CA6  F23F     NOP
15CA8  FFE6     NOP
15CAC  F243     NOP
15CAE  FFE6     NOP
15CB2  F247     NOP
15CB4  FFE6     NOP
15CB6  EE21     LFSR 2, 0x743
15CB8  F343     NOP
15CBC  FF7B     NOP
15CBE  FFE6     NOP
15CC2  FF7B     NOP
15CC4  FFE6     NOP
15CC8  FF7B     NOP
15CCA  FFE6     NOP
15CCE  FF7B     NOP
15CD0  FFE6     NOP
15CD2  ECBF     CALL 0x1B57E, 0
15CD4  F0DA     NOP
15CD8  F004     NOP
15CDA  F76F     NOP
15CDE  F008     NOP
15CE0  F770     NOP
15CE4  F00C     NOP
15CE6  F771     NOP
15CEA  F010     NOP
15CEC  F772     NOP
75:            		bcror = C.c_bat;
15CEE  C743     MOVFF 0x743, bcror
15CF0  F08E     NOP
15CF2  C744     MOVFF 0x744, 0x8F
15CF4  F08F     NOP
15CF6  C745     MOVFF 0x745, 0x90
15CF8  F090     NOP
15CFA  C746     MOVFF 0x746, 0x91
15CFC  F091     NOP
76:            		C.c_pv = C.calc[C_PV];
15CFE  EE21     LFSR 2, 0x703
15D00  F303     NOP
15D04  FF78     NOP
15D06  F747     NOP
15D0A  FF78     NOP
15D0C  F748     NOP
15D10  FF78     NOP
15D12  F749     NOP
15D16  FF74     NOP
15D18  F74A     NOP
77:            		C.v_bat = C.calc[V_BAT];
15D1A  EE21     LFSR 2, 0x70F
15D1C  F30F     NOP
15D20  FF78     NOP
15D22  F753     NOP
15D26  FF78     NOP
15D28  F754     NOP
15D2C  FF78     NOP
15D2E  F755     NOP
15D32  FF74     NOP
15D34  F756     NOP
78:            		C.v_sensor = C.calc[V_LIGHT_SENSOR];
15D36  EE21     LFSR 2, 0x733
15D38  F333     NOP
15D3C  FF78     NOP
15D3E  F767     NOP
15D42  FF78     NOP
15D44  F768     NOP
15D48  FF78     NOP
15D4A  F769     NOP
15D4E  FF74     NOP
15D50  F76A     NOP
79:            		C.bv_ror = C.v_bat - bvror;
15D54  F24B     NOP
15D56  FFE6     NOP
15D5A  F24F     NOP
15D5C  FFE6     NOP
15D60  F253     NOP
15D62  FFE6     NOP
15D66  F257     NOP
15D68  FFE6     NOP
15D6A  EE21     LFSR 2, 0x753
15D6C  F353     NOP
15D70  FF7B     NOP
15D72  FFE6     NOP
15D76  FF7B     NOP
15D78  FFE6     NOP
15D7C  FF7B     NOP
15D7E  FFE6     NOP
15D82  FF7B     NOP
15D84  FFE6     NOP
15D86  ECBF     CALL 0x1B57E, 0
15D88  F0DA     NOP
15D8C  F004     NOP
15D8E  F76B     NOP
15D92  F008     NOP
15D94  F76C     NOP
15D98  F00C     NOP
15D9A  F76D     NOP
15D9E  F010     NOP
15DA0  F76E     NOP
80:            		bvror = C.v_bat;
15DA2  C753     MOVFF 0x753, bvror
15DA4  F092     NOP
15DA6  C754     MOVFF 0x754, 0x93
15DA8  F093     NOP
15DAA  C755     MOVFF 0x755, 0x94
15DAC  F094     NOP
15DAE  C756     MOVFF 0x756, 0x95
15DB0  F095     NOP
81:            		C.v_pv = C.calc[V_PV];
15DB2  EE21     LFSR 2, 0x713
15DB4  F313     NOP
15DB8  FF78     NOP
15DBA  F74F     NOP
15DBE  FF78     NOP
15DC0  F750     NOP
15DC4  FF78     NOP
15DC6  F751     NOP
15DCA  FF74     NOP
15DCC  F752     NOP
82:            		C.v_cc = C.calc[V_CC];
15DCE  EE21     LFSR 2, 0x707
15DD0  F307     NOP
15DD4  FF78     NOP
15DD6  F74B     NOP
15DDA  FF78     NOP
15DDC  F74C     NOP
15DE0  FF78     NOP
15DE2  F74D     NOP
15DE6  FF74     NOP
15DE8  F74E     NOP
83:            		C.v_inverter = C.calc[V_INVERTER];
15DEA  EE21     LFSR 2, 0x72F
15DEC  F32F     NOP
15DF0  FF78     NOP
15DF2  F763     NOP
15DF6  FF78     NOP
15DF8  F764     NOP
15DFC  FF78     NOP
15DFE  F765     NOP
15E02  FF74     NOP
15E04  F766     NOP
84:            		C.c_load = lp_filter(C.calc[C_PV]+(-(C.calc[C_BATT])), 16, true);
15E06  0E01     MOVLW 0x1
15E08  6EE6     MOVWF 0xFE6, ACCESS
15E0A  0E10     MOVLW 0x10
15E0C  6EE6     MOVWF 0xFE6, ACCESS
15E0E  EE21     LFSR 2, 0x6FF
15E10  F2FF     NOP
15E14  FF7B     NOP
15E16  FFE6     NOP
15E1A  FF7B     NOP
15E1C  FFE6     NOP
15E20  FF7B     NOP
15E22  FFE6     NOP
15E26  FF7B     NOP
15E28  FFE6     NOP
15E2A  EE21     LFSR 2, 0x703
15E2C  F303     NOP
15E30  FF7B     NOP
15E32  FFE6     NOP
15E36  FF7B     NOP
15E38  FFE6     NOP
15E3C  FF7B     NOP
15E3E  FFE6     NOP
15E42  FF7B     NOP
15E44  FFE6     NOP
15E46  ECBF     CALL 0x1B57E, 0
15E48  F0DA     NOP
15E4C  F007     NOP
15E4E  FFE6     NOP
15E52  F00B     NOP
15E54  FFE6     NOP
15E58  F00F     NOP
15E5A  FFE6     NOP
15E5E  F013     NOP
15E60  FFE6     NOP
15E62  EC3F     CALL 0x1867E, 0
15E64  F0C3     NOP
15E68  F004     NOP
15E6A  F73F     NOP
15E6E  F008     NOP
15E70  F740     NOP
15E74  F00C     NOP
15E76  F741     NOP
15E7A  F010     NOP
15E7C  F742     NOP
85:            		C.p_load = lp_filter(C.c_load * C.v_bat, 17, true);
15E7E  0E01     MOVLW 0x1
15E80  6EE6     MOVWF 0xFE6, ACCESS
15E82  0E11     MOVLW 0x11
15E84  6EE6     MOVWF 0xFE6, ACCESS
15E86  EE21     LFSR 2, 0x753
15E88  F353     NOP
15E8C  FF7B     NOP
15E8E  FFE6     NOP
15E92  FF7B     NOP
15E94  FFE6     NOP
15E98  FF7B     NOP
15E9A  FFE6     NOP
15E9E  FF7B     NOP
15EA0  FFE6     NOP
15EA2  EE21     LFSR 2, 0x73F
15EA4  F33F     NOP
15EA8  FF7B     NOP
15EAA  FFE6     NOP
15EAE  FF7B     NOP
15EB0  FFE6     NOP
15EB4  FF7B     NOP
15EB6  FFE6     NOP
15EBA  FF7B     NOP
15EBC  FFE6     NOP
15EBE  ECC1     CALL 0x13D82, 0
15EC0  F09E     NOP
15EC4  F007     NOP
15EC6  FFE6     NOP
15ECA  F00B     NOP
15ECC  FFE6     NOP
15ED0  F00F     NOP
15ED2  FFE6     NOP
15ED6  F013     NOP
15ED8  FFE6     NOP
15EDA  EC3F     CALL 0x1867E, 0
15EDC  F0C3     NOP
15EE0  F004     NOP
15EE2  F773     NOP
15EE6  F008     NOP
15EE8  F774     NOP
15EEC  F00C     NOP
15EEE  F775     NOP
15EF2  F010     NOP
15EF4  F776     NOP
86:            		C.p_pv = lp_filter(C.c_pv * C.v_pv, 18, true);
15EF6  0E01     MOVLW 0x1
15EF8  6EE6     MOVWF 0xFE6, ACCESS
15EFA  0E12     MOVLW 0x12
15EFC  6EE6     MOVWF 0xFE6, ACCESS
15EFE  EE21     LFSR 2, 0x74F
15F00  F34F     NOP
15F04  FF7B     NOP
15F06  FFE6     NOP
15F0A  FF7B     NOP
15F0C  FFE6     NOP
15F10  FF7B     NOP
15F12  FFE6     NOP
15F16  FF7B     NOP
15F18  FFE6     NOP
15F1A  EE21     LFSR 2, 0x747
15F1C  F347     NOP
15F20  FF7B     NOP
15F22  FFE6     NOP
15F26  FF7B     NOP
15F28  FFE6     NOP
15F2C  FF7B     NOP
15F2E  FFE6     NOP
15F32  FF7B     NOP
15F34  FFE6     NOP
15F36  ECC1     CALL 0x13D82, 0
15F38  F09E     NOP
15F3C  F007     NOP
15F3E  FFE6     NOP
15F42  F00B     NOP
15F44  FFE6     NOP
15F48  F00F     NOP
15F4A  FFE6     NOP
15F4E  F013     NOP
15F50  FFE6     NOP
15F52  EC3F     CALL 0x1867E, 0
15F54  F0C3     NOP
15F58  F004     NOP
15F5A  F77B     NOP
15F5E  F008     NOP
15F60  F77C     NOP
15F64  F00C     NOP
15F66  F77D     NOP
15F6A  F010     NOP
15F6C  F77E     NOP
87:            		C.p_inverter = lp_filter((C.c_load * C.v_inverter) - STATIC_LOAD_POWER, 19, true);
15F6E  0E01     MOVLW 0x1
15F70  6EE6     MOVWF 0xFE6, ACCESS
15F72  0E13     MOVLW 0x13
15F74  6EE6     MOVWF 0xFE6, ACCESS
15F76  0E00     MOVLW 0x0
15F78  6EE6     MOVWF 0xFE6, ACCESS
15F7A  0E00     MOVLW 0x0
15F7C  6EE6     MOVWF 0xFE6, ACCESS
15F7E  0E60     MOVLW 0x60
15F80  6EE6     MOVWF 0xFE6, ACCESS
15F82  0EC1     MOVLW 0xC1
15F84  6EE6     MOVWF 0xFE6, ACCESS
15F86  EE21     LFSR 2, 0x763
15F88  F363     NOP
15F8C  FF7B     NOP
15F8E  FFE6     NOP
15F92  FF7B     NOP
15F94  FFE6     NOP
15F98  FF7B     NOP
15F9A  FFE6     NOP
15F9E  FF7B     NOP
15FA0  FFE6     NOP
15FA2  EE21     LFSR 2, 0x73F
15FA4  F33F     NOP
15FA8  FF7B     NOP
15FAA  FFE6     NOP
15FAE  FF7B     NOP
15FB0  FFE6     NOP
15FB4  FF7B     NOP
15FB6  FFE6     NOP
15FBA  FF7B     NOP
15FBC  FFE6     NOP
15FBE  ECC1     CALL 0x13D82, 0
15FC0  F09E     NOP
15FC4  F007     NOP
15FC6  FFE6     NOP
15FCA  F00B     NOP
15FCC  FFE6     NOP
15FD0  F00F     NOP
15FD2  FFE6     NOP
15FD6  F013     NOP
15FD8  FFE6     NOP
15FDA  ECD6     CALL 0x145AC, 0
15FDC  F0A2     NOP
15FE0  F007     NOP
15FE2  FFE6     NOP
15FE6  F00B     NOP
15FE8  FFE6     NOP
15FEC  F00F     NOP
15FEE  FFE6     NOP
15FF2  F013     NOP
15FF4  FFE6     NOP
15FF6  EC3F     CALL 0x1867E, 0
15FF8  F0C3     NOP
15FFC  F004     NOP
15FFE  F777     NOP
16002  F008     NOP
16004  F778     NOP
16008  F00C     NOP
1600A  F779     NOP
1600E  F010     NOP
16010  F77A     NOP
88:            		C.p_bat = lp_filter(C.c_bat * C.v_bat, 20, true);
16012  0E01     MOVLW 0x1
16014  6EE6     MOVWF 0xFE6, ACCESS
16016  0E14     MOVLW 0x14
16018  6EE6     MOVWF 0xFE6, ACCESS
1601A  EE21     LFSR 2, 0x753
1601C  F353     NOP
16020  FF7B     NOP
16022  FFE6     NOP
16026  FF7B     NOP
16028  FFE6     NOP
1602C  FF7B     NOP
1602E  FFE6     NOP
16032  FF7B     NOP
16034  FFE6     NOP
16036  EE21     LFSR 2, 0x743
16038  F343     NOP
1603C  FF7B     NOP
1603E  FFE6     NOP
16042  FF7B     NOP
16044  FFE6     NOP
16048  FF7B     NOP
1604A  FFE6     NOP
1604E  FF7B     NOP
16050  FFE6     NOP
16052  ECC1     CALL 0x13D82, 0
16054  F09E     NOP
16058  F007     NOP
1605A  FFE6     NOP
1605E  F00B     NOP
16060  FFE6     NOP
16064  F00F     NOP
16066  FFE6     NOP
1606A  F013     NOP
1606C  FFE6     NOP
1606E  EC3F     CALL 0x1867E, 0
16070  F0C3     NOP
16074  F004     NOP
16076  F77F     NOP
1607A  F008     NOP
1607C  F780     NOP
16080  F00C     NOP
16082  F781     NOP
16086  F010     NOP
16088  F782     NOP
89:            		/*
90:            		 * calculation limits
91:            		 */
92:            		if (C.p_inverter < 0.0)
1608A  EE21     LFSR 2, 0x777
1608C  F377     NOP
1608E  0E03     MOVLW 0x3
16090  AEDB     BTFSS 0xFDB, 7, ACCESS
16092  D010     BRA 0x60B4
93:            			C.p_inverter = 0.0001;
16094  0E17     MOVLW 0x17
16098  FFA0     NOP
1609A  F777     NOP
1609C  0EB7     MOVLW 0xB7
160A0  FFA0     NOP
160A2  F778     NOP
160A4  0ED1     MOVLW 0xD1
160A8  FFA0     NOP
160AA  F779     NOP
160AC  0E38     MOVLW 0x38
160B0  FFA0     NOP
160B2  F77A     NOP
94:            	}
95:            	start_bsoc();
160B4  EC33     CALL 0x1BE66, 0
160B6  F0DF     NOP
96:            	C.update = true;
160B8  0E01     MOVLW 0x1
160BC  FFA0     NOP
160BE  F7B7     NOP
97:            }
160C0  0012     RETURN 0
98:            
99:            /*
100:            * find rate of change of battery voltage under load
101:            */
102:           void calc_ror_data(void)
103:           {
104:           	static float bvror = 0.0, bcror = 0.0; // must remember prior values
105:           
106:           	C.bc_ror = fabs(conv_raw_result(C_BATT, CONV) - bcror);
18B72  F21B     NOP
18B74  FFE6     NOP
18B78  F21F     NOP
18B7A  FFE6     NOP
18B7E  F223     NOP
18B80  FFE6     NOP
18B84  F227     NOP
18B86  FFE6     NOP
18B88  0E00     MOVLW 0x0
18B8A  6EE6     MOVWF 0xFE6, ACCESS
18B8C  0E00     MOVLW 0x0
18B8E  6EE6     MOVWF 0xFE6, ACCESS
18B90  EC71     CALL 0x152E2, 0
18B92  F0A9     NOP
18B96  F007     NOP
18B98  FFE6     NOP
18B9C  F00B     NOP
18B9E  FFE6     NOP
18BA2  F00F     NOP
18BA4  FFE6     NOP
18BA8  F013     NOP
18BAA  FFE6     NOP
18BAC  ECBF     CALL 0x1B57E, 0
18BAE  F0DA     NOP
18BB2  F007     NOP
18BB4  FFE6     NOP
18BB8  F00B     NOP
18BBA  FFE6     NOP
18BBE  F00F     NOP
18BC0  FFE6     NOP
18BC4  F013     NOP
18BC6  FFE6     NOP
18BC8  ECC6     CALL 0x1A58C, 0
18BCA  F0D2     NOP
18BCE  F004     NOP
18BD0  F76F     NOP
18BD4  F008     NOP
18BD6  F770     NOP
18BDA  F00C     NOP
18BDC  F771     NOP
18BE0  F010     NOP
18BE2  F772     NOP
107:           	bcror = conv_raw_result(C_BATT, CONV);
18BE4  0E00     MOVLW 0x0
18BE6  6EE6     MOVWF 0xFE6, ACCESS
18BE8  0E00     MOVLW 0x0
18BEA  6EE6     MOVWF 0xFE6, ACCESS
18BEC  EC71     CALL 0x152E2, 0
18BEE  F0A9     NOP
18BF2  F004     NOP
18BF4  F086     NOP
18BF8  F008     NOP
18BFA  F087     NOP
18BFE  F00C     NOP
18C00  F088     NOP
18C04  F010     NOP
18C06  F089     NOP
108:           	C.bv_ror = fabs(conv_raw_result(V_BAT, CONV) - bvror);
18C0A  F22B     NOP
18C0C  FFE6     NOP
18C10  F22F     NOP
18C12  FFE6     NOP
18C16  F233     NOP
18C18  FFE6     NOP
18C1C  F237     NOP
18C1E  FFE6     NOP
18C20  0E00     MOVLW 0x0
18C22  6EE6     MOVWF 0xFE6, ACCESS
18C24  0E04     MOVLW 0x4
18C26  6EE6     MOVWF 0xFE6, ACCESS
18C28  EC71     CALL 0x152E2, 0
18C2A  F0A9     NOP
18C2E  F007     NOP
18C30  FFE6     NOP
18C34  F00B     NOP
18C36  FFE6     NOP
18C3A  F00F     NOP
18C3C  FFE6     NOP
18C40  F013     NOP
18C42  FFE6     NOP
18C44  ECBF     CALL 0x1B57E, 0
18C46  F0DA     NOP
18C4A  F007     NOP
18C4C  FFE6     NOP
18C50  F00B     NOP
18C52  FFE6     NOP
18C56  F00F     NOP
18C58  FFE6     NOP
18C5C  F013     NOP
18C5E  FFE6     NOP
18C60  ECC6     CALL 0x1A58C, 0
18C62  F0D2     NOP
18C66  F004     NOP
18C68  F76B     NOP
18C6C  F008     NOP
18C6E  F76C     NOP
18C72  F00C     NOP
18C74  F76D     NOP
18C78  F010     NOP
18C7A  F76E     NOP
109:           	if (C.bv_ror < ROR_LIMIT_NOISE) // skip noise values
18C7C  0EE7     MOVLW 0xE7
18C7E  6EE6     MOVWF 0xFE6, ACCESS
18C80  0E1D     MOVLW 0x1D
18C82  6EE6     MOVWF 0xFE6, ACCESS
18C84  0EA7     MOVLW 0xA7
18C86  6EE6     MOVWF 0xFE6, ACCESS
18C88  0E3B     MOVLW 0x3B
18C8A  6EE6     MOVWF 0xFE6, ACCESS
18C8C  EE21     LFSR 2, 0x76B
18C8E  F36B     NOP
18C92  FF7B     NOP
18C94  FFE6     NOP
18C98  FF7B     NOP
18C9A  FFE6     NOP
18C9E  FF7B     NOP
18CA0  FFE6     NOP
18CA4  FF7B     NOP
18CA6  FFE6     NOP
18CA8  ECF4     CALL 0x18FE8, 0
18CAA  F0C7     NOP
18CAC  B001     BTFSC ltemp0, 0, ACCESS
18CAE  D010     BRA 0x8CD0
110:           		C.bv_ror = ROR_LIMIT_LOW + ROR_LIMIT_SET; // keep trying value
18CB0  0EB0     MOVLW 0xB0
18CB4  FFA0     NOP
18CB6  F76B     NOP
18CB8  0E03     MOVLW 0x3
18CBC  FFA0     NOP
18CBE  F76C     NOP
18CC0  0E67     MOVLW 0x67
18CC4  FFA0     NOP
18CC6  F76D     NOP
18CC8  0E3C     MOVLW 0x3C
18CCC  FFA0     NOP
18CCE  F76E     NOP
111:           	bvror = conv_raw_result(V_BAT, CONV);
18CD0  0E00     MOVLW 0x0
18CD2  6EE6     MOVWF 0xFE6, ACCESS
18CD4  0E04     MOVLW 0x4
18CD6  6EE6     MOVWF 0xFE6, ACCESS
18CD8  EC71     CALL 0x152E2, 0
18CDA  F0A9     NOP
18CDE  F004     NOP
18CE0  F08A     NOP
18CE4  F008     NOP
18CE6  F08B     NOP
18CEA  F00C     NOP
18CEC  F08C     NOP
18CF0  F010     NOP
18CF2  F08D     NOP
112:           }
18CF4  0012     RETURN 0
113:           
114:           /*
115:            * boot battery condition defaults
116:            */
117:           void static_soc(void)
118:           {
119:           	C.runtime = 120;
1B184  0E78     MOVLW 0x78
1B188  FFA0     NOP
1B18A  F7B3     NOP
1B18C  0E00     MOVLW 0x0
1B190  FFA0     NOP
1B192  F7B4     NOP
120:           	C.soc = 100;
1B194  0E64     MOVLW 0x64
1B198  FFA0     NOP
1B19A  F7B5     NOP
1B19C  0E00     MOVLW 0x0
1B1A0  FFA0     NOP
1B1A2  F7B6     NOP
121:           	C.dynamic_ah = C.bank_ah;
1B1A4  EE21     LFSR 2, 0x78B
1B1A6  F38B     NOP
1B1AA  FF78     NOP
1B1AC  F78F     NOP
1B1B0  FF78     NOP
1B1B2  F790     NOP
1B1B6  FF78     NOP
1B1B8  F791     NOP
1B1BC  FF74     NOP
1B1BE  F792     NOP
122:           	C.dynamic_ah_adj = C.dynamic_ah;
1B1C0  EE21     LFSR 2, 0x78F
1B1C2  F38F     NOP
1B1C6  FF78     NOP
1B1C8  F79B     NOP
1B1CC  FF78     NOP
1B1CE  F79C     NOP
1B1D2  FF78     NOP
1B1D4  F79D     NOP
1B1D8  FF74     NOP
1B1DA  F79E     NOP
123:           }
1B1DC  0012     RETURN 0
124:           
125:           void set_load_relay_one(const bool mode)
126:           {
127:           	RELAYL1_LAT = mode;
1C056  0EFF     MOVLW 0xFF
1C058  B0E3     BTFSC 0xFE3, 0, ACCESS
1C05A  D002     BRA 0xC060
1C05C  98BD     BCF 0xFBD, 4, ACCESS
1C05E  D001     BRA 0xC062
1C060  88BD     BSF 0xFBD, 4, ACCESS
128:           }
1C062  52E5     MOVF 0xFE5, F, ACCESS
1C064  0012     RETURN 0
129:           
130:           void set_load_relay_two(const bool mode)
131:           {
132:           	RELAYL2_LAT = mode;
1C046  0EFF     MOVLW 0xFF
1C048  B0E3     BTFSC 0xFE3, 0, ACCESS
1C04A  D002     BRA 0xC050
1C04C  9ABD     BCF 0xFBD, 5, ACCESS
1C04E  D001     BRA 0xC052
1C050  8ABD     BSF 0xFBD, 5, ACCESS
133:           }
1C052  52E5     MOVF 0xFE5, F, ACCESS
1C054  0012     RETURN 0
134:           
135:           void set_ac_charger_relay(const bool mode)
136:           {
137:           	AC_CHARGER_LAT = mode;
1C076  0EFF     MOVLW 0xFF
1C078  B0E3     BTFSC 0xFE3, 0, ACCESS
1C07A  D002     BRA 0xC080
1C07C  9CBD     BCF 0xFBD, 6, ACCESS
1C07E  D001     BRA 0xC082
1C080  8CBD     BSF 0xFBD, 6, ACCESS
138:           }
1C082  52E5     MOVF 0xFE5, F, ACCESS
1C084  0012     RETURN 0
139:           
140:           bool get_ac_charger_relay(void)
141:           {
142:           	return AC_CHARGER_LAT;
1C0B0  ACBD     BTFSS 0xFBD, 6, ACCESS
1C0B2  D003     BRA 0xC0BA
1C0B4  6A01     CLRF ltemp0, ACCESS
1C0B6  2A01     INCF ltemp0, F, ACCESS
1C0B8  0012     RETURN 0
1C0BA  6A01     CLRF ltemp0, ACCESS
143:           }
1C0BC  0012     RETURN 0
144:           
145:           /* Misc ACSII spinner character generator, stores position for each shape */
146:           char spinners(uint8_t shape, const uint8_t reset)
19FE6  52E6     MOVF 0xFE6, F, ACCESS
147:           {
148:           	static uint8_t s[MAX_SHAPES];
149:           	char c;
150:           
151:           	if (shape > (MAX_SHAPES - 1))
19FE8  0EFE     MOVLW 0xFE
19FEC  FF8C     NOP
19FEE  F001     NOP
19FF0  0E05     MOVLW 0x5
19FF2  6401     CPFSGT ltemp0, ACCESS
19FF4  D002     BRA 0x9FFA
152:           		shape = 0;
19FF6  0EFE     MOVLW 0xFE
19FF8  6AE3     CLRF 0xFE3, ACCESS
153:           	if (reset)
19FFA  0EFD     MOVLW 0xFD
19FFC  50E3     MOVF 0xFE3, W, ACCESS
19FFE  B4D8     BTFSC 0xFD8, 2, ACCESS
1A000  D00A     BRA 0xA016
154:           		s[shape] = 0;
1A002  0EFE     MOVLW 0xFE
1A006  FF8C     NOP
1A008  F00C     NOP
1A00A  500C     MOVF 0xC, W, ACCESS
1A00C  0F74     ADDLW 0x74
1A00E  6ED9     MOVWF 0xFD9, ACCESS
1A010  6ADA     CLRF 0xFDA, ACCESS
1A012  0E00     MOVLW 0x0
1A014  6EDF     MOVWF 0xFDF, ACCESS
155:           	c = spin[shape][s[shape]];
1A016  0EFE     MOVLW 0xFE
1A018  50E3     MOVF 0xFE3, W, ACCESS
1A01A  0D14     MULLW 0x14
1A01C  0E4B     MOVLW 0x4B
1A01E  6E0B     MOVWF wtemp5, ACCESS
1A020  0EFB     MOVLW 0xFB
1A022  6E0C     MOVWF 0xC, ACCESS
1A024  50F3     MOVF 0xFF3, W, ACCESS
1A026  260B     ADDWF wtemp5, F, ACCESS
1A028  50F4     MOVF 0xFF4, W, ACCESS
1A02A  220C     ADDWFC 0xC, F, ACCESS
1A02C  0EFE     MOVLW 0xFE
1A030  FF8C     NOP
1A032  F00A     NOP
1A034  500A     MOVF ttemp3, W, ACCESS
1A036  0F74     ADDLW 0x74
1A038  6ED9     MOVWF 0xFD9, ACCESS
1A03A  6ADA     CLRF 0xFDA, ACCESS
1A03C  50DF     MOVF 0xFDF, W, ACCESS
1A03E  260B     ADDWF wtemp5, F, ACCESS
1A040  0E00     MOVLW 0x0
1A042  220C     ADDWFC 0xC, F, ACCESS
1A046  F02F     NOP
1A048  FFF6     NOP
1A04C  F033     NOP
1A04E  FFF7     NOP
1A050  0E00     MOVLW 0x0
1A052  6EF8     MOVWF 0xFF8, ACCESS
1A054  0008     TBLRD*
1A056  0EFF     MOVLW 0xFF
1A05A  FFD7     NOP
1A05C  FFE3     NOP
156:           	if (++s[shape] >= strlen(spin[shape]))
1A05E  0EFE     MOVLW 0xFE
1A060  50E3     MOVF 0xFE3, W, ACCESS
1A062  0D14     MULLW 0x14
1A064  0E4B     MOVLW 0x4B
1A066  6E0B     MOVWF wtemp5, ACCESS
1A068  0EFB     MOVLW 0xFB
1A06A  6E0C     MOVWF 0xC, ACCESS
1A06C  50F3     MOVF 0xFF3, W, ACCESS
1A06E  260B     ADDWF wtemp5, F, ACCESS
1A070  50F4     MOVF 0xFF4, W, ACCESS
1A072  220C     ADDWFC 0xC, F, ACCESS
1A076  F02F     NOP
1A078  FFE6     NOP
1A07C  F033     NOP
1A07E  FFE6     NOP
1A080  EC6F     CALL 0x1A8DE, 0
1A082  F0D4     NOP
1A084  0EFE     MOVLW 0xFE
1A088  FF8C     NOP
1A08A  F00C     NOP
1A08C  500C     MOVF 0xC, W, ACCESS
1A08E  0F74     ADDLW 0x74
1A090  6ED9     MOVWF 0xFD9, ACCESS
1A092  6ADA     CLRF 0xFDA, ACCESS
1A094  2ADF     INCF 0xFDF, F, ACCESS
1A096  50DF     MOVF 0xFDF, W, ACCESS
1A098  6E0B     MOVWF wtemp5, ACCESS
1A09A  6A0C     CLRF 0xC, ACCESS
1A09C  5001     MOVF ltemp0, W, ACCESS
1A09E  5C0B     SUBWF wtemp5, W, ACCESS
1A0A0  5002     MOVF ttemp5, W, ACCESS
1A0A2  580C     SUBWFB 0xC, W, ACCESS
1A0A4  A0D8     BTFSS 0xFD8, 0, ACCESS
1A0A6  D00A     BRA 0xA0BC
157:           		s[shape] = 0;
1A0A8  0EFE     MOVLW 0xFE
1A0AC  FF8C     NOP
1A0AE  F00C     NOP
1A0B0  500C     MOVF 0xC, W, ACCESS
1A0B2  0F74     ADDLW 0x74
1A0B4  6ED9     MOVWF 0xFD9, ACCESS
1A0B6  6ADA     CLRF 0xFDA, ACCESS
1A0B8  0E00     MOVLW 0x0
1A0BA  6EDF     MOVWF 0xFDF, ACCESS
158:           	return c;
1A0BC  0EFF     MOVLW 0xFF
1A0C0  FF8C     NOP
1A0C2  F001     NOP
159:           }
1A0C4  52E5     MOVF 0xFE5, F, ACCESS
1A0C6  52E5     MOVF 0xFE5, F, ACCESS
1A0C8  52E5     MOVF 0xFE5, F, ACCESS
1A0CA  0012     RETURN 0
160:           
161:           /*
162:            * should be called every second in the time keeper task
163:            * returns true at dusk or dawn switch-over
164:            */
165:           bool check_day_time(void)
1883A  52E6     MOVF 0xFE6, F, ACCESS
1883C  52E6     MOVF 0xFE6, F, ACCESS
1883E  52E6     MOVF 0xFE6, F, ACCESS
18840  52E6     MOVF 0xFE6, F, ACCESS
166:           {
167:           	static uint8_t day_delay = 0;
168:           	float light;
169:           
170:           	light = conv_raw_result(V_LIGHT_SENSOR, CONV);
18842  0E00     MOVLW 0x0
18844  6EE6     MOVWF 0xFE6, ACCESS
18846  0E0D     MOVLW 0xD
18848  6EE6     MOVWF 0xFE6, ACCESS
1884A  EC71     CALL 0x152E2, 0
1884C  F0A9     NOP
1884E  0EFC     MOVLW 0xFC
18852  F007     NOP
18854  FFE3     NOP
18856  0EFD     MOVLW 0xFD
1885A  F00B     NOP
1885C  FFE3     NOP
1885E  0EFE     MOVLW 0xFE
18862  F00F     NOP
18864  FFE3     NOP
18866  0EFF     MOVLW 0xFF
1886A  F013     NOP
1886C  FFE3     NOP
171:           
172:           	if (!day_delay++ && V.system_stable) {
1886E  2A42     INCF day_delay, F, ACCESS
18870  0442     DECF day_delay, W, ACCESS
18872  A4D8     BTFSS 0xFD8, 2, ACCESS
18874  D0A9     BRA 0x89C8
18876  0101     MOVLB 0x1
18878  51DE     MOVF 0xDE, W, BANKED
1887A  B4D8     BTFSC 0xFD8, 2, ACCESS
1887C  D0A5     BRA 0x89C8
173:           		if (C.soc > SOC_CRITICAL) {
1887E  EE21     LFSR 2, 0x7B5
18880  F3B5     NOP
18882  0E01     MOVLW 0x1
18884  50DB     MOVF 0xFDB, W, ACCESS
18886  E104     BNZ 0x8890
18888  0E10     MOVLW 0x10
1888A  5CDE     SUBWF 0xFDE, W, ACCESS
1888C  A0D8     BTFSS 0xFD8, 0, ACCESS
1888E  D073     BRA 0x8976
174:           			if (!C.day) {
18890  EE22     LFSR 2, 0x821
18892  F021     NOP
18894  50DF     MOVF 0xFDF, W, ACCESS
18896  A4D8     BTFSS 0xFD8, 2, ACCESS
18898  D035     BRA 0x8904
175:           				if (light > DAWN_VOLTS) {
1889A  0EFC     MOVLW 0xFC
1889E  FF8F     NOP
188A0  FFE6     NOP
188A4  FF8F     NOP
188A6  FFE6     NOP
188AA  FF8F     NOP
188AC  FFE6     NOP
188B0  FF8F     NOP
188B2  FFE6     NOP
188B4  0E00     MOVLW 0x0
188B6  6EE6     MOVWF 0xFE6, ACCESS
188B8  0E00     MOVLW 0x0
188BA  6EE6     MOVWF 0xFE6, ACCESS
188BC  0EB0     MOVLW 0xB0
188BE  6EE6     MOVWF 0xFE6, ACCESS
188C0  0E41     MOVLW 0x41
188C2  6EE6     MOVWF 0xFE6, ACCESS
188C4  ECF4     CALL 0x18FE8, 0
188C6  F0C7     NOP
188C8  B001     BTFSC ltemp0, 0, ACCESS
188CA  D07E     BRA 0x89C8
176:           					C.day = true;
188CC  0E01     MOVLW 0x1
188D0  FFA0     NOP
188D2  F821     NOP
177:           					C.day_start = V.ticks;
188D4  EE20     LFSR 2, 0x1B1
188D6  F1B1     NOP
188DA  FF78     NOP
188DC  F822     NOP
188E0  FF78     NOP
188E2  F823     NOP
188E6  FF78     NOP
188E8  F824     NOP
188EC  FF74     NOP
188EE  F825     NOP
178:           					if (get_ac_charger_relay()) { // USE PV charging during the day
188F0  EC58     CALL 0x1C0B0, 0
188F2  F0E0     NOP
188F4  5001     MOVF ltemp0, W, ACCESS
188F6  B4D8     BTFSC 0xFD8, 2, ACCESS
188F8  D06B     BRA 0x89D0
179:           						set_ac_charger_relay(false);
188FA  0E00     MOVLW 0x0
188FC  6EE6     MOVWF 0xFE6, ACCESS
188FE  EC3B     CALL 0x1C076, 0
18900  F0E0     NOP
18902  D066     BRA 0x89D0
180:           					}
181:           					return true;
182:           				}
183:           			} else {
184:           				if (light < DUSK_VOLTS) {
18904  0E00     MOVLW 0x0
18906  6EE6     MOVWF 0xFE6, ACCESS
18908  0E00     MOVLW 0x0
1890A  6EE6     MOVWF 0xFE6, ACCESS
1890C  0E40     MOVLW 0x40
1890E  6EE6     MOVWF 0xFE6, ACCESS
18910  0E41     MOVLW 0x41
18912  6EE6     MOVWF 0xFE6, ACCESS
18914  0EF8     MOVLW 0xF8
18918  FF8F     NOP
1891A  FFE6     NOP
1891E  FF8F     NOP
18920  FFE6     NOP
18924  FF8F     NOP
18926  FFE6     NOP
1892A  FF8F     NOP
1892C  FFE6     NOP
1892E  ECF4     CALL 0x18FE8, 0
18930  F0C7     NOP
18932  B001     BTFSC ltemp0, 0, ACCESS
18934  D049     BRA 0x89C8
185:           					C.day = false;
18936  0E00     MOVLW 0x0
1893A  FFA0     NOP
1893C  F821     NOP
186:           					C.day_end = V.ticks;
1893E  EE20     LFSR 2, 0x1B1
18940  F1B1     NOP
18944  FF78     NOP
18946  F826     NOP
1894A  FF78     NOP
1894C  F827     NOP
18950  FF78     NOP
18952  F828     NOP
18956  FF74     NOP
18958  F829     NOP
187:           					/*
188:           					 * at low battery condition charge with AC at night
189:           					 */
190:           					if ((C.soc < SOC_TOO_LOW)) {
1895A  EE21     LFSR 2, 0x7B5
1895C  F3B5     NOP
1895E  0E01     MOVLW 0x1
18960  50DB     MOVF 0xFDB, W, ACCESS
18962  E136     BNZ 0x89D0
18964  0E28     MOVLW 0x28
18966  5CDE     SUBWF 0xFDE, W, ACCESS
18968  B0D8     BTFSC 0xFD8, 0, ACCESS
1896A  D032     BRA 0x89D0
191:           						set_ac_charger_relay(true);
1896C  0E01     MOVLW 0x1
1896E  6EE6     MOVWF 0xFE6, ACCESS
18970  EC3B     CALL 0x1C076, 0
18972  F0E0     NOP
18974  D02D     BRA 0x89D0
192:           					}
193:           					return true;
194:           				}
195:           			}
196:           		} else {
197:           			if (C.p_pv < C.p_inverter) { // see if PV can raise SOC
18976  EE21     LFSR 2, 0x777
18978  F377     NOP
1897C  FF7B     NOP
1897E  FFE6     NOP
18982  FF7B     NOP
18984  FFE6     NOP
18988  FF7B     NOP
1898A  FFE6     NOP
1898E  FF7B     NOP
18990  FFE6     NOP
18992  EE21     LFSR 2, 0x77B
18994  F37B     NOP
18998  FF7B     NOP
1899A  FFE6     NOP
1899E  FF7B     NOP
189A0  FFE6     NOP
189A4  FF7B     NOP
189A6  FFE6     NOP
189AA  FF7B     NOP
189AC  FFE6     NOP
189AE  ECF4     CALL 0x18FE8, 0
189B0  F0C7     NOP
189B2  B001     BTFSC ltemp0, 0, ACCESS
189B4  D009     BRA 0x89C8
198:           				if (!get_ac_charger_relay()) { // USE AC charger
189B6  EC58     CALL 0x1C0B0, 0
189B8  F0E0     NOP
189BA  5001     MOVF ltemp0, W, ACCESS
189BC  A4D8     BTFSS 0xFD8, 2, ACCESS
189BE  D004     BRA 0x89C8
199:           					set_ac_charger_relay(true);
189C0  0E01     MOVLW 0x1
189C2  6EE6     MOVWF 0xFE6, ACCESS
189C4  EC3B     CALL 0x1C076, 0
189C6  F0E0     NOP
200:           				}
201:           			}
202:           		}
203:           	}
204:           	if (day_delay >= DAY_DELAY)
189C8  0EEF     MOVLW 0xEF
189CA  6442     CPFSGT day_delay, ACCESS
189CC  D001     BRA 0x89D0
205:           		day_delay = 0;
189CE  6A42     CLRF day_delay, ACCESS
206:           	return false;
207:           }
189D0  52E5     MOVF 0xFE5, F, ACCESS
189D2  52E5     MOVF 0xFE5, F, ACCESS
189D4  52E5     MOVF 0xFE5, F, ACCESS
189D6  52E5     MOVF 0xFE5, F, ACCESS
189D8  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/main.c  --------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F57K42
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries.
23:            
24:                Subject to your compliance with these terms, you may use Microchip software and any
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party
26:                license terms applicable to your use of third party software (including open source software) that
27:                may accompany Microchip software.
28:            
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS
32:                FOR A PARTICULAR PURPOSE.
33:            
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE,
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS
41:                SOFTWARE.
42:             */
43:            
44:            /*
45:             *
46:             * This program controls and monitors solar power battery arrays on a 12vdc system
47:             * MBMC uses a simple expert machine to try and keep current the energy stored in a bank of batteries
48:             * The main physics functions are contained in the noload_soc, update_cef, ChargeBatt and pick_batt functions
49:             * Much more work is needed to make the program flow logical but making it work first is the current effort
50:             * The network interface processor on a pic32 will be able to analyze the collected data for better control at some future point
51:             *
52:             * standard program display units:
53:             * Voltage  in millivolts,
54:             * Current in milliamps
55:             * Watts Power in milliwatts
56:             * Ah battery capacity milliAh
57:             *
58:             * R: structure, real values from measurements
59:             * C: structure, calculated values from measurements or programs
60:             * B: structure, battery parameters
61:             *
62:             * USART2 		Is the client comm port 38400
63:             * USART1		MBMC logger channel
64:             * timer 2 100 us PWM clock, no interrupt
65:             * timer 3 one second housekeeping clock for battery state tracking, low priority interrupt
66:             * timer 5 one second timer, interrupt
67:             * timer 6 500 us software timer ticker, interrupt
68:             *
69:             * dma1 spi transmit
70:             * dma2 tx1 transmit
71:             *
72:             * 10 analog channels are active
73:             * PORTA,PORTB		analog inputs
74:             * ana0	battery current					200A hall sensor battery output to inverter 5v R1
75:             * ana1	PV input current				100A hall sensor input from PV array 5v R2
76:             * ana2	charge controller output voltage		R3
77:             * ana3  PLUS VREF					Using a external 4.095 volt reference IC from TI/BB
78:             * ana4	battery voltage					Voltage a primary inverter battery R4
79:             * ana5	pv voltage					R5
80:             * ana6 controller buss voltage				R6
81:             * anb2 backup battery voltage				R7
82:             * anb3 thermo_batt					thermistor input 10K at 25C 5v R8
83:             * anb4 inverter voltage				R9
84:             * anb5 spare						R10
85:             *
86:             * switch MAX debounce inputs INP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
87:             * max pin	pic pin		connector pin	name	MBMC_IO board input connector pin
88:             * 1		rf0		spi 9			10
89:             * 2		rf1		spi 10			1
90:             * 3		rf2		PD 9		SELECT	2
91:             * 4		rf3		PD 8		ENTER	3
92:             * 5		rd3		PD 3			4
93:             * 6		rd2		PD 2/misc 2	SW0	5
94:             * 7				misc 3			6
95:             * 8				misc 4			7
96:             *
97:             * adc_cal[0-3]						current sensors zero offset stored in eeprom 0=a100, 1=a200, 2..3=future
98:             * 3x16 LCD status panel and led status lights.
99:             *
100:            * uln2802 port output pins OUTP
101:            * i/o  port	function
102:            * 0	RD4	load relay 1
103:            * 1	RD5	load relay 2
104:            * 2	RD6	PV/AC Charger DC charge-controller source relay
105:            * 4	RF4	spare
106:            * 
107:            * system variables float
108:            *
109:            * current_in
110:            * current_battery
111:            * current_load
112:            *
113:            * voltage_pv
114:            * voltage_cc
115:            * voltage_battery
116:            * voltage_load
117:            * voltage_buss
118:            * voltage_thermo
119:            * voltage_backup
120:            */
121:           
122:           #pragma warning disable 520
123:           #pragma warning disable 1498
124:           
125:           #ifndef __DEFINED_int24_t
126:           typedef signed long long int24_t;
127:           #define __DEFINED_int24_t
128:           #endif
129:           
130:           #include <stdio.h>
131:           #include <string.h>
132:           #include "mcc_generated_files/mcc.h"
133:           #include "mcc_generated_files/uart1.h"
134:           #include "eadog.h"
135:           #include "timers.h"
136:           #include "mconfig.h"
137:           #include "mydisplay.h"
138:           #include "daq.h"
139:           #include "mbmc.h"
140:           #include "dio.h"
141:           #include "hid.h"
142:           #include "bsoc.h"
143:           
144:           V_data V = {
145:           	.ticker = 45,
146:           	.checksum_error = 0,
147:           	.all_errors = 0,
148:           	.debug = false,
149:           	.stack = false, // 0 no messages, 1-10 messages in queue
150:           	.help_id = 0,
151:           	.sequences = 0,
152:           	.set_sequ = false,
153:           	.highint_count = 0,
154:           	.lowint_count = 0,
155:           	.timerint_count = 0,
156:           	.calib = CALIB,
157:           	.screen = 0,
158:           	.system_stable = false,
159:           };
160:           H_data H = {
161:           	.hid_display = HID_MAIN,
162:           	.h_state = H_STATE_INIT,
163:           	.wait_enter = true,
164:           	.wait_select = true,
165:           	.sequence = 0,
166:           };
167:           
168:           /*
169:            * FIXME STUFF
170:            */
171:           
172:           volatile uint16_t tickCount[TMR_COUNT] = {0};
173:           volatile uint8_t mode_sw = false;
174:           volatile C_data C = {
175:           	.bank_ah = BANKAH - DEGRADE,
176:           	.day = true,
177:           	.hist[0].version = HVER,
178:           	.hist[0].cef = CEF,
179:           	.hist[0].peukert = PEUKERT,
180:           };
181:           
182:           extern volatile struct P_data P;
183:           
184:           /*
185:            * Main application
186:            */
187:           void main(void)
11244  0E11     MOVLW 0x11
11246  26E1     ADDWF 0xFE1, F, ACCESS
11248  0E00     MOVLW 0x0
1124A  22E2     ADDWFC 0xFE2, F, ACCESS
188:           {
189:           	UI_STATES mode; /* link configuration host/equipment/etc ... */
190:           	uint8_t inp_index = 0, i = C_BATT, j = C_PV, k = V_CC, i_ror;
1124C  0EFA     MOVLW 0xFA
1124E  6AE3     CLRF 0xFE3, ACCESS
11250  0EFD     MOVLW 0xFD
11252  6AE3     CLRF 0xFE3, ACCESS
11254  0EFC     MOVLW 0xFC
11256  6AE3     CLRF 0xFE3, ACCESS
11258  2AE3     INCF 0xFE3, F, ACCESS
1125A  0EFB     MOVLW 0xFB
1125C  6AE3     CLRF 0xFE3, ACCESS
1125E  82E3     BSF 0xFE3, 1, ACCESS
191:           
192:           	// Initialize the device
193:           	SYSTEM_Initialize();
11260  ECE7     CALL 0x1B3CE, 0
11262  F0D9     NOP
194:           
195:           	// Enable high priority global interrupts
196:           	INTERRUPT_GlobalInterruptHighEnable();
11264  8ED2     BSF 0xFD2, 7, ACCESS
197:           
198:           	// Enable low priority global interrupts.
199:           	INTERRUPT_GlobalInterruptLowEnable();
11266  8CD2     BSF 0xFD2, 6, ACCESS
200:           
201:           	V.ui_state = UI_STATE_INIT;
11268  0101     MOVLB 0x1
1126A  6B30     CLRF 0x30, BANKED
202:           
203:           	/*
204:           	 * RS-232 link I/O relay defaults to monitor/log mode with no power
205:           	 */
206:           	WaitMs(300); // wait for mode switch to settle
1126C  0E2C     MOVLW 0x2C
1126E  6EE6     MOVWF 0xFE6, ACCESS
11270  0E01     MOVLW 0x1
11272  6EE6     MOVWF 0xFE6, ACCESS
11274  EC5A     CALL 0x1B8B4, 0
11276  F0DC     NOP
207:           	if (RB0_GetValue()) {
11278  A0CB     BTFSS 0xFCB, 0, ACCESS
1127A  D004     BRA 0x1284
208:           		mode = UI_STATE_HOST;
1127C  0EFE     MOVLW 0xFE
1127E  6AE3     CLRF 0xFE3, ACCESS
11280  2AE3     INCF 0xFE3, F, ACCESS
209:           	} else {
11282  D004     BRA 0x128C
210:           		mode = UI_STATE_LOG;
11284  0EFE     MOVLW 0xFE
11286  6AE3     CLRF 0xFE3, ACCESS
11288  80E3     BSF 0xFE3, 0, ACCESS
1128A  82E3     BSF 0xFE3, 1, ACCESS
211:           	}
212:           
213:           	if (mode == UI_STATE_HOST) {
1128C  0EFE     MOVLW 0xFE
1128E  04E3     DECF 0xFE3, W, ACCESS
11290  A4D8     BTFSS 0xFD8, 2, ACCESS
11292  D007     BRA 0x12A2
214:           		RELAY0_SetHigh();
11294  80BD     BSF 0xFBD, 0, ACCESS
215:           		V.mode_pwm = 70; // mode switch indicator lamp normal level
11296  0E00     MOVLW 0x0
11298  0101     MOVLB 0x1
1129A  6FC6     MOVWF CountCallBack, BANKED
1129C  0E46     MOVLW 0x46
1129E  6FC5     MOVWF 0xC5, BANKED
216:           	} else {
112A0  D004     BRA 0x12AA
217:           		RELAY0_SetLow();
112A2  90BD     BCF 0xFBD, 0, ACCESS
218:           		V.mode_pwm = 0;
112A4  0101     MOVLB 0x1
112A6  6BC5     CLRF 0xC5, BANKED
112A8  6BC6     CLRF CountCallBack, BANKED
219:           	}
220:           	mode_lamp_dim(V.mode_pwm); // 10KHz PWM
112AC  F717     NOP
112AE  FFE6     NOP
112B2  F71B     NOP
112B4  FFE6     NOP
112B6  ECD7     CALL 0x1BFAE, 0
112B8  F0DF     NOP
112BA  D326     BRA 0x1908
221:           
222:           	while (true) {
223:           		switch (V.ui_state) {
224:           		case UI_STATE_INIT:
225:           			/*
226:           			 * DMA serial uart1 I/O testing
227:           			 */
228:           			init_port_dma();
112BC  ECA9     CALL 0x1B952, 0
112BE  F0DC     NOP
229:           
230:           			init_display();
112C0  EC7E     CALL 0x19EFC, 0
112C2  F0CF     NOP
231:           			eaDogM_CursorOff();
112C4  0E0C     MOVLW 0xC
112C6  6EE6     MOVWF 0xFE6, ACCESS
112C8  EC4A     CALL 0x1C094, 0
112CA  F0E0     NOP
232:           			/*
233:           			 * load the battery to reduce surface charge
234:           			 */
235:           			set_load_relay_one(true);
112CC  0E01     MOVLW 0x1
112CE  6EE6     MOVWF 0xFE6, ACCESS
112D0  EC2B     CALL 0x1C056, 0
112D2  F0E0     NOP
236:           			set_load_relay_two(true);
112D4  0E01     MOVLW 0x1
112D6  6EE6     MOVWF 0xFE6, ACCESS
112D8  EC23     CALL 0x1C046, 0
112DA  F0E0     NOP
237:           
238:           			V.ui_state = mode;
112DC  0EFE     MOVLW 0xFE
112E0  FF8C     NOP
112E2  F130     NOP
239:           			srand(1957);
112E4  0EA5     MOVLW 0xA5
112E6  6EE6     MOVWF 0xFE6, ACCESS
112E8  0E07     MOVLW 0x7
112EA  6EE6     MOVWF 0xFE6, ACCESS
112EC  EC75     CALL 0x1B8EA, 0
112EE  F0DC     NOP
240:           			set_vterm(0); // set to buffer 0
112F0  0E00     MOVLW 0x0
112F2  6EE6     MOVWF 0xFE6, ACCESS
112F4  EC82     CALL 0x1BF04, 0
112F6  F0DF     NOP
241:           			sprintf(get_vterm_ptr(0, 0), " MBMC SOLARMON      ");
112F8  0E1E     MOVLW 0x1E
112FA  6EE6     MOVWF 0xFE6, ACCESS
112FC  0EFF     MOVLW 0xFF
112FE  6EE6     MOVWF 0xFE6, ACCESS
11300  0E00     MOVLW 0x0
11302  6EE6     MOVWF 0xFE6, ACCESS
11304  0E00     MOVLW 0x0
11306  6EE6     MOVWF 0xFE6, ACCESS
11308  EC09     CALL 0x1BA12, 0
1130A  F0DD     NOP
1130E  F007     NOP
11310  FFE6     NOP
11314  F00B     NOP
11316  FFE6     NOP
11318  0E04     MOVLW 0x4
1131A  6EE6     MOVWF 0xFE6, ACCESS
1131C  EC00     CALL 0x19C00, 0
1131E  F0CE     NOP
242:           			sprintf(get_vterm_ptr(1, 0), " Version %s         ", VER);
11320  0ED2     MOVLW 0xD2
11322  6EE6     MOVWF 0xFE6, ACCESS
11324  0EFF     MOVLW 0xFF
11326  6EE6     MOVWF 0xFE6, ACCESS
11328  0E09     MOVLW 0x9
1132A  6EE6     MOVWF 0xFE6, ACCESS
1132C  0EFF     MOVLW 0xFF
1132E  6EE6     MOVWF 0xFE6, ACCESS
11330  0E00     MOVLW 0x0
11332  6EE6     MOVWF 0xFE6, ACCESS
11334  0E01     MOVLW 0x1
11336  6EE6     MOVWF 0xFE6, ACCESS
11338  EC09     CALL 0x1BA12, 0
1133A  F0DD     NOP
1133E  F007     NOP
11340  FFE6     NOP
11344  F00B     NOP
11346  FFE6     NOP
11348  0E06     MOVLW 0x6
1134A  6EE6     MOVWF 0xFE6, ACCESS
1134C  EC00     CALL 0x19C00, 0
1134E  F0CE     NOP
243:           			sprintf(get_vterm_ptr(2, 0), " NSASPOOK           ");
11350  0ECA     MOVLW 0xCA
11352  6EE6     MOVWF 0xFE6, ACCESS
11354  0EFE     MOVLW 0xFE
11356  6EE6     MOVWF 0xFE6, ACCESS
11358  0E00     MOVLW 0x0
1135A  6EE6     MOVWF 0xFE6, ACCESS
1135C  0E02     MOVLW 0x2
1135E  6EE6     MOVWF 0xFE6, ACCESS
11360  EC09     CALL 0x1BA12, 0
11362  F0DD     NOP
11366  F007     NOP
11368  FFE6     NOP
1136C  F00B     NOP
1136E  FFE6     NOP
11370  0E04     MOVLW 0x4
11372  6EE6     MOVWF 0xFE6, ACCESS
11374  EC00     CALL 0x19C00, 0
11376  F0CE     NOP
244:           			sprintf(get_vterm_ptr(0, 2), "                    ");
11378  0EA0     MOVLW 0xA0
1137A  6EE6     MOVWF 0xFE6, ACCESS
1137C  0EFE     MOVLW 0xFE
1137E  6EE6     MOVWF 0xFE6, ACCESS
11380  0E02     MOVLW 0x2
11382  6EE6     MOVWF 0xFE6, ACCESS
11384  0E00     MOVLW 0x0
11386  6EE6     MOVWF 0xFE6, ACCESS
11388  EC09     CALL 0x1BA12, 0
1138A  F0DD     NOP
1138E  F007     NOP
11390  FFE6     NOP
11394  F00B     NOP
11396  FFE6     NOP
11398  0E04     MOVLW 0x4
1139A  6EE6     MOVWF 0xFE6, ACCESS
1139C  EC00     CALL 0x19C00, 0
1139E  F0CE     NOP
245:           			sprintf(get_vterm_ptr(1, 2), "                    ");
113A0  0EA0     MOVLW 0xA0
113A2  6EE6     MOVWF 0xFE6, ACCESS
113A4  0EFE     MOVLW 0xFE
113A6  6EE6     MOVWF 0xFE6, ACCESS
113A8  0E02     MOVLW 0x2
113AA  6EE6     MOVWF 0xFE6, ACCESS
113AC  0E01     MOVLW 0x1
113AE  6EE6     MOVWF 0xFE6, ACCESS
113B0  EC09     CALL 0x1BA12, 0
113B2  F0DD     NOP
113B6  F007     NOP
113B8  FFE6     NOP
113BC  F00B     NOP
113BE  FFE6     NOP
113C0  0E04     MOVLW 0x4
113C2  6EE6     MOVWF 0xFE6, ACCESS
113C4  EC00     CALL 0x19C00, 0
113C6  F0CE     NOP
246:           			sprintf(get_vterm_ptr(2, 2), "                    ");
113C8  0EA0     MOVLW 0xA0
113CA  6EE6     MOVWF 0xFE6, ACCESS
113CC  0EFE     MOVLW 0xFE
113CE  6EE6     MOVWF 0xFE6, ACCESS
113D0  0E02     MOVLW 0x2
113D2  6EE6     MOVWF 0xFE6, ACCESS
113D4  0E02     MOVLW 0x2
113D6  6EE6     MOVWF 0xFE6, ACCESS
113D8  EC09     CALL 0x1BA12, 0
113DA  F0DD     NOP
113DE  F007     NOP
113E0  FFE6     NOP
113E4  F00B     NOP
113E6  FFE6     NOP
113E8  0E04     MOVLW 0x4
113EA  6EE6     MOVWF 0xFE6, ACCESS
113EC  EC00     CALL 0x19C00, 0
113EE  F0CE     NOP
247:           			update_lcd(0);
113F0  0E00     MOVLW 0x0
113F2  6EE6     MOVWF 0xFE6, ACCESS
113F4  EC78     CALL 0x19AF0, 0
113F6  F0CD     NOP
248:           			WaitMs(1000);
113F8  0EE8     MOVLW 0xE8
113FA  6EE6     MOVWF 0xFE6, ACCESS
113FC  0E03     MOVLW 0x3
113FE  6EE6     MOVWF 0xFE6, ACCESS
11400  EC5A     CALL 0x1B8B4, 0
11402  F0DC     NOP
249:           			StartTimer(TMR_DISPLAY, DDELAY);
11404  0EFA     MOVLW 0xFA
11406  6EE6     MOVWF 0xFE6, ACCESS
11408  0E00     MOVLW 0x0
1140A  6EE6     MOVWF 0xFE6, ACCESS
1140C  0E0A     MOVLW 0xA
1140E  6EE6     MOVWF 0xFE6, ACCESS
11410  EC65     CALL 0x1B6CA, 0
11412  F0DB     NOP
250:           			StartTimer(TMR_ADC, ADC_SCAN_SPEED);
11414  0EC8     MOVLW 0xC8
11416  6EE6     MOVWF 0xFE6, ACCESS
11418  0E00     MOVLW 0x0
1141A  6EE6     MOVWF 0xFE6, ACCESS
1141C  0E01     MOVLW 0x1
1141E  6EE6     MOVWF 0xFE6, ACCESS
11420  EC65     CALL 0x1B6CA, 0
11422  F0DB     NOP
251:           			StartTimer(TMR_INFO, TDELAY);
11424  0EB8     MOVLW 0xB8
11426  6EE6     MOVWF 0xFE6, ACCESS
11428  0E0B     MOVLW 0xB
1142A  6EE6     MOVWF 0xFE6, ACCESS
1142C  0E07     MOVLW 0x7
1142E  6EE6     MOVWF 0xFE6, ACCESS
11430  EC65     CALL 0x1B6CA, 0
11432  F0DB     NOP
252:           			StartTimer(TMR_FLIPPER, DFLIP);
11434  0EDC     MOVLW 0xDC
11436  6EE6     MOVWF 0xFE6, ACCESS
11438  0E05     MOVLW 0x5
1143A  6EE6     MOVWF 0xFE6, ACCESS
1143C  0E0B     MOVLW 0xB
1143E  6EE6     MOVWF 0xFE6, ACCESS
11440  EC65     CALL 0x1B6CA, 0
11442  F0DB     NOP
253:           			StartTimer(TMR_HELPDIS, TDELAY);
11444  0EB8     MOVLW 0xB8
11446  6EE6     MOVWF 0xFE6, ACCESS
11448  0E0B     MOVLW 0xB
1144A  6EE6     MOVWF 0xFE6, ACCESS
1144C  0E09     MOVLW 0x9
1144E  6EE6     MOVWF 0xFE6, ACCESS
11450  EC65     CALL 0x1B6CA, 0
11452  F0DB     NOP
254:           
255:           			start_adc_scan();
11454  ECFE     CALL 0x1AFFC, 0
11456  F0D7     NOP
256:           			start_switch_handler();
11458  EC44     CALL 0x1BE88, 0
1145A  F0DF     NOP
257:           			WaitMs(1000);
1145C  0EE8     MOVLW 0xE8
1145E  6EE6     MOVWF 0xFE6, ACCESS
11460  0E03     MOVLW 0x3
11462  6EE6     MOVWF 0xFE6, ACCESS
11464  EC5A     CALL 0x1B8B4, 0
11466  F0DC     NOP
258:           			/*
259:           			 * check for quickly changing battery voltage
260:           			 * to stabilize as to get a better static SOC value
261:           			 */
262:           			i_ror = 1;
11468  0EFF     MOVLW 0xFF
1146A  6AE3     CLRF 0xFE3, ACCESS
1146C  2AE3     INCF 0xFE3, F, ACCESS
263:           			do {
264:           				calc_ror_data();
1146E  ECB8     CALL 0x18B70, 0
11470  F0C5     NOP
265:           				sprintf(get_vterm_ptr(1, 0), "BV %2.4f            ", conv_raw_result(V_BAT, CONV));
11472  0E00     MOVLW 0x0
11474  6EE6     MOVWF 0xFE6, ACCESS
11476  0E04     MOVLW 0x4
11478  6EE6     MOVWF 0xFE6, ACCESS
1147A  EC71     CALL 0x152E2, 0
1147C  F0A9     NOP
11480  F007     NOP
11482  FFE6     NOP
11486  F00B     NOP
11488  FFE6     NOP
1148C  F00F     NOP
1148E  FFE6     NOP
11492  F013     NOP
11494  FFE6     NOP
11496  0EB5     MOVLW 0xB5
11498  6EE6     MOVWF 0xFE6, ACCESS
1149A  0EFE     MOVLW 0xFE
1149C  6EE6     MOVWF 0xFE6, ACCESS
1149E  0E00     MOVLW 0x0
114A0  6EE6     MOVWF 0xFE6, ACCESS
114A2  0E01     MOVLW 0x1
114A4  6EE6     MOVWF 0xFE6, ACCESS
114A6  EC09     CALL 0x1BA12, 0
114A8  F0DD     NOP
114AC  F007     NOP
114AE  FFE6     NOP
114B2  F00B     NOP
114B4  FFE6     NOP
114B6  0E08     MOVLW 0x8
114B8  6EE6     MOVWF 0xFE6, ACCESS
114BA  EC00     CALL 0x19C00, 0
114BC  F0CE     NOP
266:           				sprintf(get_vterm_ptr(2, 0), "S S%cC %d %2.4f          ", spinners(5, false), i_ror, C.bv_ror);
114BE  EE21     LFSR 2, 0x76B
114C0  F36B     NOP
114C4  FF7B     NOP
114C6  FFE6     NOP
114CA  FF7B     NOP
114CC  FFE6     NOP
114D0  FF7B     NOP
114D2  FFE6     NOP
114D6  FF7B     NOP
114D8  FFE6     NOP
114DA  0EFB     MOVLW 0xFB
114DC  50E3     MOVF 0xFE3, W, ACCESS
114DE  6EE6     MOVWF 0xFE6, ACCESS
114E0  0E00     MOVLW 0x0
114E2  6EE6     MOVWF 0xFE6, ACCESS
114E4  0E00     MOVLW 0x0
114E6  6EE6     MOVWF 0xFE6, ACCESS
114E8  0E05     MOVLW 0x5
114EA  6EE6     MOVWF 0xFE6, ACCESS
114EC  ECF3     CALL 0x19FE6, 0
114EE  F0CF     NOP
114F0  5001     MOVF ltemp0, W, ACCESS
114F2  6EE6     MOVWF 0xFE6, ACCESS
114F4  0E00     MOVLW 0x0
114F6  6EE6     MOVWF 0xFE6, ACCESS
114F8  0E84     MOVLW 0x84
114FA  6EE6     MOVWF 0xFE6, ACCESS
114FC  0EFC     MOVLW 0xFC
114FE  6EE6     MOVWF 0xFE6, ACCESS
11500  0E00     MOVLW 0x0
11502  6EE6     MOVWF 0xFE6, ACCESS
11504  0E02     MOVLW 0x2
11506  6EE6     MOVWF 0xFE6, ACCESS
11508  EC09     CALL 0x1BA12, 0
1150A  F0DD     NOP
1150E  F007     NOP
11510  FFE6     NOP
11514  F00B     NOP
11516  FFE6     NOP
11518  0E0C     MOVLW 0xC
1151A  6EE6     MOVWF 0xFE6, ACCESS
1151C  EC00     CALL 0x19C00, 0
1151E  F0CE     NOP
267:           				update_lcd(0);
11520  0E00     MOVLW 0x0
11522  6EE6     MOVWF 0xFE6, ACCESS
11524  EC78     CALL 0x19AF0, 0
11526  F0CD     NOP
268:           				clear_adc_scan();
11528  EC9F     CALL 0x1C13E, 0
1152A  F0E0     NOP
269:           				start_adc_scan();
1152C  ECFE     CALL 0x1AFFC, 0
1152E  F0D7     NOP
270:           				WaitMs(ROR_WAIT); // time between samples
11530  0ED0     MOVLW 0xD0
11532  6EE6     MOVWF 0xFE6, ACCESS
11534  0E07     MOVLW 0x7
11536  6EE6     MOVWF 0xFE6, ACCESS
11538  EC5A     CALL 0x1B8B4, 0
1153A  F0DC     NOP
271:           
272:           				//WaitMs(500); // wait for updated ADC data
273:           			} while ((i_ror++ < ROR_TIMES) && (C.bv_ror > ROR_LIMIT_LOW));
1153C  0EFF     MOVLW 0xFF
11540  FF8C     NOP
11542  F00C     NOP
11544  2A0C     INCF 0xC, F, ACCESS
11548  F033     NOP
1154A  FFE3     NOP
1154C  060C     DECF 0xC, F, ACCESS
1154E  0E1E     MOVLW 0x1E
11550  600C     CPFSLT 0xC, ACCESS
11552  D01A     BRA 0x1588
11554  EE21     LFSR 2, 0x76B
11556  F36B     NOP
1155A  FF7B     NOP
1155C  FFE6     NOP
11560  FF7B     NOP
11562  FFE6     NOP
11566  FF7B     NOP
11568  FFE6     NOP
1156C  FF7B     NOP
1156E  FFE6     NOP
11570  0E42     MOVLW 0x42
11572  6EE6     MOVWF 0xFE6, ACCESS
11574  0E60     MOVLW 0x60
11576  6EE6     MOVWF 0xFE6, ACCESS
11578  0E65     MOVLW 0x65
1157A  6EE6     MOVWF 0xFE6, ACCESS
1157C  0E3C     MOVLW 0x3C
1157E  6EE6     MOVWF 0xFE6, ACCESS
11580  ECF4     CALL 0x18FE8, 0
11582  F0C7     NOP
11584  A001     BTFSS ltemp0, 0, ACCESS
11586  D773     BRA 0x146E
274:           
275:           			static_soc(); // defaults
11588  ECC2     CALL 0x1B184, 0
1158A  F0D8     NOP
276:           			init_bsoc(); // system calculations
1158C  ECE1     CALL 0x17BC2, 0
1158E  F0BD     NOP
277:           			set_load_relay_one(false);
11590  0E00     MOVLW 0x0
11592  6EE6     MOVWF 0xFE6, ACCESS
11594  EC2B     CALL 0x1C056, 0
11596  F0E0     NOP
278:           			set_load_relay_two(false);
11598  0E00     MOVLW 0x0
1159A  6EE6     MOVWF 0xFE6, ACCESS
1159C  EC23     CALL 0x1C046, 0
1159E  F0E0     NOP
279:           			sprintf(get_vterm_ptr(0, 0), "Static SOC %d        ", C.soc);
115A0  EE21     LFSR 2, 0x7B5
115A2  F3B5     NOP
115A6  FF78     NOP
115A8  F00B     NOP
115AC  FF74     NOP
115AE  F00C     NOP
115B2  F02F     NOP
115B4  FFE6     NOP
115B8  F033     NOP
115BA  FFE6     NOP
115BC  0E56     MOVLW 0x56
115BE  6EE6     MOVWF 0xFE6, ACCESS
115C0  0EFD     MOVLW 0xFD
115C2  6EE6     MOVWF 0xFE6, ACCESS
115C4  0E00     MOVLW 0x0
115C6  6EE6     MOVWF 0xFE6, ACCESS
115C8  0E00     MOVLW 0x0
115CA  6EE6     MOVWF 0xFE6, ACCESS
115CC  EC09     CALL 0x1BA12, 0
115CE  F0DD     NOP
115D2  F007     NOP
115D4  FFE6     NOP
115D8  F00B     NOP
115DA  FFE6     NOP
115DC  0E06     MOVLW 0x6
115DE  6EE6     MOVWF 0xFE6, ACCESS
115E0  EC00     CALL 0x19C00, 0
115E2  F0CE     NOP
280:           			sprintf(get_vterm_ptr(1, 0), "Battery Ah %3.2f     ", C.dynamic_ah);
115E4  EE21     LFSR 2, 0x78F
115E6  F38F     NOP
115EA  FF7B     NOP
115EC  FFE6     NOP
115F0  FF7B     NOP
115F2  FFE6     NOP
115F6  FF7B     NOP
115F8  FFE6     NOP
115FC  FF7B     NOP
115FE  FFE6     NOP
11600  0E32     MOVLW 0x32
11602  6EE6     MOVWF 0xFE6, ACCESS
11604  0EFE     MOVLW 0xFE
11606  6EE6     MOVWF 0xFE6, ACCESS
11608  0E00     MOVLW 0x0
1160A  6EE6     MOVWF 0xFE6, ACCESS
1160C  0E01     MOVLW 0x1
1160E  6EE6     MOVWF 0xFE6, ACCESS
11610  EC09     CALL 0x1BA12, 0
11612  F0DD     NOP
11616  F007     NOP
11618  FFE6     NOP
1161C  F00B     NOP
1161E  FFE6     NOP
11620  0E08     MOVLW 0x8
11622  6EE6     MOVWF 0xFE6, ACCESS
11624  EC00     CALL 0x19C00, 0
11626  F0CE     NOP
281:           			update_lcd(0);
11628  0E00     MOVLW 0x0
1162A  6EE6     MOVWF 0xFE6, ACCESS
1162C  EC78     CALL 0x19AF0, 0
1162E  F0CD     NOP
282:           			WaitMs(2000);
11630  0ED0     MOVLW 0xD0
11632  6EE6     MOVWF 0xFE6, ACCESS
11634  0E07     MOVLW 0x7
11636  6EE6     MOVWF 0xFE6, ACCESS
11638  EC5A     CALL 0x1B8B4, 0
1163A  F0DC     NOP
283:           			sprintf(get_vterm_ptr(0, 0), "Battery ESR         ");
1163C  0EDF     MOVLW 0xDF
1163E  6EE6     MOVWF 0xFE6, ACCESS
11640  0EFE     MOVLW 0xFE
11642  6EE6     MOVWF 0xFE6, ACCESS
11644  0E00     MOVLW 0x0
11646  6EE6     MOVWF 0xFE6, ACCESS
11648  0E00     MOVLW 0x0
1164A  6EE6     MOVWF 0xFE6, ACCESS
1164C  EC09     CALL 0x1BA12, 0
1164E  F0DD     NOP
11652  F007     NOP
11654  FFE6     NOP
11658  F00B     NOP
1165A  FFE6     NOP
1165C  0E04     MOVLW 0x4
1165E  6EE6     MOVWF 0xFE6, ACCESS
11660  EC00     CALL 0x19C00, 0
11662  F0CE     NOP
284:           			sprintf(get_vterm_ptr(1, 0), "Calculation         ");
11664  0EF4     MOVLW 0xF4
11666  6EE6     MOVWF 0xFE6, ACCESS
11668  0EFE     MOVLW 0xFE
1166A  6EE6     MOVWF 0xFE6, ACCESS
1166C  0E00     MOVLW 0x0
1166E  6EE6     MOVWF 0xFE6, ACCESS
11670  0E01     MOVLW 0x1
11672  6EE6     MOVWF 0xFE6, ACCESS
11674  EC09     CALL 0x1BA12, 0
11676  F0DD     NOP
1167A  F007     NOP
1167C  FFE6     NOP
11680  F00B     NOP
11682  FFE6     NOP
11684  0E04     MOVLW 0x4
11686  6EE6     MOVWF 0xFE6, ACCESS
11688  EC00     CALL 0x19C00, 0
1168A  F0CE     NOP
285:           			sprintf(get_vterm_ptr(2, 0), "Check 30 seconds    ");
1168C  0E48     MOVLW 0x48
1168E  6EE6     MOVWF 0xFE6, ACCESS
11690  0EFF     MOVLW 0xFF
11692  6EE6     MOVWF 0xFE6, ACCESS
11694  0E00     MOVLW 0x0
11696  6EE6     MOVWF 0xFE6, ACCESS
11698  0E02     MOVLW 0x2
1169A  6EE6     MOVWF 0xFE6, ACCESS
1169C  EC09     CALL 0x1BA12, 0
1169E  F0DD     NOP
116A2  F007     NOP
116A4  FFE6     NOP
116A8  F00B     NOP
116AA  FFE6     NOP
116AC  0E04     MOVLW 0x4
116AE  6EE6     MOVWF 0xFE6, ACCESS
116B0  EC00     CALL 0x19C00, 0
116B2  F0CE     NOP
286:           			update_lcd(0);
116B4  0E00     MOVLW 0x0
116B6  6EE6     MOVWF 0xFE6, ACCESS
116B8  EC78     CALL 0x19AF0, 0
116BA  F0CD     NOP
287:           			uint16_t i_esr = 1;
116BC  0E01     MOVLW 0x1
116BE  6E0B     MOVWF wtemp5, ACCESS
116C0  0E00     MOVLW 0x0
116C2  6E0C     MOVWF 0xC, ACCESS
116C4  0EF7     MOVLW 0xF7
116C8  F02F     NOP
116CA  FFE3     NOP
116CC  0EF8     MOVLW 0xF8
116D0  F033     NOP
116D2  FFE3     NOP
288:           			uint8_t shape = 0;
289:           			float esr_temp;
290:           			while ((esr_temp = esr_check(false)) < 0.0) {
116D4  D06D     BRA 0x17B0
117B0  0E00     MOVLW 0x0
117B2  6EE6     MOVWF 0xFE6, ACCESS
117B4  ECA0     CALL 0x17140, 0
117B6  F0B8     NOP
117B8  0EF3     MOVLW 0xF3
117BC  F007     NOP
117BE  FFE3     NOP
117C0  0EF4     MOVLW 0xF4
117C4  F00B     NOP
117C6  FFE3     NOP
117C8  0EF5     MOVLW 0xF5
117CC  F00F     NOP
117CE  FFE3     NOP
117D0  0EF6     MOVLW 0xF6
117D4  F013     NOP
117D6  FFE3     NOP
117D8  0EF6     MOVLW 0xF6
117DA  BEE3     BTFSC 0xFE3, 7, ACCESS
117DC  D77C     BRA 0x16D6
291:           				WaitMs(110); // limit display updates
116D6  0E6E     MOVLW 0x6E
116D8  6EE6     MOVWF 0xFE6, ACCESS
116DA  0E00     MOVLW 0x0
116DC  6EE6     MOVWF 0xFE6, ACCESS
116DE  EC5A     CALL 0x1B8B4, 0
116E0  F0DC     NOP
292:           				shape = (uint8_t) fabs(esr_temp);
116E2  0EF3     MOVLW 0xF3
116E6  FF8F     NOP
116E8  FFE6     NOP
116EC  FF8F     NOP
116EE  FFE6     NOP
116F2  FF8F     NOP
116F4  FFE6     NOP
116F8  FF8F     NOP
116FA  FFE6     NOP
116FC  ECC6     CALL 0x1A58C, 0
116FE  F0D2     NOP
11702  F007     NOP
11704  FFE6     NOP
11708  F00B     NOP
1170A  FFE6     NOP
1170E  F00F     NOP
11710  FFE6     NOP
11714  F013     NOP
11716  FFE6     NOP
11718  EC3B     CALL 0x18E76, 0
1171A  F0C7     NOP
1171E  F004     NOP
11720  F00C     NOP
11722  0EF9     MOVLW 0xF9
11726  F033     NOP
11728  FFE3     NOP
293:           				sprintf(get_vterm_ptr(2, 0), "Checking %c %c      ", spinners(0, false), spinners(shape, false));
1172A  0E00     MOVLW 0x0
1172C  6EE6     MOVWF 0xFE6, ACCESS
1172E  0EF8     MOVLW 0xF8
11730  50E3     MOVF 0xFE3, W, ACCESS
11732  6EE6     MOVWF 0xFE6, ACCESS
11734  ECF3     CALL 0x19FE6, 0
11736  F0CF     NOP
11738  5001     MOVF ltemp0, W, ACCESS
1173A  6EE6     MOVWF 0xFE6, ACCESS
1173C  0E00     MOVLW 0x0
1173E  6EE6     MOVWF 0xFE6, ACCESS
11740  0E00     MOVLW 0x0
11742  6EE6     MOVWF 0xFE6, ACCESS
11744  0E00     MOVLW 0x0
11746  6EE6     MOVWF 0xFE6, ACCESS
11748  ECF3     CALL 0x19FE6, 0
1174A  F0CF     NOP
1174C  5001     MOVF ltemp0, W, ACCESS
1174E  6EE6     MOVWF 0xFE6, ACCESS
11750  0E00     MOVLW 0x0
11752  6EE6     MOVWF 0xFE6, ACCESS
11754  0E33     MOVLW 0x33
11756  6EE6     MOVWF 0xFE6, ACCESS
11758  0EFF     MOVLW 0xFF
1175A  6EE6     MOVWF 0xFE6, ACCESS
1175C  0E00     MOVLW 0x0
1175E  6EE6     MOVWF 0xFE6, ACCESS
11760  0E02     MOVLW 0x2
11762  6EE6     MOVWF 0xFE6, ACCESS
11764  EC09     CALL 0x1BA12, 0
11766  F0DD     NOP
1176A  F007     NOP
1176C  FFE6     NOP
11770  F00B     NOP
11772  FFE6     NOP
11774  0E08     MOVLW 0x8
11776  6EE6     MOVWF 0xFE6, ACCESS
11778  EC00     CALL 0x19C00, 0
1177A  F0CE     NOP
294:           				update_lcd(0);
1177C  0E00     MOVLW 0x0
1177E  6EE6     MOVWF 0xFE6, ACCESS
11780  EC78     CALL 0x19AF0, 0
11782  F0CD     NOP
295:           
296:           				if (i_esr++ > 512)
11784  50E1     MOVF 0xFE1, W, ACCESS
11786  0FF7     ADDLW 0xF7
11788  6ED9     MOVWF 0xFD9, ACCESS
1178A  50E2     MOVF 0xFE2, W, ACCESS
1178C  6EDA     MOVWF 0xFDA, ACCESS
1178E  0EFF     MOVLW 0xFF
11790  22DA     ADDWFC 0xFDA, F, ACCESS
11794  FF7C     NOP
11796  F00B     NOP
11798  0E01     MOVLW 0x1
1179A  26DE     ADDWF 0xFDE, F, ACCESS
1179E  FF7C     NOP
117A0  F00C     NOP
117A2  0E00     MOVLW 0x0
117A4  22DD     ADDWFC 0xFDD, F, ACCESS
117A6  040B     DECF wtemp5, W, ACCESS
117A8  0E02     MOVLW 0x2
117AA  580C     SUBWFB 0xC, W, ACCESS
117AC  B0D8     BTFSC 0xFD8, 0, ACCESS
117AE  D017     BRA 0x17DE
297:           					break;
298:           			};
299:           			sprintf(get_vterm_ptr(0, 0), "ESR  %2.6f           ", C.esr);
117DE  EE21     LFSR 2, 0x787
117E0  F387     NOP
117E4  FF7B     NOP
117E6  FFE6     NOP
117EA  FF7B     NOP
117EC  FFE6     NOP
117F0  FF7B     NOP
117F2  FFE6     NOP
117F6  FF7B     NOP
117F8  FFE6     NOP
117FA  0E40     MOVLW 0x40
117FC  6EE6     MOVWF 0xFE6, ACCESS
117FE  0EFD     MOVLW 0xFD
11800  6EE6     MOVWF 0xFE6, ACCESS
11802  0E00     MOVLW 0x0
11804  6EE6     MOVWF 0xFE6, ACCESS
11806  0E00     MOVLW 0x0
11808  6EE6     MOVWF 0xFE6, ACCESS
1180A  EC09     CALL 0x1BA12, 0
1180C  F0DD     NOP
11810  F007     NOP
11812  FFE6     NOP
11816  F00B     NOP
11818  FFE6     NOP
1181A  0E08     MOVLW 0x8
1181C  6EE6     MOVWF 0xFE6, ACCESS
1181E  EC00     CALL 0x19C00, 0
11820  F0CE     NOP
300:           			sprintf(get_vterm_ptr(1, 0), "R1 %2.3f %3.4f           ", C.bv_one_load, C.load_i1);
11822  EE22     LFSR 2, 0x80D
11824  F00D     NOP
11828  FF7B     NOP
1182A  FFE6     NOP
1182E  FF7B     NOP
11830  FFE6     NOP
11834  FF7B     NOP
11836  FFE6     NOP
1183A  FF7B     NOP
1183C  FFE6     NOP
1183E  EE22     LFSR 2, 0x819
11840  F019     NOP
11844  FF7B     NOP
11846  FFE6     NOP
1184A  FF7B     NOP
1184C  FFE6     NOP
11850  FF7B     NOP
11852  FFE6     NOP
11856  FF7B     NOP
11858  FFE6     NOP
1185A  0E50     MOVLW 0x50
1185C  6EE6     MOVWF 0xFE6, ACCESS
1185E  0EFC     MOVLW 0xFC
11860  6EE6     MOVWF 0xFE6, ACCESS
11862  0E00     MOVLW 0x0
11864  6EE6     MOVWF 0xFE6, ACCESS
11866  0E01     MOVLW 0x1
11868  6EE6     MOVWF 0xFE6, ACCESS
1186A  EC09     CALL 0x1BA12, 0
1186C  F0DD     NOP
11870  F007     NOP
11872  FFE6     NOP
11876  F00B     NOP
11878  FFE6     NOP
1187A  0E0C     MOVLW 0xC
1187C  6EE6     MOVWF 0xFE6, ACCESS
1187E  EC00     CALL 0x19C00, 0
11880  F0CE     NOP
301:           			sprintf(get_vterm_ptr(2, 0), "R2 %2.3f %3.4f           ", C.bv_full_load, C.load_i2);
11882  EE22     LFSR 2, 0x811
11884  F011     NOP
11888  FF7B     NOP
1188A  FFE6     NOP
1188E  FF7B     NOP
11890  FFE6     NOP
11894  FF7B     NOP
11896  FFE6     NOP
1189A  FF7B     NOP
1189C  FFE6     NOP
1189E  EE22     LFSR 2, 0x81D
118A0  F01D     NOP
118A4  FF7B     NOP
118A6  FFE6     NOP
118AA  FF7B     NOP
118AC  FFE6     NOP
118B0  FF7B     NOP
118B2  FFE6     NOP
118B6  FF7B     NOP
118B8  FFE6     NOP
118BA  0E6A     MOVLW 0x6A
118BC  6EE6     MOVWF 0xFE6, ACCESS
118BE  0EFC     MOVLW 0xFC
118C0  6EE6     MOVWF 0xFE6, ACCESS
118C2  0E00     MOVLW 0x0
118C4  6EE6     MOVWF 0xFE6, ACCESS
118C6  0E02     MOVLW 0x2
118C8  6EE6     MOVWF 0xFE6, ACCESS
118CA  EC09     CALL 0x1BA12, 0
118CC  F0DD     NOP
118D0  F007     NOP
118D2  FFE6     NOP
118D6  F00B     NOP
118D8  FFE6     NOP
118DA  0E0C     MOVLW 0xC
118DC  6EE6     MOVWF 0xFE6, ACCESS
118DE  EC00     CALL 0x19C00, 0
118E0  F0CE     NOP
302:           			update_lcd(0);
118E2  0E00     MOVLW 0x0
118E4  6EE6     MOVWF 0xFE6, ACCESS
118E6  EC78     CALL 0x19AF0, 0
118E8  F0CD     NOP
303:           			WaitMs(5000);
118EA  0E88     MOVLW 0x88
118EC  6EE6     MOVWF 0xFE6, ACCESS
118EE  0E13     MOVLW 0x13
118F0  6EE6     MOVWF 0xFE6, ACCESS
118F2  EC5A     CALL 0x1B8B4, 0
118F4  F0DC     NOP
304:           			V.system_stable = true;
118F6  0E01     MOVLW 0x1
118F8  0101     MOVLB 0x1
118FA  6FDE     MOVWF 0xDE, BANKED
305:           			break;
118FC  D01C     BRA 0x1936
306:           		case UI_STATE_HOST:
307:           			break;
308:           		case UI_STATE_LOG:
309:           			break;
310:           		case UI_STATE_MON: // monitor
311:           			P.SYSTEM_STABLE = true;
118FE  0100     MOVLB 0x0
11900  819F     BSF 0x9F, 0, BANKED
312:           			break;
11902  D019     BRA 0x1936
313:           		case UI_STATE_ERROR:
314:           		default:
315:           			V.ui_state = UI_STATE_INIT;
11904  6B30     CLRF 0x30, BANKED
316:           			break;
11906  D017     BRA 0x1936
317:           		}
11908  0101     MOVLB 0x1
1190A  5130     MOVF 0x30, W, BANKED
1190C  6E0B     MOVWF wtemp5, ACCESS
1190E  6A0C     CLRF 0xC, ACCESS
11910  500C     MOVF 0xC, W, ACCESS
11912  0A00     XORLW 0x0
11914  A4D8     BTFSS 0xFD8, 2, ACCESS
11916  D7F6     BRA 0x1904
11918  500B     MOVF wtemp5, W, ACCESS
1191A  0A00     XORLW 0x0
1191C  B4D8     BTFSC 0xFD8, 2, ACCESS
1191E  D4CE     BRA 0x12BC
11920  0A01     XORLW 0x1
11922  B4D8     BTFSC 0xFD8, 2, ACCESS
11924  D008     BRA 0x1936
11926  0A02     XORLW 0x2
11928  B4D8     BTFSC 0xFD8, 2, ACCESS
1192A  D005     BRA 0x1936
1192C  0A07     XORLW 0x7
1192E  B4D8     BTFSC 0xFD8, 2, ACCESS
11930  D7E6     BRA 0x18FE
11932  0A01     XORLW 0x1
11934  D7E7     BRA 0x1904
318:           
319:           		if (TimerDone(TMR_ADC) && check_adc_scan()) {
11936  0E01     MOVLW 0x1
11938  6EE6     MOVWF 0xFE6, ACCESS
1193A  EC8B     CALL 0x1BB16, 0
1193C  F0DD     NOP
1193E  5001     MOVF ltemp0, W, ACCESS
11940  B4D8     BTFSC 0xFD8, 2, ACCESS
11942  D013     BRA 0x196A
11944  EC8F     CALL 0x1C11E, 0
11946  F0E0     NOP
11948  5001     MOVF ltemp0, W, ACCESS
1194A  B4D8     BTFSC 0xFD8, 2, ACCESS
1194C  D00E     BRA 0x196A
320:           			/*
321:           			 * download the system data variables
322:           			 */
323:           			convert_adc_data();
1194E  EC6A     CALL 0x1A4D4, 0
11950  F0D2     NOP
324:           			/*
325:           			 * restart the conversion process
326:           			 */
327:           			clear_adc_scan();
11952  EC9F     CALL 0x1C13E, 0
11954  F0E0     NOP
328:           			start_adc_scan();
11956  ECFE     CALL 0x1AFFC, 0
11958  F0D7     NOP
329:           			StartTimer(TMR_ADC, ADC_SCAN_SPEED);
1195A  0EC8     MOVLW 0xC8
1195C  6EE6     MOVWF 0xFE6, ACCESS
1195E  0E00     MOVLW 0x0
11960  6EE6     MOVWF 0xFE6, ACCESS
11962  0E01     MOVLW 0x1
11964  6EE6     MOVWF 0xFE6, ACCESS
11966  EC65     CALL 0x1B6CA, 0
11968  F0DB     NOP
330:           		}
331:           
332:           		if (V.ticks) {
333:           
334:           		}
335:           
336:           		if (TimerDone(TMR_DISPLAY)) { // limit update rate
1196A  0E0A     MOVLW 0xA
1196C  6EE6     MOVWF 0xFE6, ACCESS
1196E  EC8B     CALL 0x1BB16, 0
11970  F0DD     NOP
11972  5001     MOVF ltemp0, W, ACCESS
11974  B4D8     BTFSC 0xFD8, 2, ACCESS
11976  EF45     GOTO 0x1228A
11978  F091     NOP
337:           			if (TimerDone(TMR_HELPDIS)) {
1197A  0E09     MOVLW 0x9
1197C  6EE6     MOVWF 0xFE6, ACCESS
1197E  EC8B     CALL 0x1BB16, 0
11980  F0DD     NOP
11982  5001     MOVF ltemp0, W, ACCESS
11984  B4D8     BTFSC 0xFD8, 2, ACCESS
11986  D004     BRA 0x1990
338:           				set_display_info(DIS_STR);
11988  0E00     MOVLW 0x0
1198A  6EE6     MOVWF 0xFE6, ACCESS
1198C  EC91     CALL 0x1BF22, 0
1198E  F0DF     NOP
339:           			}
340:           			calc_model_data();
11990  EC3B     CALL 0x15C76, 0
11992  F0AE     NOP
341:           
342:           			if (false) {
343:           				sprintf(get_vterm_ptr(0, 0), "%d %2.4f   %d  ", get_raw_result(i), C.calc[i], get_switch(SSELECT));
344:           				sprintf(get_vterm_ptr(1, 0), "%d %2.4f   %d  ", get_raw_result(j), C.calc[j], get_switch(SENTER));
345:           				sprintf(get_vterm_ptr(2, 0), "%d %2.4f, %d   #", get_raw_result(k), C.calc[k], inp_index);
346:           			} else {
347:           				hid_display(&H);
11994  0EF7     MOVLW 0xF7
11996  6EE6     MOVWF 0xFE6, ACCESS
11998  EC85     CALL 0x19D0A, 0
1199A  F0CE     NOP
348:           				switch (H.hid_display) {
1199C  EFF4     GOTO 0x121E8
1199E  F090     NOP
349:           				case HID_PWR:
350:           					V.calib = false;
119A0  0101     MOVLB 0x1
119A2  6BDC     CLRF 0xDC, BANKED
351:           					sprintf(get_vterm_ptr(0, 0), "PV %c PWR %3.2f      ", (C.day) ? 'D' : ' ', C.p_pv);
119A4  EE22     LFSR 2, 0x821
119A6  F021     NOP
119A8  50DF     MOVF 0xFDF, W, ACCESS
119AA  A4D8     BTFSS 0xFD8, 2, ACCESS
119AC  D002     BRA 0x19B2
119AE  0E20     MOVLW 0x20
119B0  D001     BRA 0x19B4
119B2  0E44     MOVLW 0x44
119B4  6E0B     MOVWF wtemp5, ACCESS
119B6  0E00     MOVLW 0x0
119B8  6E0C     MOVWF 0xC, ACCESS
119BA  0EF1     MOVLW 0xF1
119BE  F02F     NOP
119C0  FFE3     NOP
119C2  0EF2     MOVLW 0xF2
119C6  F033     NOP
119C8  FFE3     NOP
119CA  EE21     LFSR 2, 0x77B
119CC  F37B     NOP
119D0  FF7B     NOP
119D2  FFE6     NOP
119D6  FF7B     NOP
119D8  FFE6     NOP
119DC  FF7B     NOP
119DE  FFE6     NOP
119E2  FF7B     NOP
119E4  FFE6     NOP
119E6  0EED     MOVLW 0xED
119EA  FF8F     NOP
119EC  FFE6     NOP
119F0  FF8F     NOP
119F2  FFE6     NOP
119F4  0E1C     MOVLW 0x1C
119F6  6EE6     MOVWF 0xFE6, ACCESS
119F8  0EFE     MOVLW 0xFE
119FA  6EE6     MOVWF 0xFE6, ACCESS
119FC  0E00     MOVLW 0x0
119FE  6EE6     MOVWF 0xFE6, ACCESS
11A00  0E00     MOVLW 0x0
11A02  6EE6     MOVWF 0xFE6, ACCESS
11A04  EC09     CALL 0x1BA12, 0
11A06  F0DD     NOP
11A0A  F007     NOP
11A0C  FFE6     NOP
11A10  F00B     NOP
11A12  FFE6     NOP
11A14  0E0A     MOVLW 0xA
11A16  6EE6     MOVWF 0xFE6, ACCESS
11A18  EC00     CALL 0x19C00, 0
11A1A  F0CE     NOP
352:           					sprintf(get_vterm_ptr(1, 0), "LOAD PWR %3.2f       ", C.p_load);
11A1C  EE21     LFSR 2, 0x773
11A1E  F373     NOP
11A22  FF7B     NOP
11A24  FFE6     NOP
11A28  FF7B     NOP
11A2A  FFE6     NOP
11A2E  FF7B     NOP
11A30  FFE6     NOP
11A34  FF7B     NOP
11A36  FFE6     NOP
11A38  0E06     MOVLW 0x6
11A3A  6EE6     MOVWF 0xFE6, ACCESS
11A3C  0EFE     MOVLW 0xFE
11A3E  6EE6     MOVWF 0xFE6, ACCESS
11A40  0E00     MOVLW 0x0
11A42  6EE6     MOVWF 0xFE6, ACCESS
11A44  0E01     MOVLW 0x1
11A46  6EE6     MOVWF 0xFE6, ACCESS
11A48  EC09     CALL 0x1BA12, 0
11A4A  F0DD     NOP
11A4E  F007     NOP
11A50  FFE6     NOP
11A54  F00B     NOP
11A56  FFE6     NOP
11A58  0E08     MOVLW 0x8
11A5A  6EE6     MOVWF 0xFE6, ACCESS
11A5C  EC00     CALL 0x19C00, 0
11A5E  F0CE     NOP
353:           					sprintf(get_vterm_ptr(2, 0), "INV  PWR %3.2f       ", C.p_inverter);
11A60  EE21     LFSR 2, 0x777
11A62  F377     NOP
11A66  FF7B     NOP
11A68  FFE6     NOP
11A6C  FF7B     NOP
11A6E  FFE6     NOP
11A72  FF7B     NOP
11A74  FFE6     NOP
11A78  FF7B     NOP
11A7A  FFE6     NOP
11A7C  0EF0     MOVLW 0xF0
11A7E  6EE6     MOVWF 0xFE6, ACCESS
11A80  0EFD     MOVLW 0xFD
11A82  6EE6     MOVWF 0xFE6, ACCESS
11A84  0E00     MOVLW 0x0
11A86  6EE6     MOVWF 0xFE6, ACCESS
11A88  0E02     MOVLW 0x2
11A8A  6EE6     MOVWF 0xFE6, ACCESS
11A8C  EC09     CALL 0x1BA12, 0
11A8E  F0DD     NOP
11A92  F007     NOP
11A94  FFE6     NOP
11A98  F00B     NOP
11A9A  FFE6     NOP
11A9C  0E08     MOVLW 0x8
11A9E  6EE6     MOVWF 0xFE6, ACCESS
11AA0  EC00     CALL 0x19C00, 0
11AA2  F0CE     NOP
354:           
355:           					sprintf(get_vterm_ptr(0, 1), "PV %c WH %3.2f       ", (C.day) ? 'D' : ' ', C.pvkw);
11AA4  EE22     LFSR 2, 0x821
11AA6  F021     NOP
11AA8  50DF     MOVF 0xFDF, W, ACCESS
11AAA  A4D8     BTFSS 0xFD8, 2, ACCESS
11AAC  D002     BRA 0x1AB2
11AAE  0E20     MOVLW 0x20
11AB0  D001     BRA 0x1AB4
11AB2  0E44     MOVLW 0x44
11AB4  6E0B     MOVWF wtemp5, ACCESS
11AB6  0E00     MOVLW 0x0
11AB8  6E0C     MOVWF 0xC, ACCESS
11ABA  0EEF     MOVLW 0xEF
11ABE  F02F     NOP
11AC0  FFE3     NOP
11AC2  0EF0     MOVLW 0xF0
11AC6  F033     NOP
11AC8  FFE3     NOP
11ACA  EE21     LFSR 2, 0x7A7
11ACC  F3A7     NOP
11AD0  FF7B     NOP
11AD2  FFE6     NOP
11AD6  FF7B     NOP
11AD8  FFE6     NOP
11ADC  FF7B     NOP
11ADE  FFE6     NOP
11AE2  FF7B     NOP
11AE4  FFE6     NOP
11AE6  0EEB     MOVLW 0xEB
11AEA  FF8F     NOP
11AEC  FFE6     NOP
11AF0  FF8F     NOP
11AF2  FFE6     NOP
11AF4  0EDA     MOVLW 0xDA
11AF6  6EE6     MOVWF 0xFE6, ACCESS
11AF8  0EFD     MOVLW 0xFD
11AFA  6EE6     MOVWF 0xFE6, ACCESS
11AFC  0E01     MOVLW 0x1
11AFE  6EE6     MOVWF 0xFE6, ACCESS
11B00  0E00     MOVLW 0x0
11B02  6EE6     MOVWF 0xFE6, ACCESS
11B04  EC09     CALL 0x1BA12, 0
11B06  F0DD     NOP
11B0A  F007     NOP
11B0C  FFE6     NOP
11B10  F00B     NOP
11B12  FFE6     NOP
11B14  0E0A     MOVLW 0xA
11B16  6EE6     MOVWF 0xFE6, ACCESS
11B18  EC00     CALL 0x19C00, 0
11B1A  F0CE     NOP
356:           					sprintf(get_vterm_ptr(1, 1), "LOAD WH %3.2f        ", C.loadkw);
11B1C  EE21     LFSR 2, 0x7AF
11B1E  F3AF     NOP
11B22  FF7B     NOP
11B24  FFE6     NOP
11B28  FF7B     NOP
11B2A  FFE6     NOP
11B2E  FF7B     NOP
11B30  FFE6     NOP
11B34  FF7B     NOP
11B36  FFE6     NOP
11B38  0EC4     MOVLW 0xC4
11B3A  6EE6     MOVWF 0xFE6, ACCESS
11B3C  0EFD     MOVLW 0xFD
11B3E  6EE6     MOVWF 0xFE6, ACCESS
11B40  0E01     MOVLW 0x1
11B42  6EE6     MOVWF 0xFE6, ACCESS
11B44  0E01     MOVLW 0x1
11B46  6EE6     MOVWF 0xFE6, ACCESS
11B48  EC09     CALL 0x1BA12, 0
11B4A  F0DD     NOP
11B4E  F007     NOP
11B50  FFE6     NOP
11B54  F00B     NOP
11B56  FFE6     NOP
11B58  0E08     MOVLW 0x8
11B5A  6EE6     MOVWF 0xFE6, ACCESS
11B5C  EC00     CALL 0x19C00, 0
11B5E  F0CE     NOP
357:           					sprintf(get_vterm_ptr(2, 1), "INV  WH %3.2f        ", C.invkw);
11B60  EE21     LFSR 2, 0x7AB
11B62  F3AB     NOP
11B66  FF7B     NOP
11B68  FFE6     NOP
11B6C  FF7B     NOP
11B6E  FFE6     NOP
11B72  FF7B     NOP
11B74  FFE6     NOP
11B78  FF7B     NOP
11B7A  FFE6     NOP
11B7C  0EAE     MOVLW 0xAE
11B7E  6EE6     MOVWF 0xFE6, ACCESS
11B80  0EFD     MOVLW 0xFD
11B82  6EE6     MOVWF 0xFE6, ACCESS
11B84  0E01     MOVLW 0x1
11B86  6EE6     MOVWF 0xFE6, ACCESS
11B88  0E02     MOVLW 0x2
11B8A  6EE6     MOVWF 0xFE6, ACCESS
11B8C  EC09     CALL 0x1BA12, 0
11B8E  F0DD     NOP
11B92  F007     NOP
11B94  FFE6     NOP
11B98  F00B     NOP
11B9A  FFE6     NOP
11B9C  0E08     MOVLW 0x8
11B9E  6EE6     MOVWF 0xFE6, ACCESS
11BA0  EC00     CALL 0x19C00, 0
11BA2  F0CE     NOP
358:           					break;
11BA4  D337     BRA 0x2214
359:           				case HID_MAIN:
360:           					V.calib = false;
11BA6  0101     MOVLB 0x1
11BA8  6BDC     CLRF 0xDC, BANKED
361:           					sprintf(get_vterm_ptr(0, 0), "PV %2.2f PA %2.2f    ", C.calc[V_PV], C.calc[C_PV]);
11BAA  EE21     LFSR 2, 0x703
11BAC  F303     NOP
11BB0  FF7B     NOP
11BB2  FFE6     NOP
11BB6  FF7B     NOP
11BB8  FFE6     NOP
11BBC  FF7B     NOP
11BBE  FFE6     NOP
11BC2  FF7B     NOP
11BC4  FFE6     NOP
11BC6  EE21     LFSR 2, 0x713
11BC8  F313     NOP
11BCC  FF7B     NOP
11BCE  FFE6     NOP
11BD2  FF7B     NOP
11BD4  FFE6     NOP
11BD8  FF7B     NOP
11BDA  FFE6     NOP
11BDE  FF7B     NOP
11BE0  FFE6     NOP
11BE2  0E74     MOVLW 0x74
11BE4  6EE6     MOVWF 0xFE6, ACCESS
11BE6  0EFE     MOVLW 0xFE
11BE8  6EE6     MOVWF 0xFE6, ACCESS
11BEA  0E00     MOVLW 0x0
11BEC  6EE6     MOVWF 0xFE6, ACCESS
11BEE  0E00     MOVLW 0x0
11BF0  6EE6     MOVWF 0xFE6, ACCESS
11BF2  EC09     CALL 0x1BA12, 0
11BF4  F0DD     NOP
11BF8  F007     NOP
11BFA  FFE6     NOP
11BFE  F00B     NOP
11C00  FFE6     NOP
11C02  0E0C     MOVLW 0xC
11C04  6EE6     MOVWF 0xFE6, ACCESS
11C06  EC00     CALL 0x19C00, 0
11C08  F0CE     NOP
362:           					sprintf(get_vterm_ptr(1, 0), "BV %2.2f BA %2.2f    ", C.calc[V_BAT], C.calc[C_BATT]);
11C0A  EE21     LFSR 2, 0x6FF
11C0C  F2FF     NOP
11C10  FF7B     NOP
11C12  FFE6     NOP
11C16  FF7B     NOP
11C18  FFE6     NOP
11C1C  FF7B     NOP
11C1E  FFE6     NOP
11C22  FF7B     NOP
11C24  FFE6     NOP
11C26  EE21     LFSR 2, 0x70F
11C28  F30F     NOP
11C2C  FF7B     NOP
11C2E  FFE6     NOP
11C32  FF7B     NOP
11C34  FFE6     NOP
11C38  FF7B     NOP
11C3A  FFE6     NOP
11C3E  FF7B     NOP
11C40  FFE6     NOP
11C42  0E48     MOVLW 0x48
11C44  6EE6     MOVWF 0xFE6, ACCESS
11C46  0EFE     MOVLW 0xFE
11C48  6EE6     MOVWF 0xFE6, ACCESS
11C4A  0E00     MOVLW 0x0
11C4C  6EE6     MOVWF 0xFE6, ACCESS
11C4E  0E01     MOVLW 0x1
11C50  6EE6     MOVWF 0xFE6, ACCESS
11C52  EC09     CALL 0x1BA12, 0
11C54  F0DD     NOP
11C58  F007     NOP
11C5A  FFE6     NOP
11C5E  F00B     NOP
11C60  FFE6     NOP
11C62  0E0C     MOVLW 0xC
11C64  6EE6     MOVWF 0xFE6, ACCESS
11C66  EC00     CALL 0x19C00, 0
11C68  F0CE     NOP
363:           					sprintf(get_vterm_ptr(2, 0), "CV %2.2f LA %2.2f    ", C.calc[V_CC], C.c_load);
11C6A  EE21     LFSR 2, 0x73F
11C6C  F33F     NOP
11C70  FF7B     NOP
11C72  FFE6     NOP
11C76  FF7B     NOP
11C78  FFE6     NOP
11C7C  FF7B     NOP
11C7E  FFE6     NOP
11C82  FF7B     NOP
11C84  FFE6     NOP
11C86  EE21     LFSR 2, 0x707
11C88  F307     NOP
11C8C  FF7B     NOP
11C8E  FFE6     NOP
11C92  FF7B     NOP
11C94  FFE6     NOP
11C98  FF7B     NOP
11C9A  FFE6     NOP
11C9E  FF7B     NOP
11CA0  FFE6     NOP
11CA2  0E5E     MOVLW 0x5E
11CA4  6EE6     MOVWF 0xFE6, ACCESS
11CA6  0EFE     MOVLW 0xFE
11CA8  6EE6     MOVWF 0xFE6, ACCESS
11CAA  0E00     MOVLW 0x0
11CAC  6EE6     MOVWF 0xFE6, ACCESS
11CAE  0E02     MOVLW 0x2
11CB0  6EE6     MOVWF 0xFE6, ACCESS
11CB2  EC09     CALL 0x1BA12, 0
11CB4  F0DD     NOP
11CB8  F007     NOP
11CBA  FFE6     NOP
11CBE  F00B     NOP
11CC0  FFE6     NOP
11CC2  0E0C     MOVLW 0xC
11CC4  6EE6     MOVWF 0xFE6, ACCESS
11CC6  EC00     CALL 0x19C00, 0
11CC8  F0CE     NOP
364:           
365:           					sprintf(get_vterm_ptr(0, 1), "BAT IWH %4.1f        ", C.bkwi);
11CCA  EE21     LFSR 2, 0x79F
11CCC  F39F     NOP
11CD0  FF7B     NOP
11CD2  FFE6     NOP
11CD6  FF7B     NOP
11CD8  FFE6     NOP
11CDC  FF7B     NOP
11CDE  FFE6     NOP
11CE2  FF7B     NOP
11CE4  FFE6     NOP
11CE6  0E6C     MOVLW 0x6C
11CE8  6EE6     MOVWF 0xFE6, ACCESS
11CEA  0EFD     MOVLW 0xFD
11CEC  6EE6     MOVWF 0xFE6, ACCESS
11CEE  0E01     MOVLW 0x1
11CF0  6EE6     MOVWF 0xFE6, ACCESS
11CF2  0E00     MOVLW 0x0
11CF4  6EE6     MOVWF 0xFE6, ACCESS
11CF6  EC09     CALL 0x1BA12, 0
11CF8  F0DD     NOP
11CFC  F007     NOP
11CFE  FFE6     NOP
11D02  F00B     NOP
11D04  FFE6     NOP
11D06  0E08     MOVLW 0x8
11D08  6EE6     MOVWF 0xFE6, ACCESS
11D0A  EC00     CALL 0x19C00, 0
11D0C  F0CE     NOP
366:           					sprintf(get_vterm_ptr(1, 1), "BAT OWH %4.1f        ", C.bkwo);
11D0E  EE21     LFSR 2, 0x7A3
11D10  F3A3     NOP
11D14  FF7B     NOP
11D16  FFE6     NOP
11D1A  FF7B     NOP
11D1C  FFE6     NOP
11D20  FF7B     NOP
11D22  FFE6     NOP
11D26  FF7B     NOP
11D28  FFE6     NOP
11D2A  0E82     MOVLW 0x82
11D2C  6EE6     MOVWF 0xFE6, ACCESS
11D2E  0EFD     MOVLW 0xFD
11D30  6EE6     MOVWF 0xFE6, ACCESS
11D32  0E01     MOVLW 0x1
11D34  6EE6     MOVWF 0xFE6, ACCESS
11D36  0E01     MOVLW 0x1
11D38  6EE6     MOVWF 0xFE6, ACCESS
11D3A  EC09     CALL 0x1BA12, 0
11D3C  F0DD     NOP
11D40  F007     NOP
11D42  FFE6     NOP
11D46  F00B     NOP
11D48  FFE6     NOP
11D4A  0E08     MOVLW 0x8
11D4C  6EE6     MOVWF 0xFE6, ACCESS
11D4E  EC00     CALL 0x19C00, 0
11D50  F0CE     NOP
367:           					sprintf(get_vterm_ptr(2, 1), "BAT TWH %4.1f        ", C.bkwi + C.bkwo);
11D52  EE21     LFSR 2, 0x7A3
11D54  F3A3     NOP
11D58  FF7B     NOP
11D5A  FFE6     NOP
11D5E  FF7B     NOP
11D60  FFE6     NOP
11D64  FF7B     NOP
11D66  FFE6     NOP
11D6A  FF7B     NOP
11D6C  FFE6     NOP
11D6E  EE21     LFSR 2, 0x79F
11D70  F39F     NOP
11D74  FF7B     NOP
11D76  FFE6     NOP
11D7A  FF7B     NOP
11D7C  FFE6     NOP
11D80  FF7B     NOP
11D82  FFE6     NOP
11D86  FF7B     NOP
11D88  FFE6     NOP
11D8A  ECD6     CALL 0x145AC, 0
11D8C  F0A2     NOP
11D90  F007     NOP
11D92  FFE6     NOP
11D96  F00B     NOP
11D98  FFE6     NOP
11D9C  F00F     NOP
11D9E  FFE6     NOP
11DA2  F013     NOP
11DA4  FFE6     NOP
11DA6  0E98     MOVLW 0x98
11DA8  6EE6     MOVWF 0xFE6, ACCESS
11DAA  0EFD     MOVLW 0xFD
11DAC  6EE6     MOVWF 0xFE6, ACCESS
11DAE  0E01     MOVLW 0x1
11DB0  6EE6     MOVWF 0xFE6, ACCESS
11DB2  0E02     MOVLW 0x2
11DB4  6EE6     MOVWF 0xFE6, ACCESS
11DB6  EC09     CALL 0x1BA12, 0
11DB8  F0DD     NOP
11DBC  F007     NOP
11DBE  FFE6     NOP
11DC2  F00B     NOP
11DC4  FFE6     NOP
11DC6  0E08     MOVLW 0x8
11DC8  6EE6     MOVWF 0xFE6, ACCESS
11DCA  EC00     CALL 0x19C00, 0
11DCC  F0CE     NOP
368:           					break;
11DCE  D222     BRA 0x2214
369:           				case HID_RUN:
370:           					V.calib = false;
11DD0  0101     MOVLB 0x1
11DD2  6BDC     CLRF 0xDC, BANKED
371:           					sprintf(get_vterm_ptr(0, 0), "BATT PWR %3.2f        ", C.p_bat);
11DD4  EE21     LFSR 2, 0x77F
11DD6  F37F     NOP
11DDA  FF7B     NOP
11DDC  FFE6     NOP
11DE0  FF7B     NOP
11DE2  FFE6     NOP
11DE6  FF7B     NOP
11DE8  FFE6     NOP
11DEC  FF7B     NOP
11DEE  FFE6     NOP
11DF0  0EE4     MOVLW 0xE4
11DF2  6EE6     MOVWF 0xFE6, ACCESS
11DF4  0EFC     MOVLW 0xFC
11DF6  6EE6     MOVWF 0xFE6, ACCESS
11DF8  0E00     MOVLW 0x0
11DFA  6EE6     MOVWF 0xFE6, ACCESS
11DFC  0E00     MOVLW 0x0
11DFE  6EE6     MOVWF 0xFE6, ACCESS
11E00  EC09     CALL 0x1BA12, 0
11E02  F0DD     NOP
11E06  F007     NOP
11E08  FFE6     NOP
11E0C  F00B     NOP
11E0E  FFE6     NOP
11E10  0E08     MOVLW 0x8
11E12  6EE6     MOVWF 0xFE6, ACCESS
11E14  EC00     CALL 0x19C00, 0
11E16  F0CE     NOP
372:           					sprintf(get_vterm_ptr(1, 0), "BAH %3.2f P%3.2f      ", C.dynamic_ah, C.pv_ah);
11E18  EE21     LFSR 2, 0x793
11E1A  F393     NOP
11E1E  FF7B     NOP
11E20  FFE6     NOP
11E24  FF7B     NOP
11E26  FFE6     NOP
11E2A  FF7B     NOP
11E2C  FFE6     NOP
11E30  FF7B     NOP
11E32  FFE6     NOP
11E34  EE21     LFSR 2, 0x78F
11E36  F38F     NOP
11E3A  FF7B     NOP
11E3C  FFE6     NOP
11E40  FF7B     NOP
11E42  FFE6     NOP
11E46  FF7B     NOP
11E48  FFE6     NOP
11E4C  FF7B     NOP
11E4E  FFE6     NOP
11E50  0E29     MOVLW 0x29
11E52  6EE6     MOVWF 0xFE6, ACCESS
11E54  0EFD     MOVLW 0xFD
11E56  6EE6     MOVWF 0xFE6, ACCESS
11E58  0E00     MOVLW 0x0
11E5A  6EE6     MOVWF 0xFE6, ACCESS
11E5C  0E01     MOVLW 0x1
11E5E  6EE6     MOVWF 0xFE6, ACCESS
11E60  EC09     CALL 0x1BA12, 0
11E62  F0DD     NOP
11E66  F007     NOP
11E68  FFE6     NOP
11E6C  F00B     NOP
11E6E  FFE6     NOP
11E70  0E0C     MOVLW 0xC
11E72  6EE6     MOVWF 0xFE6, ACCESS
11E74  EC00     CALL 0x19C00, 0
11E76  F0CE     NOP
373:           					sprintf(get_vterm_ptr(2, 0), "S%cC %d RUN %d        ", spinners(5, false), C.soc, C.runtime);
11E78  EE21     LFSR 2, 0x7B3
11E7A  F3B3     NOP
11E7E  FF78     NOP
11E80  F00B     NOP
11E84  FF74     NOP
11E86  F00C     NOP
11E8A  F02F     NOP
11E8C  FFE6     NOP
11E90  F033     NOP
11E92  FFE6     NOP
11E94  EE21     LFSR 2, 0x7B5
11E96  F3B5     NOP
11E9A  FF78     NOP
11E9C  F00B     NOP
11EA0  FF74     NOP
11EA2  F00C     NOP
11EA6  F02F     NOP
11EA8  FFE6     NOP
11EAC  F033     NOP
11EAE  FFE6     NOP
11EB0  0E00     MOVLW 0x0
11EB2  6EE6     MOVWF 0xFE6, ACCESS
11EB4  0E05     MOVLW 0x5
11EB6  6EE6     MOVWF 0xFE6, ACCESS
11EB8  ECF3     CALL 0x19FE6, 0
11EBA  F0CF     NOP
11EBC  5001     MOVF ltemp0, W, ACCESS
11EBE  6EE6     MOVWF 0xFE6, ACCESS
11EC0  0E00     MOVLW 0x0
11EC2  6EE6     MOVWF 0xFE6, ACCESS
11EC4  0ECD     MOVLW 0xCD
11EC6  6EE6     MOVWF 0xFE6, ACCESS
11EC8  0EFC     MOVLW 0xFC
11ECA  6EE6     MOVWF 0xFE6, ACCESS
11ECC  0E00     MOVLW 0x0
11ECE  6EE6     MOVWF 0xFE6, ACCESS
11ED0  0E02     MOVLW 0x2
11ED2  6EE6     MOVWF 0xFE6, ACCESS
11ED4  EC09     CALL 0x1BA12, 0
11ED6  F0DD     NOP
11EDA  F007     NOP
11EDC  FFE6     NOP
11EE0  F00B     NOP
11EE2  FFE6     NOP
11EE4  0E0A     MOVLW 0xA
11EE6  6EE6     MOVWF 0xFE6, ACCESS
11EE8  EC00     CALL 0x19C00, 0
11EEA  F0CE     NOP
374:           
375:           					sprintf(get_vterm_ptr(0, 1), "ESR  %2.6f            ", C.esr);
11EEC  EE21     LFSR 2, 0x787
11EEE  F387     NOP
11EF2  FF7B     NOP
11EF4  FFE6     NOP
11EF8  FF7B     NOP
11EFA  FFE6     NOP
11EFE  FF7B     NOP
11F00  FFE6     NOP
11F04  FF7B     NOP
11F06  FFE6     NOP
11F08  0EB6     MOVLW 0xB6
11F0A  6EE6     MOVWF 0xFE6, ACCESS
11F0C  0EFC     MOVLW 0xFC
11F0E  6EE6     MOVWF 0xFE6, ACCESS
11F10  0E01     MOVLW 0x1
11F12  6EE6     MOVWF 0xFE6, ACCESS
11F14  0E00     MOVLW 0x0
11F16  6EE6     MOVWF 0xFE6, ACCESS
11F18  EC09     CALL 0x1BA12, 0
11F1A  F0DD     NOP
11F1E  F007     NOP
11F20  FFE6     NOP
11F24  F00B     NOP
11F26  FFE6     NOP
11F28  0E08     MOVLW 0x8
11F2A  6EE6     MOVWF 0xFE6, ACCESS
11F2C  EC00     CALL 0x19C00, 0
11F2E  F0CE     NOP
376:           					sprintf(get_vterm_ptr(1, 1), "R1 %2.3f %3.4f        ", C.bv_one_load, C.load_i1);
11F30  EE22     LFSR 2, 0x80D
11F32  F00D     NOP
11F36  FF7B     NOP
11F38  FFE6     NOP
11F3C  FF7B     NOP
11F3E  FFE6     NOP
11F42  FF7B     NOP
11F44  FFE6     NOP
11F48  FF7B     NOP
11F4A  FFE6     NOP
11F4C  EE22     LFSR 2, 0x819
11F4E  F019     NOP
11F52  FF7B     NOP
11F54  FFE6     NOP
11F58  FF7B     NOP
11F5A  FFE6     NOP
11F5E  FF7B     NOP
11F60  FFE6     NOP
11F64  FF7B     NOP
11F66  FFE6     NOP
11F68  0EFB     MOVLW 0xFB
11F6A  6EE6     MOVWF 0xFE6, ACCESS
11F6C  0EFC     MOVLW 0xFC
11F6E  6EE6     MOVWF 0xFE6, ACCESS
11F70  0E01     MOVLW 0x1
11F72  6EE6     MOVWF 0xFE6, ACCESS
11F74  0E01     MOVLW 0x1
11F76  6EE6     MOVWF 0xFE6, ACCESS
11F78  EC09     CALL 0x1BA12, 0
11F7A  F0DD     NOP
11F7E  F007     NOP
11F80  FFE6     NOP
11F84  F00B     NOP
11F86  FFE6     NOP
11F88  0E0C     MOVLW 0xC
11F8A  6EE6     MOVWF 0xFE6, ACCESS
11F8C  EC00     CALL 0x19C00, 0
11F8E  F0CE     NOP
377:           					sprintf(get_vterm_ptr(2, 1), "R2 %2.3f %3.4f        ", C.bv_full_load, C.load_i2);
11F90  EE22     LFSR 2, 0x811
11F92  F011     NOP
11F96  FF7B     NOP
11F98  FFE6     NOP
11F9C  FF7B     NOP
11F9E  FFE6     NOP
11FA2  FF7B     NOP
11FA4  FFE6     NOP
11FA8  FF7B     NOP
11FAA  FFE6     NOP
11FAC  EE22     LFSR 2, 0x81D
11FAE  F01D     NOP
11FB2  FF7B     NOP
11FB4  FFE6     NOP
11FB8  FF7B     NOP
11FBA  FFE6     NOP
11FBE  FF7B     NOP
11FC0  FFE6     NOP
11FC4  FF7B     NOP
11FC6  FFE6     NOP
11FC8  0E12     MOVLW 0x12
11FCA  6EE6     MOVWF 0xFE6, ACCESS
11FCC  0EFD     MOVLW 0xFD
11FCE  6EE6     MOVWF 0xFE6, ACCESS
11FD0  0E01     MOVLW 0x1
11FD2  6EE6     MOVWF 0xFE6, ACCESS
11FD4  0E02     MOVLW 0x2
11FD6  6EE6     MOVWF 0xFE6, ACCESS
11FD8  EC09     CALL 0x1BA12, 0
11FDA  F0DD     NOP
11FDE  F007     NOP
11FE0  FFE6     NOP
11FE4  F00B     NOP
11FE6  FFE6     NOP
11FE8  0E0C     MOVLW 0xC
11FEA  6EE6     MOVWF 0xFE6, ACCESS
11FEC  EC00     CALL 0x19C00, 0
11FEE  F0CE     NOP
378:           					break;
11FF0  D111     BRA 0x2214
379:           				case HID_AUX:
380:           					if (!V.calib) {
11FF2  0101     MOVLB 0x1
11FF4  51DC     MOVF 0xDC, W, BANKED
11FF6  A4D8     BTFSS 0xFD8, 2, ACCESS
11FF8  D02D     BRA 0x2054
381:           						lp_filter(0.0, i, -1);
11FFA  0EFF     MOVLW 0xFF
11FFC  6EE6     MOVWF 0xFE6, ACCESS
11FFE  0EFC     MOVLW 0xFC
12000  50E3     MOVF 0xFE3, W, ACCESS
12002  6EE6     MOVWF 0xFE6, ACCESS
12004  0E00     MOVLW 0x0
12006  6EE6     MOVWF 0xFE6, ACCESS
12008  0E00     MOVLW 0x0
1200A  6EE6     MOVWF 0xFE6, ACCESS
1200C  0E00     MOVLW 0x0
1200E  6EE6     MOVWF 0xFE6, ACCESS
12010  0E00     MOVLW 0x0
12012  6EE6     MOVWF 0xFE6, ACCESS
12014  EC3F     CALL 0x1867E, 0
12016  F0C3     NOP
382:           						lp_filter(0.0, j, -1);
12018  0EFF     MOVLW 0xFF
1201A  6EE6     MOVWF 0xFE6, ACCESS
1201C  0EFB     MOVLW 0xFB
1201E  50E3     MOVF 0xFE3, W, ACCESS
12020  6EE6     MOVWF 0xFE6, ACCESS
12022  0E00     MOVLW 0x0
12024  6EE6     MOVWF 0xFE6, ACCESS
12026  0E00     MOVLW 0x0
12028  6EE6     MOVWF 0xFE6, ACCESS
1202A  0E00     MOVLW 0x0
1202C  6EE6     MOVWF 0xFE6, ACCESS
1202E  0E00     MOVLW 0x0
12030  6EE6     MOVWF 0xFE6, ACCESS
12032  EC3F     CALL 0x1867E, 0
12034  F0C3     NOP
383:           						lp_filter(0.0, k, -1);
12036  0EFF     MOVLW 0xFF
12038  6EE6     MOVWF 0xFE6, ACCESS
1203A  0EFA     MOVLW 0xFA
1203C  50E3     MOVF 0xFE3, W, ACCESS
1203E  6EE6     MOVWF 0xFE6, ACCESS
12040  0E00     MOVLW 0x0
12042  6EE6     MOVWF 0xFE6, ACCESS
12044  0E00     MOVLW 0x0
12046  6EE6     MOVWF 0xFE6, ACCESS
12048  0E00     MOVLW 0x0
1204A  6EE6     MOVWF 0xFE6, ACCESS
1204C  0E00     MOVLW 0x0
1204E  6EE6     MOVWF 0xFE6, ACCESS
12050  EC3F     CALL 0x1867E, 0
12052  F0C3     NOP
384:           					}
385:           					V.calib = true;
12054  0E01     MOVLW 0x1
12056  0101     MOVLB 0x1
12058  6FDC     MOVWF 0xDC, BANKED
386:           					sprintf(get_vterm_ptr(0, 0), "%d %2.4f, %d  TRIM   ", get_raw_result(i), C.calc[i], inp_index + 1);
1205A  0EFA     MOVLW 0xFA
1205C  50E3     MOVF 0xFE3, W, ACCESS
1205E  6E0B     MOVWF wtemp5, ACCESS
12060  6A0C     CLRF 0xC, ACCESS
12062  0E01     MOVLW 0x1
12064  260B     ADDWF wtemp5, F, ACCESS
12066  0E00     MOVLW 0x0
12068  220C     ADDWFC 0xC, F, ACCESS
1206C  F02F     NOP
1206E  FFE6     NOP
12072  F033     NOP
12074  FFE6     NOP
12076  0EFB     MOVLW 0xFB
12078  50E3     MOVF 0xFE3, W, ACCESS
1207A  0D04     MULLW 0x4
1207C  0EFF     MOVLW 0xFF
1207E  24F3     ADDWF 0xFF3, W, ACCESS
12080  6ED9     MOVWF 0xFD9, ACCESS
12082  0E06     MOVLW 0x6
12084  20F4     ADDWFC 0xFF4, W, ACCESS
12086  6EDA     MOVWF 0xFDA, ACCESS
1208A  FF7B     NOP
1208C  FFE6     NOP
12090  FF7B     NOP
12092  FFE6     NOP
12096  FF7B     NOP
12098  FFE6     NOP
1209C  FF7B     NOP
1209E  FFE6     NOP
120A0  0EF7     MOVLW 0xF7
120A2  50E3     MOVF 0xFE3, W, ACCESS
120A4  6EE6     MOVWF 0xFE6, ACCESS
120A6  EC22     CALL 0x1BE44, 0
120A8  F0DF     NOP
120AC  F007     NOP
120AE  FFE6     NOP
120B2  F00B     NOP
120B4  FFE6     NOP
120B6  0E8A     MOVLW 0x8A
120B8  6EE6     MOVWF 0xFE6, ACCESS
120BA  0EFE     MOVLW 0xFE
120BC  6EE6     MOVWF 0xFE6, ACCESS
120BE  0E00     MOVLW 0x0
120C0  6EE6     MOVWF 0xFE6, ACCESS
120C2  0E00     MOVLW 0x0
120C4  6EE6     MOVWF 0xFE6, ACCESS
120C6  EC09     CALL 0x1BA12, 0
120C8  F0DD     NOP
120CC  F007     NOP
120CE  FFE6     NOP
120D2  F00B     NOP
120D4  FFE6     NOP
120D6  0E0C     MOVLW 0xC
120D8  6EE6     MOVWF 0xFE6, ACCESS
120DA  EC00     CALL 0x19C00, 0
120DC  F0CE     NOP
387:           					sprintf(get_vterm_ptr(1, 0), "%d %2.4f, %d  TRIM   ", get_raw_result(j), C.calc[j], inp_index + 2);
120DE  0EFA     MOVLW 0xFA
120E0  50E3     MOVF 0xFE3, W, ACCESS
120E2  6E0B     MOVWF wtemp5, ACCESS
120E4  6A0C     CLRF 0xC, ACCESS
120E6  0E02     MOVLW 0x2
120E8  260B     ADDWF wtemp5, F, ACCESS
120EA  0E00     MOVLW 0x0
120EC  220C     ADDWFC 0xC, F, ACCESS
120F0  F02F     NOP
120F2  FFE6     NOP
120F6  F033     NOP
120F8  FFE6     NOP
120FA  0EFA     MOVLW 0xFA
120FC  50E3     MOVF 0xFE3, W, ACCESS
120FE  0D04     MULLW 0x4
12100  0EFF     MOVLW 0xFF
12102  24F3     ADDWF 0xFF3, W, ACCESS
12104  6ED9     MOVWF 0xFD9, ACCESS
12106  0E06     MOVLW 0x6
12108  20F4     ADDWFC 0xFF4, W, ACCESS
1210A  6EDA     MOVWF 0xFDA, ACCESS
1210E  FF7B     NOP
12110  FFE6     NOP
12114  FF7B     NOP
12116  FFE6     NOP
1211A  FF7B     NOP
1211C  FFE6     NOP
12120  FF7B     NOP
12122  FFE6     NOP
12124  0EF6     MOVLW 0xF6
12126  50E3     MOVF 0xFE3, W, ACCESS
12128  6EE6     MOVWF 0xFE6, ACCESS
1212A  EC22     CALL 0x1BE44, 0
1212C  F0DF     NOP
12130  F007     NOP
12132  FFE6     NOP
12136  F00B     NOP
12138  FFE6     NOP
1213A  0E8A     MOVLW 0x8A
1213C  6EE6     MOVWF 0xFE6, ACCESS
1213E  0EFE     MOVLW 0xFE
12140  6EE6     MOVWF 0xFE6, ACCESS
12142  0E00     MOVLW 0x0
12144  6EE6     MOVWF 0xFE6, ACCESS
12146  0E01     MOVLW 0x1
12148  6EE6     MOVWF 0xFE6, ACCESS
1214A  EC09     CALL 0x1BA12, 0
1214C  F0DD     NOP
12150  F007     NOP
12152  FFE6     NOP
12156  F00B     NOP
12158  FFE6     NOP
1215A  0E0C     MOVLW 0xC
1215C  6EE6     MOVWF 0xFE6, ACCESS
1215E  EC00     CALL 0x19C00, 0
12160  F0CE     NOP
388:           					sprintf(get_vterm_ptr(2, 0), "%d %2.4f, %d  TRIM   ", get_raw_result(k), C.calc[k], inp_index + 3);
12162  0EFA     MOVLW 0xFA
12164  50E3     MOVF 0xFE3, W, ACCESS
12166  6E0B     MOVWF wtemp5, ACCESS
12168  6A0C     CLRF 0xC, ACCESS
1216A  0E03     MOVLW 0x3
1216C  260B     ADDWF wtemp5, F, ACCESS
1216E  0E00     MOVLW 0x0
12170  220C     ADDWFC 0xC, F, ACCESS
12174  F02F     NOP
12176  FFE6     NOP
1217A  F033     NOP
1217C  FFE6     NOP
1217E  0EF9     MOVLW 0xF9
12180  50E3     MOVF 0xFE3, W, ACCESS
12182  0D04     MULLW 0x4
12184  0EFF     MOVLW 0xFF
12186  24F3     ADDWF 0xFF3, W, ACCESS
12188  6ED9     MOVWF 0xFD9, ACCESS
1218A  0E06     MOVLW 0x6
1218C  20F4     ADDWFC 0xFF4, W, ACCESS
1218E  6EDA     MOVWF 0xFDA, ACCESS
12192  FF7B     NOP
12194  FFE6     NOP
12198  FF7B     NOP
1219A  FFE6     NOP
1219E  FF7B     NOP
121A0  FFE6     NOP
121A4  FF7B     NOP
121A6  FFE6     NOP
121A8  0EF5     MOVLW 0xF5
121AA  50E3     MOVF 0xFE3, W, ACCESS
121AC  6EE6     MOVWF 0xFE6, ACCESS
121AE  EC22     CALL 0x1BE44, 0
121B0  F0DF     NOP
121B4  F007     NOP
121B6  FFE6     NOP
121BA  F00B     NOP
121BC  FFE6     NOP
121BE  0E8A     MOVLW 0x8A
121C0  6EE6     MOVWF 0xFE6, ACCESS
121C2  0EFE     MOVLW 0xFE
121C4  6EE6     MOVWF 0xFE6, ACCESS
121C6  0E00     MOVLW 0x0
121C8  6EE6     MOVWF 0xFE6, ACCESS
121CA  0E02     MOVLW 0x2
121CC  6EE6     MOVWF 0xFE6, ACCESS
121CE  EC09     CALL 0x1BA12, 0
121D0  F0DD     NOP
121D4  F007     NOP
121D6  FFE6     NOP
121DA  F00B     NOP
121DC  FFE6     NOP
121DE  0E0C     MOVLW 0xC
121E0  6EE6     MOVWF 0xFE6, ACCESS
121E2  EC00     CALL 0x19C00, 0
121E4  F0CE     NOP
389:           					break;
121E6  D016     BRA 0x2214
390:           				default:
391:           					break;
392:           				}
121E8  0100     MOVLB 0x0
121EA  51F7     MOVF H, W, BANKED
121EC  6E0B     MOVWF wtemp5, ACCESS
121EE  6A0C     CLRF 0xC, ACCESS
121F0  500C     MOVF 0xC, W, ACCESS
121F2  0A00     XORLW 0x0
121F4  A4D8     BTFSS 0xFD8, 2, ACCESS
121F6  D00E     BRA 0x2214
121F8  500B     MOVF wtemp5, W, ACCESS
121FA  0A00     XORLW 0x0
121FC  B4D8     BTFSC 0xFD8, 2, ACCESS
121FE  D4D3     BRA 0x1BA6
12200  0A01     XORLW 0x1
12202  B4D8     BTFSC 0xFD8, 2, ACCESS
12204  EFD0     GOTO 0x119A0
12206  F08C     NOP
12208  0A03     XORLW 0x3
1220A  B4D8     BTFSC 0xFD8, 2, ACCESS
1220C  D5E1     BRA 0x1DD0
1220E  0A01     XORLW 0x1
12210  B4D8     BTFSC 0xFD8, 2, ACCESS
12212  D6EF     BRA 0x1FF2
393:           				clear_hid_pflags(&H);
12214  0EF7     MOVLW 0xF7
12216  6EE6     MOVWF 0xFE6, ACCESS
12218  ECB6     CALL 0x1BD6C, 0
1221A  F0DE     NOP
394:           			}
395:           			StartTimer(TMR_DISPLAY, DDELAY);
1221C  0EFA     MOVLW 0xFA
1221E  6EE6     MOVWF 0xFE6, ACCESS
12220  0E00     MOVLW 0x0
12222  6EE6     MOVWF 0xFE6, ACCESS
12224  0E0A     MOVLW 0xA
12226  6EE6     MOVWF 0xFE6, ACCESS
12228  EC65     CALL 0x1B6CA, 0
1222A  F0DB     NOP
396:           			V.enter = check_enter_button(&H);
1222C  0EF7     MOVLW 0xF7
1222E  6EE6     MOVWF 0xFE6, ACCESS
12230  EC85     CALL 0x1B70A, 0
12232  F0DB     NOP
12234  5001     MOVF ltemp0, W, ACCESS
12236  0101     MOVLB 0x1
12238  6FDD     MOVWF 0xDD, BANKED
397:           			if (V.enter && (H.hid_display != HID_AUX)) {
1223A  51DD     MOVF 0xDD, W, BANKED
1223C  B4D8     BTFSC 0xFD8, 2, ACCESS
1223E  D013     BRA 0x2266
12240  0E03     MOVLW 0x3
12242  0100     MOVLB 0x0
12244  19F7     XORWF H, W, BANKED
12246  B4D8     BTFSC 0xFD8, 2, ACCESS
12248  D00E     BRA 0x2266
398:           				V.enter = false;
1224A  0101     MOVLB 0x1
1224C  6BDD     CLRF 0xDD, BANKED
399:           				V.screen = ~V.screen;
1224E  A1CC     BTFSS uart2RxTail, 0, BANKED
12250  D002     BRA 0x2256
12252  0E01     MOVLW 0x1
12254  D001     BRA 0x2258
12256  0E00     MOVLW 0x0
12258  0AFF     XORLW 0xFF
1225A  6E0C     MOVWF 0xC, ACCESS
1225C  51CC     MOVF uart2RxTail, W, BANKED
1225E  180C     XORWF 0xC, W, ACCESS
12260  0BFE     ANDLW 0xFE
12262  180C     XORWF 0xC, W, ACCESS
12264  6FCC     MOVWF uart2RxTail, BANKED
400:           			}
401:           			set_vterm(V.screen);
12266  0101     MOVLB 0x1
12268  A1CC     BTFSS uart2RxTail, 0, BANKED
1226A  D002     BRA 0x2270
1226C  0E01     MOVLW 0x1
1226E  D001     BRA 0x2272
12270  0E00     MOVLW 0x0
12272  6EE6     MOVWF 0xFE6, ACCESS
12274  EC82     CALL 0x1BF04, 0
12276  F0DF     NOP
402:           			update_lcd(V.screen);
12278  0101     MOVLB 0x1
1227A  A1CC     BTFSS uart2RxTail, 0, BANKED
1227C  D002     BRA 0x2282
1227E  0E01     MOVLW 0x1
12280  D001     BRA 0x2284
12282  0E00     MOVLW 0x0
12284  6EE6     MOVWF 0xFE6, ACCESS
12286  EC78     CALL 0x19AF0, 0
12288  F0CD     NOP
403:           		}
404:           
405:           		/*
406:           		 * show help display if button pressed
407:           		 */
408:           		check_help(V.flipper);
1228A  0101     MOVLB 0x1
1228C  51DB     MOVF 0xDB, W, BANKED
1228E  6EE6     MOVWF 0xFE6, ACCESS
12290  EC34     CALL 0x18268, 0
12292  F0C1     NOP
409:           
410:           		if (V.enter) {
12294  0101     MOVLB 0x1
12296  51DD     MOVF 0xDD, W, BANKED
12298  B4D8     BTFSC 0xFD8, 2, ACCESS
1229A  D062     BRA 0x2360
411:           			V.enter = false;
1229C  6BDD     CLRF 0xDD, BANKED
412:           			V.calib = false;
1229E  6BDC     CLRF 0xDC, BANKED
413:           			inp_index += 3;
122A0  0EFA     MOVLW 0xFA
122A4  FF8C     NOP
122A6  F001     NOP
122A8  0E03     MOVLW 0x3
122AA  2601     ADDWF ltemp0, F, ACCESS
122AC  0EFA     MOVLW 0xFA
122B0  F007     NOP
122B2  FFE3     NOP
414:           			if (inp_index > 9)
122B4  0EFA     MOVLW 0xFA
122B8  FF8C     NOP
122BA  F001     NOP
122BC  0E09     MOVLW 0x9
122BE  6401     CPFSGT ltemp0, ACCESS
122C0  D03A     BRA 0x2336
415:           				inp_index = 0;
122C2  0EFA     MOVLW 0xFA
122C4  6AE3     CLRF 0xFE3, ACCESS
122C6  D037     BRA 0x2336
416:           			switch (inp_index) {
417:           			case 0:
418:           				i = C_BATT;
122C8  0EFD     MOVLW 0xFD
122CA  6AE3     CLRF 0xFE3, ACCESS
419:           				j = C_PV;
122CC  0EFC     MOVLW 0xFC
122CE  6AE3     CLRF 0xFE3, ACCESS
122D0  2AE3     INCF 0xFE3, F, ACCESS
420:           				k = V_CC;
122D2  0EFB     MOVLW 0xFB
122D4  6AE3     CLRF 0xFE3, ACCESS
122D6  82E3     BSF 0xFE3, 1, ACCESS
421:           				break;
122D8  D043     BRA 0x2360
422:           			case 3:
423:           				i = V_BAT;
122DA  0EFD     MOVLW 0xFD
122DC  6AE3     CLRF 0xFE3, ACCESS
122DE  84E3     BSF 0xFE3, 2, ACCESS
424:           				j = V_PV;
122E0  0EFC     MOVLW 0xFC
122E2  6AE3     CLRF 0xFE3, ACCESS
122E4  80E3     BSF 0xFE3, 0, ACCESS
122E6  84E3     BSF 0xFE3, 2, ACCESS
425:           				k = V_CBUS;
122E8  0EFB     MOVLW 0xFB
122EA  6AE3     CLRF 0xFE3, ACCESS
122EC  82E3     BSF 0xFE3, 1, ACCESS
122EE  84E3     BSF 0xFE3, 2, ACCESS
426:           				break;
122F0  D037     BRA 0x2360
427:           			case 6:
428:           				i = V_BBAT;
122F2  0EFD     MOVLW 0xFD
122F4  6AE3     CLRF 0xFE3, ACCESS
122F6  82E3     BSF 0xFE3, 1, ACCESS
122F8  86E3     BSF 0xFE3, 3, ACCESS
429:           				j = V_TEMP;
122FA  0E0B     MOVLW 0xB
122FC  6E0C     MOVWF 0xC, ACCESS
122FE  0EFC     MOVLW 0xFC
12302  F033     NOP
12304  FFE3     NOP
430:           				k = V_INVERTER;
12306  0EFB     MOVLW 0xFB
12308  6AE3     CLRF 0xFE3, ACCESS
1230A  84E3     BSF 0xFE3, 2, ACCESS
1230C  86E3     BSF 0xFE3, 3, ACCESS
431:           				break;
1230E  D028     BRA 0x2360
432:           			case 9:
433:           				i = V_LIGHT_SENSOR;
12310  0E0D     MOVLW 0xD
12312  6E0C     MOVWF 0xC, ACCESS
12314  0EFD     MOVLW 0xFD
12318  F033     NOP
1231A  FFE3     NOP
434:           				j = V_LIGHT_SENSOR;
1231C  0E0D     MOVLW 0xD
1231E  6E0C     MOVWF 0xC, ACCESS
12320  0EFC     MOVLW 0xFC
12324  F033     NOP
12326  FFE3     NOP
435:           				k = V_LIGHT_SENSOR;
12328  0E0D     MOVLW 0xD
1232A  6E0C     MOVWF 0xC, ACCESS
1232C  0EFB     MOVLW 0xFB
12330  F033     NOP
12332  FFE3     NOP
436:           				break;
12334  D015     BRA 0x2360
437:           			default:
438:           				break;
439:           			}
12336  0EFA     MOVLW 0xFA
12338  50E3     MOVF 0xFE3, W, ACCESS
1233A  6E0B     MOVWF wtemp5, ACCESS
1233C  6A0C     CLRF 0xC, ACCESS
1233E  500C     MOVF 0xC, W, ACCESS
12340  0A00     XORLW 0x0
12342  A4D8     BTFSS 0xFD8, 2, ACCESS
12344  D00D     BRA 0x2360
12346  500B     MOVF wtemp5, W, ACCESS
12348  0A00     XORLW 0x0
1234A  B4D8     BTFSC 0xFD8, 2, ACCESS
1234C  D7BD     BRA 0x22C8
1234E  0A03     XORLW 0x3
12350  B4D8     BTFSC 0xFD8, 2, ACCESS
12352  D7C3     BRA 0x22DA
12354  0A05     XORLW 0x5
12356  B4D8     BTFSC 0xFD8, 2, ACCESS
12358  D7CC     BRA 0x22F2
1235A  0A0F     XORLW 0xF
1235C  B4D8     BTFSC 0xFD8, 2, ACCESS
1235E  D7D8     BRA 0x2310
440:           		};
441:           
442:           		/*
443:           		 * show command messages if flag is set for timer duration
444:           		 */
445:           		if (V.set_sequ) {
12360  A1CB     BTFSS uart2RxCount, 0, BANKED
12362  EF84     GOTO 0x11908
12364  F08C     NOP
446:           			if (TimerDone(TMR_INFO)) {
12366  0E07     MOVLW 0x7
12368  6EE6     MOVWF 0xFE6, ACCESS
1236A  EC8B     CALL 0x1BB16, 0
1236C  F0DD     NOP
1236E  5001     MOVF ltemp0, W, ACCESS
12370  B4D8     BTFSC 0xFD8, 2, ACCESS
12372  D00C     BRA 0x238C
447:           				V.set_sequ = false;
12374  0101     MOVLB 0x1
12376  91CB     BCF uart2RxCount, 0, BANKED
448:           				set_vterm(0);
12378  0E00     MOVLW 0x0
1237A  6EE6     MOVWF 0xFE6, ACCESS
1237C  EC82     CALL 0x1BF04, 0
1237E  F0DF     NOP
449:           				update_lcd(0);
12380  0E00     MOVLW 0x0
12382  6EE6     MOVWF 0xFE6, ACCESS
12384  EC78     CALL 0x19AF0, 0
12386  F0CD     NOP
450:           			} else {
12388  EF84     GOTO 0x11908
1238A  F08C     NOP
451:           				set_vterm(2);
1238C  0E02     MOVLW 0x2
1238E  6EE6     MOVWF 0xFE6, ACCESS
12390  EC82     CALL 0x1BF04, 0
12392  F0DF     NOP
452:           				update_lcd(2);
12394  0E02     MOVLW 0x2
12396  6EE6     MOVWF 0xFE6, ACCESS
12398  EC78     CALL 0x19AF0, 0
1239A  F0CD     NOP
1239C  EF84     GOTO 0x11908
1239E  F08C     NOP
453:           			}
454:           		}
455:           	}
456:           }
457:           
458:           /**
459:            End of File
460:            */
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/hid.c  ---------------------------------------------------
1:             #include "hid.h"
2:             
3:             H_data* hid_input(H_data* h)
4:             {
5:             	if (get_switch(SSELECT)) {
1AB3C  0E02     MOVLW 0x2
1AB3E  6EE6     MOVWF 0xFE6, ACCESS
1AB40  EC20     CALL 0x1BA40, 0
1AB42  F0DD     NOP
1AB44  5001     MOVF ltemp0, W, ACCESS
1AB46  B4D8     BTFSC 0xFD8, 2, ACCESS
1AB48  D01C     BRA 0xAB82
6:             		h->wait_select = false;
1AB4A  0EFF     MOVLW 0xFF
1AB4C  50E3     MOVF 0xFE3, W, ACCESS
1AB4E  6ED9     MOVWF 0xFD9, ACCESS
1AB50  6ADA     CLRF 0xFDA, ACCESS
1AB52  0E02     MOVLW 0x2
1AB54  26D9     ADDWF 0xFD9, F, ACCESS
1AB56  0E00     MOVLW 0x0
1AB58  6EDF     MOVWF 0xFDF, ACCESS
7:             		h->select_p = get_switch(SSELECT);
1AB5A  0E02     MOVLW 0x2
1AB5C  6EE6     MOVWF 0xFE6, ACCESS
1AB5E  EC20     CALL 0x1BA40, 0
1AB60  F0DD     NOP
1AB62  5001     MOVF ltemp0, W, ACCESS
1AB64  B4D8     BTFSC 0xFD8, 2, ACCESS
1AB66  D003     BRA 0xAB6E
1AB68  6A0C     CLRF 0xC, ACCESS
1AB6A  2A0C     INCF 0xC, F, ACCESS
1AB6C  D001     BRA 0xAB70
1AB6E  6A0C     CLRF 0xC, ACCESS
1AB70  0EFF     MOVLW 0xFF
1AB72  50E3     MOVF 0xFE3, W, ACCESS
1AB74  6ED9     MOVWF 0xFD9, ACCESS
1AB76  6ADA     CLRF 0xFDA, ACCESS
1AB78  0E03     MOVLW 0x3
1AB7A  26D9     ADDWF 0xFD9, F, ACCESS
1AB7E  F033     NOP
1AB80  FFDF     NOP
8:             	}
9:             
10:            	if (get_switch(SENTER)) {
1AB82  0E03     MOVLW 0x3
1AB84  6EE6     MOVWF 0xFE6, ACCESS
1AB86  EC20     CALL 0x1BA40, 0
1AB88  F0DD     NOP
1AB8A  5001     MOVF ltemp0, W, ACCESS
1AB8C  B4D8     BTFSC 0xFD8, 2, ACCESS
1AB8E  D01C     BRA 0xABC8
11:            		h->wait_enter = false;
1AB90  0EFF     MOVLW 0xFF
1AB92  50E3     MOVF 0xFE3, W, ACCESS
1AB94  6ED9     MOVWF 0xFD9, ACCESS
1AB96  6ADA     CLRF 0xFDA, ACCESS
1AB98  0E04     MOVLW 0x4
1AB9A  26D9     ADDWF 0xFD9, F, ACCESS
1AB9C  0E00     MOVLW 0x0
1AB9E  6EDF     MOVWF 0xFDF, ACCESS
12:            		h->enter_p = get_switch(SENTER);
1ABA0  0E03     MOVLW 0x3
1ABA2  6EE6     MOVWF 0xFE6, ACCESS
1ABA4  EC20     CALL 0x1BA40, 0
1ABA6  F0DD     NOP
1ABA8  5001     MOVF ltemp0, W, ACCESS
1ABAA  B4D8     BTFSC 0xFD8, 2, ACCESS
1ABAC  D003     BRA 0xABB4
1ABAE  6A0C     CLRF 0xC, ACCESS
1ABB0  2A0C     INCF 0xC, F, ACCESS
1ABB2  D001     BRA 0xABB6
1ABB4  6A0C     CLRF 0xC, ACCESS
1ABB6  0EFF     MOVLW 0xFF
1ABB8  50E3     MOVF 0xFE3, W, ACCESS
1ABBA  6ED9     MOVWF 0xFD9, ACCESS
1ABBC  6ADA     CLRF 0xFDA, ACCESS
1ABBE  0E05     MOVLW 0x5
1ABC0  26D9     ADDWF 0xFD9, F, ACCESS
1ABC4  F033     NOP
1ABC6  FFDF     NOP
13:            	}
14:            	return h;
15:            }
1ABC8  52E5     MOVF 0xFE5, F, ACCESS
1ABCA  0012     RETURN 0
16:            
17:            H_data* hid_display(H_data* h)
18:            {
19:            	hid_input(h);
19D0A  0EFF     MOVLW 0xFF
19D0C  50E3     MOVF 0xFE3, W, ACCESS
19D0E  6EE6     MOVWF 0xFE6, ACCESS
19D10  EC9E     CALL 0x1AB3C, 0
19D12  F0D5     NOP
20:            
21:            	switch (h->h_state) {
19D14  D066     BRA 0x9DE2
22:            	case H_STATE_INIT:
23:            		h->h_state = H_STATE_DISPLAY;
19D16  0EFF     MOVLW 0xFF
19D18  50E3     MOVF 0xFE3, W, ACCESS
19D1A  6ED9     MOVWF 0xFD9, ACCESS
19D1C  6ADA     CLRF 0xFDA, ACCESS
19D1E  0E01     MOVLW 0x1
19D20  26D9     ADDWF 0xFD9, F, ACCESS
19D22  0E01     MOVLW 0x1
19D24  6EDF     MOVWF 0xFDF, ACCESS
24:            		h->hid_display = HID_MAIN;
19D26  0EFF     MOVLW 0xFF
19D28  50E3     MOVF 0xFE3, W, ACCESS
19D2A  6ED9     MOVWF 0xFD9, ACCESS
19D2C  6ADA     CLRF 0xFDA, ACCESS
19D2E  0E00     MOVLW 0x0
19D30  6EDF     MOVWF 0xFDF, ACCESS
25:            		h->wait_enter = true;
19D32  0EFF     MOVLW 0xFF
19D34  50E3     MOVF 0xFE3, W, ACCESS
19D36  6ED9     MOVWF 0xFD9, ACCESS
19D38  6ADA     CLRF 0xFDA, ACCESS
19D3A  0E04     MOVLW 0x4
19D3C  26D9     ADDWF 0xFD9, F, ACCESS
19D3E  0E01     MOVLW 0x1
19D40  6EDF     MOVWF 0xFDF, ACCESS
26:            		h->wait_select = true;
19D42  0EFF     MOVLW 0xFF
19D44  50E3     MOVF 0xFE3, W, ACCESS
19D46  6ED9     MOVWF 0xFD9, ACCESS
19D48  6ADA     CLRF 0xFDA, ACCESS
19D4A  0E02     MOVLW 0x2
19D4C  26D9     ADDWF 0xFD9, F, ACCESS
19D4E  0E01     MOVLW 0x1
19D50  6EDF     MOVWF 0xFDF, ACCESS
27:            		h->select_p = SW_OFF;
19D52  0EFF     MOVLW 0xFF
19D54  50E3     MOVF 0xFE3, W, ACCESS
19D56  6ED9     MOVWF 0xFD9, ACCESS
19D58  6ADA     CLRF 0xFDA, ACCESS
19D5A  0E03     MOVLW 0x3
19D5C  26D9     ADDWF 0xFD9, F, ACCESS
19D5E  0E00     MOVLW 0x0
19D60  6EDF     MOVWF 0xFDF, ACCESS
28:            		h->enter_p = SW_OFF;
19D62  0EFF     MOVLW 0xFF
19D64  50E3     MOVF 0xFE3, W, ACCESS
19D66  6ED9     MOVWF 0xFD9, ACCESS
19D68  6ADA     CLRF 0xFDA, ACCESS
19D6A  0E05     MOVLW 0x5
19D6C  26D9     ADDWF 0xFD9, F, ACCESS
19D6E  0E00     MOVLW 0x0
19D70  D036     BRA 0x9DDE
29:            		break;
30:            	default:
31:            	case H_STATE_DISPLAY:
32:            		if (!h->wait_select && (h->select_p == SW_OFF)) {
19D72  0EFF     MOVLW 0xFF
19D74  50E3     MOVF 0xFE3, W, ACCESS
19D76  6ED9     MOVWF 0xFD9, ACCESS
19D78  6ADA     CLRF 0xFDA, ACCESS
19D7A  0E02     MOVLW 0x2
19D7C  26D9     ADDWF 0xFD9, F, ACCESS
19D7E  50DF     MOVF 0xFDF, W, ACCESS
19D80  A4D8     BTFSS 0xFD8, 2, ACCESS
19D82  D042     BRA 0x9E08
19D84  0EFF     MOVLW 0xFF
19D86  50E3     MOVF 0xFE3, W, ACCESS
19D88  6ED9     MOVWF 0xFD9, ACCESS
19D8A  6ADA     CLRF 0xFDA, ACCESS
19D8C  0E03     MOVLW 0x3
19D8E  26D9     ADDWF 0xFD9, F, ACCESS
19D90  50DF     MOVF 0xFDF, W, ACCESS
19D92  A4D8     BTFSS 0xFD8, 2, ACCESS
19D94  D039     BRA 0x9E08
33:            			h->sequence = ++h->sequence & 0x3;
19D96  0EFF     MOVLW 0xFF
19D98  50E3     MOVF 0xFE3, W, ACCESS
19D9A  6ED9     MOVWF 0xFD9, ACCESS
19D9C  6ADA     CLRF 0xFDA, ACCESS
19D9E  0E06     MOVLW 0x6
19DA0  26D9     ADDWF 0xFD9, F, ACCESS
19DA2  0EFF     MOVLW 0xFF
19DA4  50E3     MOVF 0xFE3, W, ACCESS
19DA6  6EE9     MOVWF 0xFE9, ACCESS
19DA8  6AEA     CLRF 0xFEA, ACCESS
19DAA  0E06     MOVLW 0x6
19DAC  26E9     ADDWF 0xFE9, F, ACCESS
19DAE  2AEF     INCF 0xFEF, F, ACCESS
19DB0  50EF     MOVF 0xFEF, W, ACCESS
19DB2  0B03     ANDLW 0x3
19DB4  6EDF     MOVWF 0xFDF, ACCESS
34:            			h->hid_display = h->sequence;
19DB6  0EFF     MOVLW 0xFF
19DB8  50E3     MOVF 0xFE3, W, ACCESS
19DBA  6ED9     MOVWF 0xFD9, ACCESS
19DBC  6ADA     CLRF 0xFDA, ACCESS
19DBE  0E06     MOVLW 0x6
19DC0  26D9     ADDWF 0xFD9, F, ACCESS
19DC2  0EFF     MOVLW 0xFF
19DC4  50E3     MOVF 0xFE3, W, ACCESS
19DC6  6EE9     MOVWF 0xFE9, ACCESS
19DC8  6AEA     CLRF 0xFEA, ACCESS
19DCC  FF7F     NOP
19DCE  FFEF     NOP
35:            			h->wait_select = true;
19DD0  0EFF     MOVLW 0xFF
19DD2  50E3     MOVF 0xFE3, W, ACCESS
19DD4  6ED9     MOVWF 0xFD9, ACCESS
19DD6  6ADA     CLRF 0xFDA, ACCESS
19DD8  0E02     MOVLW 0x2
19DDA  26D9     ADDWF 0xFD9, F, ACCESS
19DDC  0E01     MOVLW 0x1
19DDE  6EDF     MOVWF 0xFDF, ACCESS
19DE0  D013     BRA 0x9E08
36:            		}
37:            		break;
38:            	}
19DE2  0EFF     MOVLW 0xFF
19DE4  50E3     MOVF 0xFE3, W, ACCESS
19DE6  6ED9     MOVWF 0xFD9, ACCESS
19DE8  6ADA     CLRF 0xFDA, ACCESS
19DEA  0E01     MOVLW 0x1
19DEC  26D9     ADDWF 0xFD9, F, ACCESS
19DEE  50DF     MOVF 0xFDF, W, ACCESS
19DF0  6E0B     MOVWF wtemp5, ACCESS
19DF2  6A0C     CLRF 0xC, ACCESS
19DF4  500C     MOVF 0xC, W, ACCESS
19DF6  0A00     XORLW 0x0
19DF8  A4D8     BTFSS 0xFD8, 2, ACCESS
19DFA  D7BB     BRA 0x9D72
19DFC  500B     MOVF wtemp5, W, ACCESS
19DFE  0A00     XORLW 0x0
19E00  B4D8     BTFSC 0xFD8, 2, ACCESS
19E02  D789     BRA 0x9D16
19E04  0A01     XORLW 0x1
19E06  D7B5     BRA 0x9D72
39:            	return h;
40:            }
19E08  52E5     MOVF 0xFE5, F, ACCESS
19E0A  0012     RETURN 0
41:            
42:            bool check_enter_button(H_data* h)
43:            {
44:            	if (!h->wait_enter && (h->enter_p == SW_OFF)) {
1B70A  0EFF     MOVLW 0xFF
1B70C  50E3     MOVF 0xFE3, W, ACCESS
1B70E  6ED9     MOVWF 0xFD9, ACCESS
1B710  6ADA     CLRF 0xFDA, ACCESS
1B712  0E04     MOVLW 0x4
1B714  26D9     ADDWF 0xFD9, F, ACCESS
1B716  50DF     MOVF 0xFDF, W, ACCESS
1B718  A4D8     BTFSS 0xFD8, 2, ACCESS
1B71A  D013     BRA 0xB742
1B71C  0EFF     MOVLW 0xFF
1B71E  50E3     MOVF 0xFE3, W, ACCESS
1B720  6ED9     MOVWF 0xFD9, ACCESS
1B722  6ADA     CLRF 0xFDA, ACCESS
1B724  0E05     MOVLW 0x5
1B726  26D9     ADDWF 0xFD9, F, ACCESS
1B728  50DF     MOVF 0xFDF, W, ACCESS
1B72A  A4D8     BTFSS 0xFD8, 2, ACCESS
1B72C  D00A     BRA 0xB742
45:            		h->wait_enter = true;
1B72E  0EFF     MOVLW 0xFF
1B730  50E3     MOVF 0xFE3, W, ACCESS
1B732  6ED9     MOVWF 0xFD9, ACCESS
1B734  6ADA     CLRF 0xFDA, ACCESS
1B736  0E04     MOVLW 0x4
1B738  26D9     ADDWF 0xFD9, F, ACCESS
1B73A  0E01     MOVLW 0x1
1B73C  6EDF     MOVWF 0xFDF, ACCESS
46:            		return true;
1B73E  0E01     MOVLW 0x1
1B740  D001     BRA 0xB744
47:            	}
48:            	return false;
1B742  0E00     MOVLW 0x0
1B744  6E01     MOVWF ltemp0, ACCESS
49:            }
1B746  52E5     MOVF 0xFE5, F, ACCESS
1B748  0012     RETURN 0
50:            
51:            void clear_hid_pflags(H_data* h)
52:            {
53:            	h->select_p = SW_OFF;
1BD6C  0EFF     MOVLW 0xFF
1BD6E  50E3     MOVF 0xFE3, W, ACCESS
1BD70  6ED9     MOVWF 0xFD9, ACCESS
1BD72  6ADA     CLRF 0xFDA, ACCESS
1BD74  0E03     MOVLW 0x3
1BD76  26D9     ADDWF 0xFD9, F, ACCESS
1BD78  0E00     MOVLW 0x0
1BD7A  6EDF     MOVWF 0xFDF, ACCESS
54:            	h->enter_p = SW_OFF;
1BD7C  0EFF     MOVLW 0xFF
1BD7E  50E3     MOVF 0xFE3, W, ACCESS
1BD80  6ED9     MOVWF 0xFD9, ACCESS
1BD82  6ADA     CLRF 0xFDA, ACCESS
1BD84  0E05     MOVLW 0x5
1BD86  26D9     ADDWF 0xFD9, F, ACCESS
1BD88  0E00     MOVLW 0x0
1BD8A  6EDF     MOVWF 0xFDF, ACCESS
55:            }
1BD8C  52E5     MOVF 0xFE5, F, ACCESS
1BD8E  0012     RETURN 0
56:            
57:            void clear_hid_wflags(H_data* h)
58:            {
59:            	h->wait_enter = true;
60:            	h->wait_select = true;
61:            }
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/eadog.c  -------------------------------------------------
1:             #include "vconfig.h"
2:             #include "eadog.h"
3:             #include "ringbufs.h"
4:             #include <stdio.h>
5:             #include <string.h>
6:             
7:             
8:             
9:             #define max_strlen	64
10:            #define max_port_data	512
11:            
12:            struct spi_link_type spi_link;
13:            struct ringBufS_t ring_buf1;
14:            struct ringBufS_t ring_buf2;
15:            static uint8_t port_data[max_port_data] = {255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0, 255, 0};
16:            
17:            extern struct V_data V;
18:            
19:            static void send_lcd_cmd_long(uint8_t); // for display init only
20:            static void send_lcd_data(uint8_t);
21:            static void send_lcd_cmd(uint8_t);
22:            
23:            void wdtdelay(const uint32_t delay)
24:            {
25:            	static uint32_t dcount;
26:            
27:            	for (dcount = 0; dcount <= delay; dcount++) { // delay a bit
1B1DE  0100     MOVLB 0x0
1B1E0  6B9A     CLRF dcount, BANKED
1B1E2  6B9B     CLRF 0x9B, BANKED
1B1E4  6B9C     CLRF 0x9C, BANKED
1B1E6  6B9D     CLRF 0x9D, BANKED
28:            		Nop();
1B1E8  F000     NOP
29:            		ClrWdt(); // reset the WDT timer
1B1EA  0004     CLRWDT
30:            	};
1B1EC  0E01     MOVLW 0x1
1B1EE  0100     MOVLB 0x0
1B1F0  279A     ADDWF dcount, F, BANKED
1B1F2  0E00     MOVLW 0x0
1B1F4  239B     ADDWFC 0x9B, F, BANKED
1B1F6  239C     ADDWFC 0x9C, F, BANKED
1B1F8  239D     ADDWFC 0x9D, F, BANKED
1B1FA  0EFC     MOVLW 0xFC
1B1FE  FF8C     NOP
1B200  F001     NOP
1B202  519A     MOVF dcount, W, BANKED
1B204  5C01     SUBWF ltemp0, W, ACCESS
1B206  0EFD     MOVLW 0xFD
1B20A  FF8C     NOP
1B20C  F001     NOP
1B20E  519B     MOVF 0x9B, W, BANKED
1B210  5801     SUBWFB ltemp0, W, ACCESS
1B212  0EFE     MOVLW 0xFE
1B216  FF8C     NOP
1B218  F001     NOP
1B21A  519C     MOVF 0x9C, W, BANKED
1B21C  5801     SUBWFB ltemp0, W, ACCESS
1B21E  0EFF     MOVLW 0xFF
1B222  FF8C     NOP
1B224  F001     NOP
1B226  519D     MOVF 0x9D, W, BANKED
1B228  5801     SUBWFB ltemp0, W, ACCESS
1B22A  B0D8     BTFSC 0xFD8, 0, ACCESS
1B22C  D7DD     BRA 0xB1E8
31:            
32:            }
1B22E  52E5     MOVF 0xFE5, F, ACCESS
1B230  52E5     MOVF 0xFE5, F, ACCESS
1B232  52E5     MOVF 0xFE5, F, ACCESS
1B234  52E5     MOVF 0xFE5, F, ACCESS
1B236  0012     RETURN 0
33:            
34:            /*
35:             * Init the EA DOGM163 in 8-bit serial mode
36:             * channel 1 DMA
37:             */
38:            void init_display(void)
39:            {
40:            	spi_link.tx1a = &ring_buf1;
19EFC  0E83     MOVLW 0x83
19EFE  0100     MOVLB 0x0
19F00  6F66     MOVWF 0x66, BANKED
19F02  0E03     MOVLW 0x3
19F04  6F67     MOVWF 0x67, BANKED
41:            	spi_link.tx1b = &ring_buf2;
19F06  0E40     MOVLW 0x40
19F08  6F64     MOVWF 0x64, BANKED
19F0A  0E03     MOVLW 0x3
19F0C  6F65     MOVWF 0x65, BANKED
42:            	ringBufS_init(spi_link.tx1a);
19F10  F19B     NOP
19F12  FFE6     NOP
19F16  F19F     NOP
19F18  FFE6     NOP
19F1A  EC77     CALL 0x1BAEE, 0
19F1C  F0DD     NOP
43:            	ringBufS_init(spi_link.tx1b);
19F20  F193     NOP
19F22  FFE6     NOP
19F26  F197     NOP
19F28  FFE6     NOP
19F2A  EC77     CALL 0x1BAEE, 0
19F2C  F0DD     NOP
44:            
45:            	DLED = true;
19F2E  84BE     BSF 0xFBE, 2, ACCESS
46:            #ifdef NHD
47:            	SPI1CON0bits.EN = 0;
19F30  013D     MOVLB 0x3D
19F32  9F14     BCF 0x14, 7, BANKED
48:            	// mode 3
49:            	SPI1CON1 = 0x20;
19F34  0E20     MOVLW 0x20
19F36  6F15     MOVWF 0x15, BANKED
50:            	// SSET disabled; RXR suspended if the RxFIFO is full; TXR required for a transfer; 
51:            	SPI1CON2 = 0x03;
19F38  0E03     MOVLW 0x3
19F3A  6F16     MOVWF 0x16, BANKED
52:            	// BAUD 0; 
53:            	SPI1BAUD = 0x04; // 50kHz SCK
19F3C  0E04     MOVLW 0x4
19F3E  6F19     MOVWF lltemp3, BANKED
54:            	// CLKSEL MFINTOSC; 
55:            	SPI1CLK = 0x02;
19F40  0E02     MOVLW 0x2
19F42  6F1C     MOVWF 0x1C, BANKED
56:            	// BMODE every byte; LSBF MSb first; EN enabled; MST bus master; 
57:            	SPI1CON0 = 0x83;
19F44  0E83     MOVLW 0x83
19F46  6F14     MOVWF 0x14, BANKED
58:            	SPI1CON0bits.EN = 1;
19F48  8F14     BSF 0x14, 7, BANKED
59:            
60:            	wdtdelay(350000); // > 400ms power up delay
19F4A  0E30     MOVLW 0x30
19F4C  6EE6     MOVWF 0xFE6, ACCESS
19F4E  0E57     MOVLW 0x57
19F50  6EE6     MOVWF 0xFE6, ACCESS
19F52  0E05     MOVLW 0x5
19F54  6EE6     MOVWF 0xFE6, ACCESS
19F56  0E00     MOVLW 0x0
19F58  6EE6     MOVWF 0xFE6, ACCESS
19F5A  ECEF     CALL 0x1B1DE, 0
19F5C  F0D8     NOP
61:            	send_lcd_cmd_long(0x46); // home cursor
19F5E  0E46     MOVLW 0x46
19F60  6EE6     MOVWF 0xFE6, ACCESS
19F62  EC25     CALL 0x1B64A, 0
19F64  F0DB     NOP
62:            	send_lcd_cmd(0x41); // display on
19F66  0E41     MOVLW 0x41
19F68  6EE6     MOVWF 0xFE6, ACCESS
19F6A  EC45     CALL 0x1B68A, 0
19F6C  F0DB     NOP
63:            	wdtdelay(80);
19F6E  0E50     MOVLW 0x50
19F70  6EE6     MOVWF 0xFE6, ACCESS
19F72  0E00     MOVLW 0x0
19F74  6EE6     MOVWF 0xFE6, ACCESS
19F76  0E00     MOVLW 0x0
19F78  6EE6     MOVWF 0xFE6, ACCESS
19F7A  0E00     MOVLW 0x0
19F7C  6EE6     MOVWF 0xFE6, ACCESS
19F7E  ECEF     CALL 0x1B1DE, 0
19F80  F0D8     NOP
64:            	send_lcd_cmd(0x53); // set back-light level
19F82  0E53     MOVLW 0x53
19F84  6EE6     MOVWF 0xFE6, ACCESS
19F86  EC45     CALL 0x1B68A, 0
19F88  F0DB     NOP
65:            	send_lcd_data(NHD_BL_LOW);
19F8A  0E02     MOVLW 0x2
19F8C  6EE6     MOVWF 0xFE6, ACCESS
19F8E  ECA4     CALL 0x1BD48, 0
19F90  F0DE     NOP
66:            	wdtdelay(80);
19F92  0E50     MOVLW 0x50
19F94  6EE6     MOVWF 0xFE6, ACCESS
19F96  0E00     MOVLW 0x0
19F98  6EE6     MOVWF 0xFE6, ACCESS
19F9A  0E00     MOVLW 0x0
19F9C  6EE6     MOVWF 0xFE6, ACCESS
19F9E  0E00     MOVLW 0x0
19FA0  6EE6     MOVWF 0xFE6, ACCESS
19FA2  ECEF     CALL 0x1B1DE, 0
19FA4  F0D8     NOP
67:            	send_lcd_cmd_long(0x51); // clear screen
19FA6  0E51     MOVLW 0x51
19FA8  6EE6     MOVWF 0xFE6, ACCESS
19FAA  EC25     CALL 0x1B64A, 0
19FAC  F0DB     NOP
68:            	SPI1CON0bits.EN = 0;
19FAE  013D     MOVLB 0x3D
19FB0  9F14     BCF 0x14, 7, BANKED
69:            	SPI1CON2 = 0x02; //  Received data is not stored in the FIFO
19FB2  0E02     MOVLW 0x2
19FB4  6F16     MOVWF 0x16, BANKED
70:            	SPI1CON0bits.EN = 1;
19FB6  8F14     BSF 0x14, 7, BANKED
71:            #else
72:            	CSB_SetHigh();
73:            	wdtdelay(350000); // > 400ms power up delay
74:            	send_lcd_cmd(0x39);
75:            	send_lcd_cmd(0x1d);
76:            	send_lcd_cmd(0x50);
77:            	send_lcd_cmd(0x6c);
78:            	send_lcd_cmd(0x76); // contrast last 4 bits
79:            	send_lcd_cmd_long(0x38); // follower control
80:            	send_lcd_cmd(0x0f);
81:            	send_lcd_cmd_long(0x01); // clear
82:            	send_lcd_cmd(0x02);
83:            	send_lcd_cmd(0x06);
84:            	wdtdelay(30);
85:            	SPI1CON2 = 0x02;
86:            	SPI1CON1 = 0x40;
87:            	SPI1CON0 = 0x83;
88:            #endif
89:            	SPI1INTFbits.SPI1TXUIF = 0;
19FB8  931A     BCF 0x1A, 1, BANKED
90:            	DMA1CON1bits.DMODE = 0;
19FBA  0E3F     MOVLW 0x3F
19FBC  013B     MOVLB 0x3B
19FBE  17FD     ANDWF 0xFD, F, BANKED
91:            	DMA1CON1bits.DSTP = 0;
19FC0  9BFD     BCF 0xFD, 5, BANKED
92:            	DMA1CON1bits.SMODE = 1;
19FC2  51FD     MOVF 0xFD, W, BANKED
19FC4  0BF9     ANDLW 0xF9
19FC6  0902     IORLW 0x2
19FC8  6FFD     MOVWF 0xFD, BANKED
93:            	DMA1CON1bits.SMR = 0;
19FCA  0EE7     MOVLW 0xE7
19FCC  17FD     ANDWF 0xFD, F, BANKED
94:            	DMA1CON1bits.SSTP = 1;
19FCE  81FD     BSF 0xFD, 0, BANKED
95:            	DMA1SSA = (uint32_t) & ring_buf1;
19FD0  0E83     MOVLW 0x83
19FD2  6FF9     MOVWF 0xF9, BANKED
19FD4  0E03     MOVLW 0x3
19FD6  6FFA     MOVWF 0xFA, BANKED
19FD8  0E00     MOVLW 0x0
19FDA  6FFB     MOVWF 0xFB, BANKED
96:            	DMA1CON0bits.DGO = 0;
19FDC  9BFC     BCF 0xFC, 5, BANKED
97:            	SPI1INTFbits.SPI1TXUIF = 1;
19FDE  013D     MOVLB 0x3D
19FE0  831A     BSF 0x1A, 1, BANKED
98:            	DLED = false;
19FE2  94BE     BCF 0xFBE, 2, ACCESS
99:            }
19FE4  0012     RETURN 0
100:           
101:           /*
102:            * channel 2 DMA, serial port 1 transmit
103:            */
104:           void init_port_dma(void)
105:           {
106:           	DMA2CON1bits.DMODE = 0;
1B952  0E3F     MOVLW 0x3F
1B954  013B     MOVLB 0x3B
1B956  17DD     ANDWF 0xDD, F, BANKED
107:           	DMA2CON1bits.DSTP = 0;
1B958  9BDD     BCF 0xDD, 5, BANKED
108:           	DMA2CON1bits.SMODE = 1;
1B95A  51DD     MOVF 0xDD, W, BANKED
1B95C  0BF9     ANDLW 0xF9
1B95E  0902     IORLW 0x2
1B960  6FDD     MOVWF 0xDD, BANKED
109:           	DMA2CON1bits.SMR = 0;
1B962  0EE7     MOVLW 0xE7
1B964  17DD     ANDWF 0xDD, F, BANKED
110:           	DMA2CON1bits.SSTP = 1;
1B966  81DD     BSF 0xDD, 0, BANKED
111:           	DMA2CON0bits.SIRQEN = 0;
1B968  9DDC     BCF 0xDC, 6, BANKED
112:           	DMA2DSA = 0x3DEA; // U1TXB SERIAL PORT 1
1B96A  0E3D     MOVLW 0x3D
1B96C  6FD1     MOVWF 0xD1, BANKED
1B96E  0EEA     MOVLW 0xEA
1B970  6FD0     MOVWF 0xD0, BANKED
113:           	DMA2SSA = (uint32_t) port_data;
1B972  0EFF     MOVLW 0xFF
1B974  6FD9     MOVWF 0xD9, BANKED
1B976  0E04     MOVLW 0x4
1B978  6FDA     MOVWF 0xDA, BANKED
1B97A  0E00     MOVLW 0x0
1B97C  6FDB     MOVWF 0xDB, BANKED
114:           	DMA2CON0bits.DGO = 0;
1B97E  9BDC     BCF 0xDC, 5, BANKED
115:           }
1B980  0012     RETURN 0
116:           
117:           #ifdef NHD
118:           
119:           /*
120:            * R2 short on LCD board
121:            */
122:           
123:           static void send_lcd_data(const uint8_t data)
124:           {
125:           	CSB_SetLow();
1BD48  94BC     BCF 0xFBC, 2, ACCESS
126:           	SPI1_Exchange8bit(data);
1BD4A  0EFF     MOVLW 0xFF
1BD4C  50E3     MOVF 0xFE3, W, ACCESS
1BD4E  6EE6     MOVWF 0xFE6, ACCESS
1BD50  EC64     CALL 0x1BEC8, 0
1BD52  F0DF     NOP
127:           	wdtdelay(8);
1BD54  0E08     MOVLW 0x8
1BD56  6EE6     MOVWF 0xFE6, ACCESS
1BD58  0E00     MOVLW 0x0
1BD5A  6EE6     MOVWF 0xFE6, ACCESS
1BD5C  0E00     MOVLW 0x0
1BD5E  6EE6     MOVWF 0xFE6, ACCESS
1BD60  0E00     MOVLW 0x0
1BD62  6EE6     MOVWF 0xFE6, ACCESS
1BD64  ECEF     CALL 0x1B1DE, 0
1BD66  F0D8     NOP
128:           }
1BD68  52E5     MOVF 0xFE5, F, ACCESS
1BD6A  0012     RETURN 0
129:           
130:           static void send_lcd_cmd(const uint8_t cmd)
131:           {
132:           	CSB_SetLow();
1B68A  94BC     BCF 0xFBC, 2, ACCESS
133:           	SPI1_Exchange8bit(NHD_CMD);
1B68C  0EFE     MOVLW 0xFE
1B68E  6EE6     MOVWF 0xFE6, ACCESS
1B690  EC64     CALL 0x1BEC8, 0
1B692  F0DF     NOP
134:           	wdtdelay(8);
1B694  0E08     MOVLW 0x8
1B696  6EE6     MOVWF 0xFE6, ACCESS
1B698  0E00     MOVLW 0x0
1B69A  6EE6     MOVWF 0xFE6, ACCESS
1B69C  0E00     MOVLW 0x0
1B69E  6EE6     MOVWF 0xFE6, ACCESS
1B6A0  0E00     MOVLW 0x0
1B6A2  6EE6     MOVWF 0xFE6, ACCESS
1B6A4  ECEF     CALL 0x1B1DE, 0
1B6A6  F0D8     NOP
135:           	SPI1_Exchange8bit(cmd);
1B6A8  0EFF     MOVLW 0xFF
1B6AA  50E3     MOVF 0xFE3, W, ACCESS
1B6AC  6EE6     MOVWF 0xFE6, ACCESS
1B6AE  EC64     CALL 0x1BEC8, 0
1B6B0  F0DF     NOP
136:           	wdtdelay(8);
1B6B2  0E08     MOVLW 0x8
1B6B4  6EE6     MOVWF 0xFE6, ACCESS
1B6B6  0E00     MOVLW 0x0
1B6B8  6EE6     MOVWF 0xFE6, ACCESS
1B6BA  0E00     MOVLW 0x0
1B6BC  6EE6     MOVWF 0xFE6, ACCESS
1B6BE  0E00     MOVLW 0x0
1B6C0  6EE6     MOVWF 0xFE6, ACCESS
1B6C2  ECEF     CALL 0x1B1DE, 0
1B6C4  F0D8     NOP
137:           }
1B6C6  52E5     MOVF 0xFE5, F, ACCESS
1B6C8  0012     RETURN 0
138:           
139:           static void send_lcd_cmd_long(const uint8_t cmd)
140:           {
141:           	CSB_SetLow();
1B64A  94BC     BCF 0xFBC, 2, ACCESS
142:           	SPI1_Exchange8bit(NHD_CMD);
1B64C  0EFE     MOVLW 0xFE
1B64E  6EE6     MOVWF 0xFE6, ACCESS
1B650  EC64     CALL 0x1BEC8, 0
1B652  F0DF     NOP
143:           	wdtdelay(8);
1B654  0E08     MOVLW 0x8
1B656  6EE6     MOVWF 0xFE6, ACCESS
1B658  0E00     MOVLW 0x0
1B65A  6EE6     MOVWF 0xFE6, ACCESS
1B65C  0E00     MOVLW 0x0
1B65E  6EE6     MOVWF 0xFE6, ACCESS
1B660  0E00     MOVLW 0x0
1B662  6EE6     MOVWF 0xFE6, ACCESS
1B664  ECEF     CALL 0x1B1DE, 0
1B666  F0D8     NOP
144:           	SPI1_Exchange8bit(cmd);
1B668  0EFF     MOVLW 0xFF
1B66A  50E3     MOVF 0xFE3, W, ACCESS
1B66C  6EE6     MOVWF 0xFE6, ACCESS
1B66E  EC64     CALL 0x1BEC8, 0
1B670  F0DF     NOP
145:           	wdtdelay(800);
1B672  0E20     MOVLW 0x20
1B674  6EE6     MOVWF 0xFE6, ACCESS
1B676  0E03     MOVLW 0x3
1B678  6EE6     MOVWF 0xFE6, ACCESS
1B67A  0E00     MOVLW 0x0
1B67C  6EE6     MOVWF 0xFE6, ACCESS
1B67E  0E00     MOVLW 0x0
1B680  6EE6     MOVWF 0xFE6, ACCESS
1B682  ECEF     CALL 0x1B1DE, 0
1B684  F0D8     NOP
146:           }
1B686  52E5     MOVF 0xFE5, F, ACCESS
1B688  0012     RETURN 0
147:           
148:           /*
149:            * uses DMA channel 1 for transfers
150:            */
151:           void eaDogM_WriteString(char *strPtr)
152:           {
153:           	wait_lcd_set();
1A838  ECA2     CALL 0x1C144, 0
1A83A  F0E0     NOP
154:           	/* reset buffer for DMA */
155:           	ringBufS_flush(spi_link.tx1a, false);
1A83C  0E00     MOVLW 0x0
1A83E  6EE6     MOVWF 0xFE6, ACCESS
1A842  F19B     NOP
1A844  FFE6     NOP
1A848  F19F     NOP
1A84A  FFE6     NOP
1A84C  EC0C     CALL 0x1AA18, 0
1A84E  F0D5     NOP
156:           	CSB_SetLow(); /* SPI select display */
1A850  94BC     BCF 0xFBC, 2, ACCESS
157:           	if (strlen(strPtr) > max_strlen) strPtr[max_strlen] = 0; // buffer overflow check
1A852  0EFE     MOVLW 0xFE
1A856  FF8F     NOP
1A858  FFE6     NOP
1A85C  FF8F     NOP
1A85E  FFE6     NOP
1A860  EC6F     CALL 0x1A8DE, 0
1A862  F0D4     NOP
1A864  5002     MOVF ttemp5, W, ACCESS
1A866  E104     BNZ 0xA870
1A868  0E41     MOVLW 0x41
1A86A  5C01     SUBWF ltemp0, W, ACCESS
1A86C  A0D8     BTFSS 0xFD8, 0, ACCESS
1A86E  D010     BRA 0xA890
1A870  0EFE     MOVLW 0xFE
1A874  FF8C     NOP
1A876  F00B     NOP
1A878  0EFF     MOVLW 0xFF
1A87C  FF8C     NOP
1A87E  F00C     NOP
1A880  0E40     MOVLW 0x40
1A882  240B     ADDWF wtemp5, W, ACCESS
1A884  6ED9     MOVWF 0xFD9, ACCESS
1A886  0E00     MOVLW 0x0
1A888  200C     ADDWFC 0xC, W, ACCESS
1A88A  6EDA     MOVWF 0xFDA, ACCESS
1A88C  0E00     MOVLW 0x0
1A88E  6EDF     MOVWF 0xFDF, ACCESS
158:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
1A890  013B     MOVLB 0x3B
1A892  9FFC     BCF 0xFC, 7, BANKED
159:           	DMA1SSZ = strlen(strPtr);
1A894  0EFE     MOVLW 0xFE
1A898  FF8F     NOP
1A89A  FFE6     NOP
1A89E  FF8F     NOP
1A8A0  FFE6     NOP
1A8A2  EC6F     CALL 0x1A8DE, 0
1A8A4  F0D4     NOP
1A8A8  F007     NOP
1A8AA  FBF7     NOP
1A8AE  F00B     NOP
1A8B0  FBF8     NOP
160:           	DMA1CON0bits.EN = 1; /* enable DMA */
1A8B2  013B     MOVLB 0x3B
1A8B4  8FFC     BSF 0xFC, 7, BANKED
161:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
1A8B6  0EFE     MOVLW 0xFE
1A8BA  FF8F     NOP
1A8BC  FFE6     NOP
1A8C0  FF8F     NOP
1A8C2  FFE6     NOP
1A8C4  0EFC     MOVLW 0xFC
1A8C6  6EE6     MOVWF 0xFE6, ACCESS
1A8C8  0EFF     MOVLW 0xFF
1A8CA  6EE6     MOVWF 0xFE6, ACCESS
1A8CC  0E04     MOVLW 0x4
1A8CE  6EE6     MOVWF 0xFE6, ACCESS
1A8D0  EC30     CALL 0x1B060, 0
1A8D2  F0D8     NOP
162:           	start_lcd();
1A8D4  ECA5     CALL 0x1C14A, 0
1A8D6  F0E0     NOP
163:           #ifdef DISPLAY_SLOW
164:           	wdtdelay(9000);
165:           #endif
166:           }
1A8D8  52E5     MOVF 0xFE5, F, ACCESS
1A8DA  52E5     MOVF 0xFE5, F, ACCESS
1A8DC  0012     RETURN 0
167:           
168:           /*
169:            * uses DMA channel 1 for transfers
170:            */
171:           void send_lcd_cmd_dma(const uint8_t strPtr)
172:           {
173:           	send_lcd_data_dma(NHD_CMD); //prefix
1BEE6  0EFE     MOVLW 0xFE
1BEE8  6EE6     MOVWF 0xFE6, ACCESS
1BEEA  ECC2     CALL 0x1B384, 0
1BEEC  F0D9     NOP
174:           	wait_lcd_done();
1BEEE  ECAF     CALL 0x1BF5E, 0
1BEF0  F0DF     NOP
175:           	send_lcd_data_dma(strPtr); // cmd code
1BEF2  0EFF     MOVLW 0xFF
1BEF4  50E3     MOVF 0xFE3, W, ACCESS
1BEF6  6EE6     MOVWF 0xFE6, ACCESS
1BEF8  ECC2     CALL 0x1B384, 0
1BEFA  F0D9     NOP
176:           	wait_lcd_done();
1BEFC  ECAF     CALL 0x1BF5E, 0
1BEFE  F0DF     NOP
177:           }
1BF00  52E5     MOVF 0xFE5, F, ACCESS
1BF02  0012     RETURN 0
178:           
179:           /*
180:            * uses DMA channel 1 for transfers
181:            */
182:           void send_lcd_data_dma(const uint8_t strPtr)
183:           {
184:           	wait_lcd_set();
1B384  ECA2     CALL 0x1C144, 0
1B386  F0E0     NOP
185:           	/* reset buffer for DMA */
186:           	ringBufS_flush(spi_link.tx1a, false);
1B388  0E00     MOVLW 0x0
1B38A  6EE6     MOVWF 0xFE6, ACCESS
1B38E  F19B     NOP
1B390  FFE6     NOP
1B394  F19F     NOP
1B396  FFE6     NOP
1B398  EC0C     CALL 0x1AA18, 0
1B39A  F0D5     NOP
187:           	CSB_SetLow(); /* SPI select display */
1B39C  94BC     BCF 0xFBC, 2, ACCESS
188:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
1B39E  013B     MOVLB 0x3B
1B3A0  9FFC     BCF 0xFC, 7, BANKED
189:           	DMA1SSZ = 1;
1B3A2  0E00     MOVLW 0x0
1B3A4  6FF8     MOVWF 0xF8, BANKED
1B3A6  0E01     MOVLW 0x1
1B3A8  6FF7     MOVWF H, BANKED
190:           	DMA1CON0bits.EN = 1; /* enable DMA */
1B3AA  8FFC     BSF 0xFC, 7, BANKED
191:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
1B3AC  0EFF     MOVLW 0xFF
1B3AE  50E3     MOVF 0xFE3, W, ACCESS
1B3B0  6EE6     MOVWF 0xFE6, ACCESS
1B3B2  0E00     MOVLW 0x0
1B3B4  6EE6     MOVWF 0xFE6, ACCESS
1B3B6  0EF9     MOVLW 0xF9
1B3B8  6EE6     MOVWF 0xFE6, ACCESS
1B3BA  0EFF     MOVLW 0xFF
1B3BC  6EE6     MOVWF 0xFE6, ACCESS
1B3BE  0E04     MOVLW 0x4
1B3C0  6EE6     MOVWF 0xFE6, ACCESS
1B3C2  EC30     CALL 0x1B060, 0
1B3C4  F0D8     NOP
192:           	start_lcd();
1B3C6  ECA5     CALL 0x1C14A, 0
1B3C8  F0E0     NOP
193:           }
1B3CA  52E5     MOVF 0xFE5, F, ACCESS
1B3CC  0012     RETURN 0
194:           
195:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
1A790  52E6     MOVF 0xFE6, F, ACCESS
196:           {
197:           	uint8_t row;
198:           
199:           	switch (r) {
1A792  D014     BRA 0xA7BC
200:           	case 0:
201:           		row = 0x40;
1A794  0EFF     MOVLW 0xFF
1A796  6AE3     CLRF 0xFE3, ACCESS
1A798  8CE3     BSF 0xFE3, 6, ACCESS
202:           		break;
1A79A  D026     BRA 0xA7E8
203:           	case 1:
204:           		row = 0x14;
1A79C  0EFF     MOVLW 0xFF
1A79E  6AE3     CLRF 0xFE3, ACCESS
1A7A0  84E3     BSF 0xFE3, 2, ACCESS
1A7A2  88E3     BSF 0xFE3, 4, ACCESS
205:           		break;
1A7A4  D021     BRA 0xA7E8
206:           	case 2:
207:           		row = 0x54;
1A7A6  0E54     MOVLW 0x54
1A7A8  6E0C     MOVWF 0xC, ACCESS
1A7AA  0EFF     MOVLW 0xFF
1A7AE  F033     NOP
1A7B0  FFE3     NOP
208:           		break;
1A7B2  D01A     BRA 0xA7E8
209:           	case 3:
210:           		row = 0x1;
1A7B4  0EFF     MOVLW 0xFF
1A7B6  6AE3     CLRF 0xFE3, ACCESS
1A7B8  2AE3     INCF 0xFE3, F, ACCESS
211:           		break;
1A7BA  D016     BRA 0xA7E8
212:           	default:
213:           		row = 0x40;
214:           		break;
215:           	}
1A7BC  0EFE     MOVLW 0xFE
1A7BE  50E3     MOVF 0xFE3, W, ACCESS
1A7C0  6E0B     MOVWF wtemp5, ACCESS
1A7C2  6A0C     CLRF 0xC, ACCESS
1A7C4  500C     MOVF 0xC, W, ACCESS
1A7C6  0A00     XORLW 0x0
1A7C8  A4D8     BTFSS 0xFD8, 2, ACCESS
1A7CA  D7E4     BRA 0xA794
1A7CC  500B     MOVF wtemp5, W, ACCESS
1A7CE  0A00     XORLW 0x0
1A7D0  B4D8     BTFSC 0xFD8, 2, ACCESS
1A7D2  D7E0     BRA 0xA794
1A7D4  0A01     XORLW 0x1
1A7D6  B4D8     BTFSC 0xFD8, 2, ACCESS
1A7D8  D7E1     BRA 0xA79C
1A7DA  0A03     XORLW 0x3
1A7DC  B4D8     BTFSC 0xFD8, 2, ACCESS
1A7DE  D7E3     BRA 0xA7A6
1A7E0  0A01     XORLW 0x1
1A7E2  B4D8     BTFSC 0xFD8, 2, ACCESS
1A7E4  D7E7     BRA 0xA7B4
1A7E6  D7D6     BRA 0xA794
216:           	send_lcd_cmd_dma(0x45);
1A7E8  0E45     MOVLW 0x45
1A7EA  6EE6     MOVWF 0xFE6, ACCESS
1A7EC  EC73     CALL 0x1BEE6, 0
1A7EE  F0DF     NOP
217:           	send_lcd_data_dma(row + c);
1A7F0  0EFD     MOVLW 0xFD
1A7F4  FF8C     NOP
1A7F6  F00C     NOP
1A7F8  0EFF     MOVLW 0xFF
1A7FA  50E3     MOVF 0xFE3, W, ACCESS
1A7FC  240C     ADDWF 0xC, W, ACCESS
1A7FE  6EE6     MOVWF 0xFE6, ACCESS
1A800  ECC2     CALL 0x1B384, 0
1A802  F0D9     NOP
218:           	wait_lcd_done();
1A804  ECAF     CALL 0x1BF5E, 0
1A806  F0DF     NOP
219:           	wdtdelay(8);
1A808  0E08     MOVLW 0x8
1A80A  6EE6     MOVWF 0xFE6, ACCESS
1A80C  0E00     MOVLW 0x0
1A80E  6EE6     MOVWF 0xFE6, ACCESS
1A810  0E00     MOVLW 0x0
1A812  6EE6     MOVWF 0xFE6, ACCESS
1A814  0E00     MOVLW 0x0
1A816  6EE6     MOVWF 0xFE6, ACCESS
1A818  ECEF     CALL 0x1B1DE, 0
1A81A  F0D8     NOP
220:           	eaDogM_WriteString(strPtr);
1A81C  0EFB     MOVLW 0xFB
1A820  FF8F     NOP
1A822  FFE6     NOP
1A826  FF8F     NOP
1A828  FFE6     NOP
1A82A  EC1C     CALL 0x1A838, 0
1A82C  F0D4     NOP
221:           }
1A82E  0EFB     MOVLW 0xFB
1A830  26E1     ADDWF 0xFE1, F, ACCESS
1A832  0EFF     MOVLW 0xFF
1A834  22E2     ADDWFC 0xFE2, F, ACCESS
1A836  0012     RETURN 0
222:           
223:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
224:           {
225:           
226:           }
227:           
228:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
229:           {
230:           
231:           }
232:           
233:           void eaDogM_ClearRow(const uint8_t r)
234:           {
235:           
236:           }
237:           
238:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
239:           {
240:           
241:           }
242:           
243:           #else
244:           
245:           /*
246:            * add short spi delay (default)
247:            */
248:           static void send_lcd_data(const uint8_t data)
249:           {
250:           	RS_SetHigh();
251:           	CSB_SetLow();
252:           	SPI1_Exchange8bit(data);
253:           	wdtdelay(8);
254:           }
255:           
256:           /*
257:            * add inst spi delay
258:            */
259:           static void send_lcd_cmd(const uint8_t cmd)
260:           {
261:           	RS_SetLow();
262:           	CSB_SetLow();
263:           	SPI1_Exchange8bit(cmd);
264:           	wdtdelay(30);
265:           	RS_SetHigh();
266:           }
267:           
268:           /*
269:            * add clear/home spi delay
270:            */
271:           static void send_lcd_cmd_long(const uint8_t cmd)
272:           {
273:           	RS_SetLow();
274:           	CSB_SetLow();
275:           	SPI1_Exchange8bit(cmd);
276:           	wdtdelay(800);
277:           	RS_SetHigh();
278:           }
279:           
280:           void eaDogM_SetPos(const uint8_t r, const uint8_t c)
281:           {
282:           	uint8_t cmdPos;
283:           	cmdPos = (uint8_t) EADOGM_CMD_DDRAM_ADDR + (uint8_t) ((uint8_t) r * (uint8_t) EADOGM_COLSPAN) + (uint8_t) c;
284:           	eaDogM_WriteCommand(cmdPos);
285:           }
286:           
287:           void eaDogM_ClearRow(const uint8_t r)
288:           {
289:           	uint8_t i;
290:           	eaDogM_SetPos(r, 0);
291:           	for (i = 0; i < EADOGM_COLSPAN; i++) {
292:           		eaDogM_WriteChr(' ');
293:           	}
294:           }
295:           
296:           /*
297:            * uses DMA channel 1 for transfers
298:            */
299:           void eaDogM_WriteString(char *strPtr)
300:           {
301:           	wait_lcd_set();
302:           	/* reset buffer for DMA */
303:           	ringBufS_flush(spi_link.tx1a, false);
304:           	CSB_SetLow(); /* SPI select display */
305:           	if (strlen(strPtr) > max_strlen) strPtr[max_strlen] = 0; // buffer overflow check
306:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
307:           	DMA1SSZ = strlen(strPtr);
308:           	DMA1CON0bits.EN = 1; /* enable DMA */
309:           	printf("%s", strPtr); // testing copy method using STDIO redirect to buffer
310:           	start_lcd();
311:           #ifdef DISPLAY_SLOW
312:           	wdtdelay(9000);
313:           #endif
314:           }
315:           
316:           /*
317:            * uses DMA channel 1 for transfers
318:            */
319:           void send_lcd_cmd_dma(uint8_t strPtr)
320:           {
321:           	wait_lcd_set();
322:           	/* reset buffer for DMA */
323:           	ringBufS_flush(spi_link.tx1a, false);
324:           	RS_SetLow();
325:           	CSB_SetLow(); /* SPI select display */
326:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
327:           	DMA1SSZ = 1;
328:           	DMA1CON0bits.EN = 1; /* enable DMA */
329:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
330:           	start_lcd();
331:           	wait_lcd_done();
332:           	RS_SetHigh();
333:           }
334:           
335:           /*
336:            * uses DMA channel 1 for transfers
337:            */
338:           void send_lcd_data_dma(uint8_t strPtr)
339:           {
340:           	wait_lcd_set();
341:           	/* reset buffer for DMA */
342:           	ringBufS_flush(spi_link.tx1a, false);
343:           	RS_SetHigh();
344:           	CSB_SetLow(); /* SPI select display */
345:           	DMA1CON0bits.EN = 0; /* disable DMA to change source count */
346:           	DMA1SSZ = 1;
347:           	DMA1CON0bits.EN = 1; /* enable DMA */
348:           	printf("%c", strPtr); // testing copy method using STDIO redirect to buffer
349:           	start_lcd();
350:           }
351:           
352:           void eaDogM_WriteStringAtPos(const uint8_t r, const uint8_t c, char *strPtr)
353:           {
354:           	send_lcd_cmd_dma((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
355:           	eaDogM_WriteString(strPtr);
356:           }
357:           
358:           void eaDogM_WriteIntAtPos(uint8_t r, uint8_t c, uint8_t i)
359:           {
360:           	eaDogM_WriteCommand((EADOGM_CMD_DDRAM_ADDR + (r * EADOGM_COLSPAN) + c));
361:           
362:           	eaDogM_WriteChr(i / 10 + '0');
363:           	eaDogM_WriteChr(i % 10 + '0');
364:           
365:           }
366:           
367:           // this writes a byte to the internal CGRAM (v2.02)
368:           // format for ndx: 00CCCRRR = CCC = character 0 to 7, RRR = row 0 to 7
369:           
370:           void eaDogM_WriteByteToCGRAM(uint8_t ndx, uint8_t data)
371:           {
372:           	uint8_t cmd;
373:           
374:           	cmd = ndx & 0b00111111; // mask off upper to bits
375:           	cmd = cmd | EADOGM_CMD_CGRAM_ADDR; // set bit cmd bits
376:           
377:           	eaDogM_WriteCommand(cmd);
378:           	eaDogM_WriteChr(data);
379:           
380:           	// this is done to make sure we are back in data mode
381:           	eaDogM_SetPos(0, 0);
382:           }
383:           #endif
384:           
385:           void eaDogM_WriteCommand(const uint8_t cmd)
386:           {
387:           	send_lcd_cmd_dma(cmd);
1C094  0EFF     MOVLW 0xFF
1C096  50E3     MOVF 0xFE3, W, ACCESS
1C098  6EE6     MOVWF 0xFE6, ACCESS
1C09A  EC73     CALL 0x1BEE6, 0
1C09C  F0DF     NOP
388:           }
1C09E  52E5     MOVF 0xFE5, F, ACCESS
1C0A0  0012     RETURN 0
389:           
390:           void eaDogM_WriteChr(const int8_t value)
391:           {
392:           	send_lcd_data_dma((uint8_t) value);
393:           }
394:           
395:           /*
396:            * uses DMA channel 2 for transfers
397:            */
398:           void send_port_data_dma(uint16_t dsize)
399:           {
400:           	if (dsize > max_port_data)
1B2E4  0EFE     MOVLW 0xFE
1B2E6  04E3     DECF 0xFE3, W, ACCESS
1B2E8  0EFF     MOVLW 0xFF
1B2EC  FF8C     NOP
1B2EE  F001     NOP
1B2F0  0E02     MOVLW 0x2
1B2F2  5A01     SUBWFB ltemp0, F, ACCESS
1B2F4  A0D8     BTFSS 0xFD8, 0, ACCESS
1B2F6  D00C     BRA 0xB310
401:           		dsize = max_port_data;
1B2F8  0E00     MOVLW 0x0
1B2FA  6E0B     MOVWF wtemp5, ACCESS
1B2FC  0E02     MOVLW 0x2
1B2FE  6E0C     MOVWF 0xC, ACCESS
1B300  0EFE     MOVLW 0xFE
1B304  F02F     NOP
1B306  FFE3     NOP
1B308  0EFF     MOVLW 0xFF
1B30C  F033     NOP
1B30E  FFE3     NOP
402:           
403:           	DMA2CON0bits.EN = 0; /* disable DMA to change source count */
1B310  013B     MOVLB 0x3B
1B312  9FDC     BCF 0xDC, 7, BANKED
404:           	DMA2SSZ = dsize;
1B314  0EFE     MOVLW 0xFE
1B318  FF8F     NOP
1B31A  FBD7     NOP
1B31C  0EFF     MOVLW 0xFF
1B320  FF8F     NOP
1B322  FBD8     NOP
405:           	DMA2DSZ = 1;
1B324  0E00     MOVLW 0x0
1B326  6FCF     MOVWF seed, BANKED
1B328  0E01     MOVLW 0x1
1B32A  6FCE     MOVWF uart1RxCount, BANKED
406:           	DMA2CON0bits.EN = 1; /* enable DMA */
1B32C  8FDC     BSF 0xDC, 7, BANKED
407:           	DMA2CON0bits.DMA2SIRQEN = 1; /* start DMA trigger */
1B32E  8DDC     BSF 0xDC, 6, BANKED
408:           }
1B330  52E5     MOVF 0xFE5, F, ACCESS
1B332  52E5     MOVF 0xFE5, F, ACCESS
1B334  0012     RETURN 0
409:           
410:           /*
411:            * return pointer to internal data buffer for DMA
412:            */
413:           uint8_t* port_data_dma_ptr(void)
414:           {
415:           	return port_data;
1C0E8  0EFF     MOVLW 0xFF
1C0EA  6E01     MOVWF ltemp0, ACCESS
1C0EC  0E04     MOVLW 0x4
1C0EE  6E02     MOVWF ttemp5, ACCESS
416:           }
1C0F0  0012     RETURN 0
417:           
418:           /*
419:            * STDOUT user handler function
420:            */
421:           void putch(char c)
422:           {
423:           	ringBufS_put_dma(spi_link.tx1a, c);
1BF7A  0EFF     MOVLW 0xFF
1BF7C  50E3     MOVF 0xFE3, W, ACCESS
1BF7E  6EE6     MOVWF 0xFE6, ACCESS
1BF82  F19B     NOP
1BF84  FFE6     NOP
1BF88  F19F     NOP
1BF8A  FFE6     NOP
1BF8C  EC73     CALL 0x1A6E6, 0
1BF8E  F0D3     NOP
424:           }
1BF90  52E5     MOVF 0xFE5, F, ACCESS
1BF92  0012     RETURN 0
425:           
426:           /*
427:            * Trigger the SPI DMA transfer to the LCD display
428:            */
429:           void start_lcd(void)
430:           {
431:           	DMA1CON0bits.DMA1SIRQEN = 1; /* start DMA trigger */
1C14A  013B     MOVLB 0x3B
1C14C  8DFC     BSF 0xFC, 6, BANKED
432:           }
1C14E  0012     RETURN 0
433:           
434:           void wait_lcd_set(void)
435:           {
436:           	spi_link.LCD_DATA = 1;
1C144  0100     MOVLB 0x0
1C146  8760     BSF spi_link, 3, BANKED
437:           }
1C148  0012     RETURN 0
438:           
439:           bool wait_lcd_check(void)
440:           {
441:           	return spi_link.LCD_DATA;
442:           }
443:           
444:           void wait_lcd_done(void)
445:           {
446:           	while (spi_link.LCD_DATA);
1BF5E  0100     MOVLB 0x0
1BF60  B760     BTFSC spi_link, 3, BANKED
1BF62  D7FD     BRA 0xBF5E
447:           	wdtdelay(50);
1BF64  0E32     MOVLW 0x32
1BF66  6EE6     MOVWF 0xFE6, ACCESS
1BF68  0E00     MOVLW 0x0
1BF6A  6EE6     MOVWF 0xFE6, ACCESS
1BF6C  0E00     MOVLW 0x0
1BF6E  6EE6     MOVWF 0xFE6, ACCESS
1BF70  0E00     MOVLW 0x0
1BF72  6EE6     MOVWF 0xFE6, ACCESS
1BF74  ECEF     CALL 0x1B1DE, 0
1BF76  F0D8     NOP
448:           }
1BF78  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/dio.c  ---------------------------------------------------
1:             #include "dio.h"
2:             #include "mcc_generated_files/ext_int.h"
3:             
4:             typedef struct S_data { // switch control data structure 
5:             	volatile rbutton_type button[MAX_BUTTONS];
6:             	volatile uint8_t sw_bitmap;
7:             } S_data;
8:             
9:             static S_data S;
10:            extern V_data V;
11:            
12:            static void switch_handler(void);
13:            
14:            /*
15:             * return the current actual state of x switch
16:             * the actual current state of a switch is ONLY changed in the interrupt handler
17:             */
18:            SW_STATES get_switch(const uint8_t i)
19:            {
20:            	if (i >= NUM_SWITCHES)
1BA40  0EFF     MOVLW 0xFF
1BA44  FF8C     NOP
1BA46  F001     NOP
1BA48  0E03     MOVLW 0x3
1BA4A  6401     CPFSGT ltemp0, ACCESS
1BA4C  D002     BRA 0xBA52
21:            		return SW_OFF;
1BA4E  0E00     MOVLW 0x0
1BA50  D00A     BRA 0xBA66
22:            
23:            	return S.button[i].sw;
1BA52  0EFF     MOVLW 0xFF
1BA54  50E3     MOVF 0xFE3, W, ACCESS
1BA56  0D05     MULLW 0x5
1BA58  0E54     MOVLW 0x54
1BA5A  24F3     ADDWF 0xFF3, W, ACCESS
1BA5C  6ED9     MOVWF 0xFD9, ACCESS
1BA5E  0E02     MOVLW 0x2
1BA60  20F4     ADDWFC 0xFF4, W, ACCESS
1BA62  6EDA     MOVWF 0xFDA, ACCESS
1BA64  50DF     MOVF 0xFDF, W, ACCESS
1BA66  6E01     MOVWF ltemp0, ACCESS
24:            }
1BA68  52E5     MOVF 0xFE5, F, ACCESS
1BA6A  0012     RETURN 0
25:            
26:            /*
27:             * return the x switch structure
28:             * mainly for testing
29:             */
30:            rbutton_type get_switch_data(const uint8_t i)
31:            {
32:            	if (i >= NUM_SWITCHES)
33:            		return S.button[SNULL];
34:            
35:            	return S.button[i];
36:            }
37:            
38:            /*
39:             * check the switch pressed bitmap for button presses, the actual current switch state might differ
40:             */
41:            uint8_t check_switches(void)
42:            {
43:            	return S.sw_bitmap;
44:            }
45:            
46:            /*
47:             * clear X switch pressed and time pressed data
48:             */
49:            void clear_switch(const uint8_t i)
50:            {
51:            	if (i >= NUM_SWITCHES)
52:            		return;
53:            
54:            	S.button[i].count = 0;
55:            	S.sw_bitmap &= ~(1 << i); //clear switch pressed bit
56:            }
57:            
58:            void switch_handler(void)
1953C  52E6     MOVF 0xFE6, F, ACCESS
1953E  52E6     MOVF 0xFE6, F, ACCESS
59:            {
60:            	uint8_t i = 0, sw_value;
19540  0EFE     MOVLW 0xFE
19542  6AE3     CLRF 0xFE3, ACCESS
61:            
62:            	/*
63:            	 * enable the outputs for reading and reset MAX Change-of-State pin
64:            	 */
65:            	MAX_EN1_SetLow(); // rev 1.1+ board
19544  9ABF     BCF 0xFBF, 5, ACCESS
66:            
67:            #ifdef DEBUG_SWH1
68:            	DEBUG1_SetHigh();
69:            #endif
70:            
71:            	// Nop for MAX chip output Propagation Delay after enable
72:            	Nop();
19546  F000     NOP
73:            	Nop();
19548  F000     NOP
74:            	Nop();
1954A  F000     NOP
75:            	Nop();
1954C  F000     NOP
76:            	Nop();
1954E  F000     NOP
77:            	Nop();
19550  F000     NOP
19552  D013     BRA 0x957A
78:            	// start reading the various pic port input bits after the max chip is ready
79:            	do {
80:            		switch (i) {
81:            		case SENTER:
82:            			sw_value = ENTER_B_GetValue();
19554  A6CF     BTFSS 0xFCF, 3, ACCESS
19556  D00B     BRA 0x956E
19558  D007     BRA 0x9568
1955A  0EFF     MOVLW 0xFF
1955E  F033     NOP
19560  FFE3     NOP
83:            			break;
19562  D021     BRA 0x95A6
84:            		case SSELECT:
85:            			sw_value = SELECT_B_GetValue();
19564  A4CF     BTFSS 0xFCF, 2, ACCESS
19566  D003     BRA 0x956E
19568  6A0C     CLRF 0xC, ACCESS
1956A  2A0C     INCF 0xC, F, ACCESS
1956C  D7F6     BRA 0x955A
1956E  6A0C     CLRF 0xC, ACCESS
19570  D7F4     BRA 0x955A
86:            			break;
87:            		case S1:
88:            			sw_value = 1;
19572  0EFF     MOVLW 0xFF
19574  6AE3     CLRF 0xFE3, ACCESS
19576  2AE3     INCF 0xFE3, F, ACCESS
89:            			break;
19578  D016     BRA 0x95A6
90:            		case S0:
91:            			sw_value = 1;
92:            			break;
93:            		default:
94:            			sw_value = 1;
95:            			break;
96:            		}
1957A  0EFE     MOVLW 0xFE
1957C  50E3     MOVF 0xFE3, W, ACCESS
1957E  6E0B     MOVWF wtemp5, ACCESS
19580  6A0C     CLRF 0xC, ACCESS
19582  500C     MOVF 0xC, W, ACCESS
19584  0A00     XORLW 0x0
19586  A4D8     BTFSS 0xFD8, 2, ACCESS
19588  D7F4     BRA 0x9572
1958A  500B     MOVF wtemp5, W, ACCESS
1958C  0A00     XORLW 0x0
1958E  B4D8     BTFSC 0xFD8, 2, ACCESS
19590  D7F0     BRA 0x9572
19592  0A01     XORLW 0x1
19594  B4D8     BTFSC 0xFD8, 2, ACCESS
19596  D7ED     BRA 0x9572
19598  0A03     XORLW 0x3
1959A  B4D8     BTFSC 0xFD8, 2, ACCESS
1959C  D7E3     BRA 0x9564
1959E  0A01     XORLW 0x1
195A0  B4D8     BTFSC 0xFD8, 2, ACCESS
195A2  D7D8     BRA 0x9554
195A4  D7E6     BRA 0x9572
97:            
98:            		// update actual current button state
99:            		if (sw_value) {
195A6  0EFF     MOVLW 0xFF
195A8  50E3     MOVF 0xFE3, W, ACCESS
195AA  B4D8     BTFSC 0xFD8, 2, ACCESS
195AC  D018     BRA 0x95DE
100:           			if (S.button[i].sw == SW_ON) {
195AE  0EFE     MOVLW 0xFE
195B0  50E3     MOVF 0xFE3, W, ACCESS
195B2  0D05     MULLW 0x5
195B4  0E54     MOVLW 0x54
195B6  24F3     ADDWF 0xFF3, W, ACCESS
195B8  6ED9     MOVWF 0xFD9, ACCESS
195BA  0E02     MOVLW 0x2
195BC  20F4     ADDWFC 0xFF4, W, ACCESS
195BE  6EDA     MOVWF 0xFDA, ACCESS
195C0  04DE     DECF 0xFDE, W, ACCESS
195C2  A4D8     BTFSS 0xFD8, 2, ACCESS
195C4  D049     BRA 0x9658
101:           				S.button[i].sw = SW_OFF;
195C6  0EFE     MOVLW 0xFE
195C8  50E3     MOVF 0xFE3, W, ACCESS
195CA  0D05     MULLW 0x5
195CC  0E54     MOVLW 0x54
195CE  24F3     ADDWF 0xFF3, W, ACCESS
195D0  6ED9     MOVWF 0xFD9, ACCESS
195D2  0E02     MOVLW 0x2
195D4  20F4     ADDWFC 0xFF4, W, ACCESS
195D6  6EDA     MOVWF 0xFDA, ACCESS
195D8  0E00     MOVLW 0x0
195DA  6EDF     MOVWF 0xFDF, ACCESS
195DC  D03D     BRA 0x9658
102:           			}
103:           		} else {
104:           			if (S.button[i].sw == SW_OFF) {
195DE  0EFE     MOVLW 0xFE
195E0  50E3     MOVF 0xFE3, W, ACCESS
195E2  0D05     MULLW 0x5
195E4  0E54     MOVLW 0x54
195E6  24F3     ADDWF 0xFF3, W, ACCESS
195E8  6ED9     MOVWF 0xFD9, ACCESS
195EA  0E02     MOVLW 0x2
195EC  20F4     ADDWFC 0xFF4, W, ACCESS
195EE  6EDA     MOVWF 0xFDA, ACCESS
195F0  50DF     MOVF 0xFDF, W, ACCESS
195F2  A4D8     BTFSS 0xFD8, 2, ACCESS
195F4  D031     BRA 0x9658
105:           				S.button[i].sw = SW_ON;
195F6  0EFE     MOVLW 0xFE
195F8  50E3     MOVF 0xFE3, W, ACCESS
195FA  0D05     MULLW 0x5
195FC  0E54     MOVLW 0x54
195FE  24F3     ADDWF 0xFF3, W, ACCESS
19600  6ED9     MOVWF 0xFD9, ACCESS
19602  0E02     MOVLW 0x2
19604  20F4     ADDWFC 0xFF4, W, ACCESS
19606  6EDA     MOVWF 0xFDA, ACCESS
19608  0E01     MOVLW 0x1
1960A  6EDF     MOVWF 0xFDF, ACCESS
106:           				S.button[i].count = V.timerint_count; // so we can check button SW_ON duration
1960C  EE20     LFSR 2, 0x1EB
1960E  F1EB     NOP
19610  0EFE     MOVLW 0xFE
19612  50E3     MOVF 0xFE3, W, ACCESS
19614  0D05     MULLW 0x5
19616  0E55     MOVLW 0x55
19618  24F3     ADDWF 0xFF3, W, ACCESS
1961A  6EE9     MOVWF 0xFE9, ACCESS
1961C  0E02     MOVLW 0x2
1961E  20F4     ADDWFC 0xFF4, W, ACCESS
19620  6EEA     MOVWF 0xFEA, ACCESS
19624  FF7B     NOP
19626  FFEE     NOP
1962A  FF7B     NOP
1962C  FFEE     NOP
19630  FF7B     NOP
19632  FFEE     NOP
19636  FF7B     NOP
19638  FFEE     NOP
107:           				S.sw_bitmap |= 1 << i; // set switch pressed bit
1963A  0EFE     MOVLW 0xFE
1963E  FF8C     NOP
19640  F00C     NOP
19642  0E01     MOVLW 0x1
19644  6E0B     MOVWF wtemp5, ACCESS
19646  2A0C     INCF 0xC, F, ACCESS
19648  D002     BRA 0x964E
1964A  90D8     BCF 0xFD8, 0, ACCESS
1964C  360B     RLCF wtemp5, F, ACCESS
1964E  2E0C     DECFSZ 0xC, F, ACCESS
19650  D7FC     BRA 0x964A
19652  500B     MOVF wtemp5, W, ACCESS
19654  0102     MOVLB 0x2
19656  137C     IORWF 0x7C, F, BANKED
108:           			}
109:           		}
110:           	} while (++i < NUM_SWITCHES);
19658  0EFE     MOVLW 0xFE
1965A  2AE3     INCF 0xFE3, F, ACCESS
1965C  0EFE     MOVLW 0xFE
19660  FF8C     NOP
19662  F001     NOP
19664  0E03     MOVLW 0x3
19666  6401     CPFSGT ltemp0, ACCESS
19668  D788     BRA 0x957A
111:           
112:           #ifdef DEBUG_SWH1
113:           	DEBUG1_SetLow();
114:           #endif
115:           #ifdef DEBUG_SWH2
116:           	DEBUG2_Toggle();
117:           #endif
118:           
119:           	MAX_EN1_SetHigh(); // disable MAX output pins
1966A  8ABF     BSF 0xFBF, 5, ACCESS
120:           }
1966C  52E5     MOVF 0xFE5, F, ACCESS
121:           
122:           void start_switch_handler(void)
123:           {
124:           	EXT_INT1_InterruptDisable();
1BE88  0139     MOVLB 0x39
1BE8A  9195     BCF 0x95, 0, BANKED
125:           	INT1_SetInterruptHandler(switch_handler);
1BE8C  0E3C     MOVLW 0x3C
1BE8E  6EE6     MOVWF 0xFE6, ACCESS
1BE90  0E95     MOVLW 0x95
1BE92  6EE6     MOVWF 0xFE6, ACCESS
1BE94  0E01     MOVLW 0x1
1BE96  6EE6     MOVWF 0xFE6, ACCESS
1BE98  EC17     CALL 0x1BC2E, 0
1BE9A  F0DE     NOP
126:           	S.button[SNULL].sw = SW_INVALID; // set a error condition for invalid button number
1BE9C  0E02     MOVLW 0x2
1BE9E  0102     MOVLB 0x2
1BEA0  6F77     MOVWF 0x77, BANKED
127:           	EXT_INT1_InterruptEnable();
1BEA2  0139     MOVLB 0x39
1BEA4  8195     BSF 0x95, 0, BANKED
128:           }
1BEA6  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/daq.c  ---------------------------------------------------
1:             /*
2:              * 12-bit analog 64 sample average per channel on ports A and B
3:              * uses the compute burst average mode threshold interrupt to auto change
4:              * channels during interrupt after a repeat count
5:              */
6:             
7:             #include "daq.h"
8:             
9:             typedef struct R_data { // internal variables
10:            	adc_result_t raw_adc[ADC_BUFFER_SIZE];
11:            	int16_t n_offset[NUM_C_SENSORS];
12:            	float n_zero[NUM_C_SENSORS];
13:            	uint8_t scan_index;
14:            	uint16_t scan_select;
15:            	bool done;
16:            } R_data;
17:            
18:            static volatile R_data R = {
19:            	.done = false,
20:            	.scan_index = 0,
21:            	.n_offset[0] = N_OFFSET0,
22:            	.n_offset[1] = N_OFFSET1,
23:            	.n_zero[0] = 0.0,
24:            	.n_zero[1] = 0.0,
25:            };
26:            
27:            static void adc_int_handler(void);
28:            static void adc_int_t_handler(void);
29:            
30:            /*
31:             * start computed ADC results: 64 samples per average value per selected channel from
32:             * AN channel zero to LAST_ADC_CHAN
33:             * check_adc_scan returns true when sequence is complete
34:             */
35:            bool start_adc_scan(void)
36:            {
37:            	if (R.done)
1AFFC  0101     MOVLB 0x1
1AFFE  512F     MOVF 0x2F, W, BANKED
1B000  A4D8     BTFSS 0xFD8, 2, ACCESS
1B002  0012     RETURN 0
38:            		return false;
39:            
40:            	R.scan_index = 0;
1B004  6B2C     CLRF 0x2C, BANKED
41:            	R.scan_select = (uint16_t) ((ANSELB << 8) + ANSELA) & ADC_SCAN_CHAN; // skip digital pins PORT A and B
1B006  013A     MOVLB 0x3A
1B008  5140     MOVF esr_state, W, BANKED
1B00C  F940     NOP
1B00E  F001     NOP
1B010  6A02     CLRF ttemp5, ACCESS
1B014  F004     NOP
1B016  F002     NOP
1B018  6A01     CLRF ltemp0, ACCESS
1B01A  2601     ADDWF ltemp0, F, ACCESS
1B01C  0E00     MOVLW 0x0
1B01E  2202     ADDWFC ttemp5, F, ACCESS
1B020  0E77     MOVLW 0x77
1B022  1401     ANDWF ltemp0, W, ACCESS
1B024  0101     MOVLB 0x1
1B026  6F2D     MOVWF 0x2D, BANKED
1B028  0E3C     MOVLW 0x3C
1B02A  1402     ANDWF ttemp5, W, ACCESS
1B02C  6F2E     MOVWF 0x2E, BANKED
42:            	ADCC_SetADIInterruptHandler(adc_int_handler);
1B02E  0E66     MOVLW 0x66
1B030  6EE6     MOVWF 0xFE6, ACCESS
1B032  0EC1     MOVLW 0xC1
1B034  6EE6     MOVWF 0xFE6, ACCESS
1B036  0E01     MOVLW 0x1
1B038  6EE6     MOVWF 0xFE6, ACCESS
1B03A  EC53     CALL 0x1BCA6, 0
1B03C  F0DE     NOP
43:            	ADCC_SetADTIInterruptHandler(adc_int_t_handler);
1B03E  0E5C     MOVLW 0x5C
1B040  6EE6     MOVWF 0xFE6, ACCESS
1B042  0EAD     MOVLW 0xAD
1B044  6EE6     MOVWF 0xFE6, ACCESS
1B046  0E01     MOVLW 0x1
1B048  6EE6     MOVWF 0xFE6, ACCESS
1B04A  EC3F     CALL 0x1BC7E, 0
1B04C  F0DE     NOP
44:            	ADCC_DischargeSampleCapacitor(); // short ADC sample cap before channel sampling
1B04E  EC8B     CALL 0x1C116, 0
1B050  F0E0     NOP
45:            	ADCC_StartConversion(R.scan_index & 0xf);
1B052  0101     MOVLB 0x1
1B054  512C     MOVF 0x2C, W, BANKED
1B056  0B0F     ANDLW 0xF
1B058  6EE6     MOVWF 0xFE6, ACCESS
1B05A  EC1A     CALL 0x1C034, 0
1B05C  F0E0     NOP
46:            #ifdef DEBUG_DAQ1
47:            	DEBUG1_SetHigh();
48:            #endif
49:            #ifdef DEBUG_DAQ2
50:            	DEBUG2_SetHigh();
51:            #endif
52:            	return true;
53:            }
1B05E  0012     RETURN 0
54:            
55:            /*
56:             * check scan done flag
57:             */
58:            bool check_adc_scan(void)
59:            {
60:            	return R.done;
1C120  F4BC     NOP
1C122  F001     NOP
61:            }
1C124  0012     RETURN 0
62:            
63:            /*
64:             * clear scan done flag
65:             */
66:            void clear_adc_scan(void)
67:            {
68:            	R.done = false;
1C13E  0101     MOVLB 0x1
1C140  6B2F     CLRF 0x2F, BANKED
69:            }
1C142  0012     RETURN 0
70:            
71:            /*
72:             * update the raw adc values
73:             */
74:            bool update_adc_result(void)
75:            {
76:            	if (R.done) {
1B80A  0101     MOVLB 0x1
1B80C  512F     MOVF 0x2F, W, BANKED
1B80E  B4D8     BTFSC 0xFD8, 2, ACCESS
1B810  0012     RETURN 0
77:            		clear_adc_scan();
1B812  EC9F     CALL 0x1C13E, 0
1B814  F0E0     NOP
78:            		start_adc_scan();
1B816  ECFE     CALL 0x1AFFC, 0
1B818  F0D7     NOP
79:            		StartTimer(TMR_ADC, ADC_SCAN_SPEED);
1B81A  0EC8     MOVLW 0xC8
1B81C  6EE6     MOVWF 0xFE6, ACCESS
1B81E  0E00     MOVLW 0x0
1B820  6EE6     MOVWF 0xFE6, ACCESS
1B822  0E01     MOVLW 0x1
1B824  6EE6     MOVWF 0xFE6, ACCESS
1B826  EC65     CALL 0x1B6CA, 0
1B828  F0DB     NOP
80:            		while (!TimerDone(TMR_ADC) && !check_adc_scan());
1B82A  0E01     MOVLW 0x1
1B82C  6EE6     MOVWF 0xFE6, ACCESS
1B82E  EC8B     CALL 0x1BB16, 0
1B830  F0DD     NOP
1B832  5001     MOVF ltemp0, W, ACCESS
1B834  A4D8     BTFSS 0xFD8, 2, ACCESS
1B836  0012     RETURN 0
1B838  EC8F     CALL 0x1C11E, 0
1B83A  F0E0     NOP
1B83C  5001     MOVF ltemp0, W, ACCESS
1B83E  A4D8     BTFSS 0xFD8, 2, ACCESS
1B840  0012     RETURN 0
1B842  D7F3     BRA 0xB82A
81:            		return true;
82:            	} else {
83:            		return false;
84:            	}
85:            }
86:            
87:            /*
88:             * read average value of a channel after scan completion (done)
89:             */
90:            adc_result_t get_raw_result(const adcc_channel_t index)
91:            {
92:            	return R.raw_adc[index];
1BE44  0EFF     MOVLW 0xFF
1BE46  50E3     MOVF 0xFE3, W, ACCESS
1BE48  0D02     MULLW 0x2
1BE4A  0E00     MOVLW 0x0
1BE4C  24F3     ADDWF 0xFF3, W, ACCESS
1BE4E  6ED9     MOVWF 0xFD9, ACCESS
1BE50  0E01     MOVLW 0x1
1BE52  20F4     ADDWFC 0xFF4, W, ACCESS
1BE54  6EDA     MOVWF 0xFDA, ACCESS
1BE58  FF78     NOP
1BE5A  F001     NOP
1BE5E  FF74     NOP
1BE60  F002     NOP
93:            }
1BE62  52E5     MOVF 0xFE5, F, ACCESS
1BE64  0012     RETURN 0
94:            
95:            /*
96:             * turn ADC values into standard program values
97:             */
98:            float conv_raw_result(const adcc_channel_t chan, const adc_conv_t to_what)
99:            {
100:           
101:           	switch (to_what) {
152E2  D276     BRA 0x57D0
102:           	case CONV:
103:           		if (!(ADC_SCAN_CHAN >> chan & 0x1))
152E4  0EFF     MOVLW 0xFF
152E8  FF8C     NOP
152EA  F00C     NOP
152EC  0E77     MOVLW 0x77
152EE  6E09     MOVWF ltemp2, ACCESS
152F0  0E3C     MOVLW 0x3C
152F2  6E0A     MOVWF ttemp3, ACCESS
152F4  2A0C     INCF 0xC, F, ACCESS
152F6  D003     BRA 0x52FE
152F8  340A     RLCF ttemp3, W, ACCESS
152FA  320A     RRCF ttemp3, F, ACCESS
152FC  3209     RRCF ltemp2, F, ACCESS
152FE  2E0C     DECFSZ 0xC, F, ACCESS
15300  D7FB     BRA 0x52F8
15302  B009     BTFSC ltemp2, 0, ACCESS
15304  D007     BRA 0x5314
104:           			return NAN;
15306  0E4F     MOVLW 0x4F
15308  6EE6     MOVWF 0xFE6, ACCESS
1530A  0EFC     MOVLW 0xFC
1530C  6EE6     MOVWF 0xFE6, ACCESS
1530E  EC61     CALL 0x1B0C2, 0
15310  F0D8     NOP
15312  D26E     BRA 0x57F0
105:           
106:           		if (ADC_C_CHAN >> chan & 0x1) { // current conversion
15314  0EFF     MOVLW 0xFF
15318  FF8C     NOP
1531A  F00C     NOP
1531C  0E03     MOVLW 0x3
1531E  6E09     MOVWF ltemp2, ACCESS
15320  0E00     MOVLW 0x0
15322  6E0A     MOVWF ttemp3, ACCESS
15324  2A0C     INCF 0xC, F, ACCESS
15326  D003     BRA 0x532E
15328  340A     RLCF ttemp3, W, ACCESS
1532A  320A     RRCF ttemp3, F, ACCESS
1532C  3209     RRCF ltemp2, F, ACCESS
1532E  2E0C     DECFSZ 0xC, F, ACCESS
15330  D7FB     BRA 0x5328
15332  A009     BTFSS ltemp2, 0, ACCESS
15334  D11F     BRA 0x5574
107:           			if (ADC_C_CHAN_TYPE >> chan & 0x1) {
15336  0EFF     MOVLW 0xFF
1533A  FF8C     NOP
1533C  F00C     NOP
1533E  0E01     MOVLW 0x1
15340  6E09     MOVWF ltemp2, ACCESS
15342  0E00     MOVLW 0x0
15344  6E0A     MOVWF ttemp3, ACCESS
15346  2A0C     INCF 0xC, F, ACCESS
15348  D003     BRA 0x5350
1534A  340A     RLCF ttemp3, W, ACCESS
1534C  320A     RRCF ttemp3, F, ACCESS
1534E  3209     RRCF ltemp2, F, ACCESS
15350  2E0C     DECFSZ 0xC, F, ACCESS
15352  D7FB     BRA 0x534A
15354  A009     BTFSS ltemp2, 0, ACCESS
15356  D087     BRA 0x5466
108:           				return R.n_zero[0]+((float) ((int16_t) get_raw_result(chan)) - R.n_offset[0]) * C_A200;
1535A  F493     NOP
1535C  FFE6     NOP
15360  F497     NOP
15362  FFE6     NOP
15366  F49B     NOP
15368  FFE6     NOP
1536C  F49F     NOP
1536E  FFE6     NOP
15370  0E7B     MOVLW 0x7B
15372  6EE6     MOVWF 0xFE6, ACCESS
15374  0E14     MOVLW 0x14
15376  6EE6     MOVWF 0xFE6, ACCESS
15378  0EAE     MOVLW 0xAE
1537A  6EE6     MOVWF 0xFE6, ACCESS
1537C  0E3D     MOVLW 0x3D
1537E  6EE6     MOVWF 0xFE6, ACCESS
15382  F480     NOP
15384  F009     NOP
15388  F484     NOP
1538A  F00A     NOP
1538C  0E00     MOVLW 0x0
1538E  BE0A     BTFSC ttemp3, 7, ACCESS
15390  0EFF     MOVLW 0xFF
15392  6E0B     MOVWF wtemp5, ACCESS
15394  6E0C     MOVWF 0xC, ACCESS
15398  F027     NOP
1539A  FFE6     NOP
1539E  F02B     NOP
153A0  FFE6     NOP
153A4  F02F     NOP
153A6  FFE6     NOP
153AA  F033     NOP
153AC  FFE6     NOP
153AE  0E01     MOVLW 0x1
153B0  6EE6     MOVWF 0xFE6, ACCESS
153B2  EC3D     CALL 0x1847A, 0
153B4  F0C2     NOP
153B8  F007     NOP
153BA  FFE6     NOP
153BE  F00B     NOP
153C0  FFE6     NOP
153C4  F00F     NOP
153C6  FFE6     NOP
153CA  F013     NOP
153CC  FFE6     NOP
153CE  0EF3     MOVLW 0xF3
153D0  50E3     MOVF 0xFE3, W, ACCESS
153D2  6EE6     MOVWF 0xFE6, ACCESS
153D4  EC22     CALL 0x1BE44, 0
153D6  F0DF     NOP
153DA  F004     NOP
153DC  F00B     NOP
153E0  F008     NOP
153E2  F00C     NOP
153E4  500B     MOVF wtemp5, W, ACCESS
153E6  6E05     MOVWF ltemp1, ACCESS
153E8  500C     MOVF 0xC, W, ACCESS
153EA  6E06     MOVWF 0x6, ACCESS
153EC  6A07     CLRF ttemp2, ACCESS
153EE  6A08     CLRF 0x8, ACCESS
153F2  F017     NOP
153F4  FFE6     NOP
153F8  F01B     NOP
153FA  FFE6     NOP
153FE  F01F     NOP
15400  FFE6     NOP
15404  F023     NOP
15406  FFE6     NOP
15408  0E00     MOVLW 0x0
1540A  6EE6     MOVWF 0xFE6, ACCESS
1540C  EC3D     CALL 0x1847A, 0
1540E  F0C2     NOP
15412  F007     NOP
15414  FFE6     NOP
15418  F00B     NOP
1541A  FFE6     NOP
1541E  F00F     NOP
15420  FFE6     NOP
15424  F013     NOP
15426  FFE6     NOP
15428  ECBF     CALL 0x1B57E, 0
1542A  F0DA     NOP
1542E  F007     NOP
15430  FFE6     NOP
15434  F00B     NOP
15436  FFE6     NOP
1543A  F00F     NOP
1543C  FFE6     NOP
15440  F013     NOP
15442  FFE6     NOP
15444  ECC1     CALL 0x13D82, 0
15446  F09E     NOP
1544A  F007     NOP
1544C  FFE6     NOP
15450  F00B     NOP
15452  FFE6     NOP
15456  F00F     NOP
15458  FFE6     NOP
1545C  F013     NOP
1545E  FFE6     NOP
15460  ECD6     CALL 0x145AC, 0
15462  F0A2     NOP
15464  D1C5     BRA 0x57F0
109:           			} else {
110:           				return R.n_zero[1]+((float) ((int16_t) get_raw_result(chan)) - R.n_offset[1]) * C_A100;
15468  F4A3     NOP
1546A  FFE6     NOP
1546E  F4A7     NOP
15470  FFE6     NOP
15474  F4AB     NOP
15476  FFE6     NOP
1547A  F4AF     NOP
1547C  FFE6     NOP
1547E  0E29     MOVLW 0x29
15480  6EE6     MOVWF 0xFE6, ACCESS
15482  0E5C     MOVLW 0x5C
15484  6EE6     MOVWF 0xFE6, ACCESS
15486  0E0F     MOVLW 0xF
15488  6EE6     MOVWF 0xFE6, ACCESS
1548A  0E3D     MOVLW 0x3D
1548C  6EE6     MOVWF 0xFE6, ACCESS
15490  F488     NOP
15492  F009     NOP
15496  F48C     NOP
15498  F00A     NOP
1549A  0E00     MOVLW 0x0
1549C  BE0A     BTFSC ttemp3, 7, ACCESS
1549E  0EFF     MOVLW 0xFF
154A0  6E0B     MOVWF wtemp5, ACCESS
154A2  6E0C     MOVWF 0xC, ACCESS
154A6  F027     NOP
154A8  FFE6     NOP
154AC  F02B     NOP
154AE  FFE6     NOP
154B2  F02F     NOP
154B4  FFE6     NOP
154B8  F033     NOP
154BA  FFE6     NOP
154BC  0E01     MOVLW 0x1
154BE  6EE6     MOVWF 0xFE6, ACCESS
154C0  EC3D     CALL 0x1847A, 0
154C2  F0C2     NOP
154C6  F007     NOP
154C8  FFE6     NOP
154CC  F00B     NOP
154CE  FFE6     NOP
154D2  F00F     NOP
154D4  FFE6     NOP
154D8  F013     NOP
154DA  FFE6     NOP
154DC  0EF3     MOVLW 0xF3
154DE  50E3     MOVF 0xFE3, W, ACCESS
154E0  6EE6     MOVWF 0xFE6, ACCESS
154E2  EC22     CALL 0x1BE44, 0
154E4  F0DF     NOP
154E8  F004     NOP
154EA  F00B     NOP
154EE  F008     NOP
154F0  F00C     NOP
154F2  500B     MOVF wtemp5, W, ACCESS
154F4  6E05     MOVWF ltemp1, ACCESS
154F6  500C     MOVF 0xC, W, ACCESS
154F8  6E06     MOVWF 0x6, ACCESS
154FA  6A07     CLRF ttemp2, ACCESS
154FC  6A08     CLRF 0x8, ACCESS
15500  F017     NOP
15502  FFE6     NOP
15506  F01B     NOP
15508  FFE6     NOP
1550C  F01F     NOP
1550E  FFE6     NOP
15512  F023     NOP
15514  FFE6     NOP
15516  0E00     MOVLW 0x0
15518  6EE6     MOVWF 0xFE6, ACCESS
1551A  EC3D     CALL 0x1847A, 0
1551C  F0C2     NOP
15520  F007     NOP
15522  FFE6     NOP
15526  F00B     NOP
15528  FFE6     NOP
1552C  F00F     NOP
1552E  FFE6     NOP
15532  F013     NOP
15534  FFE6     NOP
15536  ECBF     CALL 0x1B57E, 0
15538  F0DA     NOP
1553C  F007     NOP
1553E  FFE6     NOP
15542  F00B     NOP
15544  FFE6     NOP
15548  F00F     NOP
1554A  FFE6     NOP
1554E  F013     NOP
15550  FFE6     NOP
15552  ECC1     CALL 0x13D82, 0
15554  F09E     NOP
15558  F007     NOP
1555A  FFE6     NOP
1555E  F00B     NOP
15560  FFE6     NOP
15564  F00F     NOP
15566  FFE6     NOP
1556A  F013     NOP
1556C  FFE6     NOP
1556E  ECD6     CALL 0x145AC, 0
15570  F0A2     NOP
15572  D13E     BRA 0x57F0
111:           			}
112:           		} else {
113:           			if (ADC_T_CHAN >> chan & 0x1) { // temp conversion
15574  0EFF     MOVLW 0xFF
15578  FF8C     NOP
1557A  F00C     NOP
1557C  0E00     MOVLW 0x0
1557E  6E09     MOVWF ltemp2, ACCESS
15580  0E08     MOVLW 0x8
15582  6E0A     MOVWF ttemp3, ACCESS
15584  2A0C     INCF 0xC, F, ACCESS
15586  D003     BRA 0x558E
15588  340A     RLCF ttemp3, W, ACCESS
1558A  320A     RRCF ttemp3, F, ACCESS
1558C  3209     RRCF ltemp2, F, ACCESS
1558E  2E0C     DECFSZ 0xC, F, ACCESS
15590  D7FB     BRA 0x5588
15592  A009     BTFSS ltemp2, 0, ACCESS
15594  D008     BRA 0x55A6
114:           				return 25.0; // filler until sensor is selected
15596  0E00     MOVLW 0x0
15598  6E01     MOVWF ltemp0, ACCESS
1559A  0E00     MOVLW 0x0
1559C  6E02     MOVWF ttemp5, ACCESS
1559E  0EC8     MOVLW 0xC8
155A0  6E03     MOVWF wtemp1, ACCESS
155A2  0E41     MOVLW 0x41
155A4  D113     BRA 0x57CC
115:           			} else { // voltage conversion
116:           				return((float) get_raw_result(chan) * V_SCALE) / 1000.0;
155A6  0E00     MOVLW 0x0
155A8  6EE6     MOVWF 0xFE6, ACCESS
155AA  0E00     MOVLW 0x0
155AC  6EE6     MOVWF 0xFE6, ACCESS
155AE  0E7A     MOVLW 0x7A
155B0  6EE6     MOVWF 0xFE6, ACCESS
155B2  0E44     MOVLW 0x44
155B4  6EE6     MOVWF 0xFE6, ACCESS
155B6  0E61     MOVLW 0x61
155B8  6EE6     MOVWF 0xFE6, ACCESS
155BA  0E03     MOVLW 0x3
155BC  6EE6     MOVWF 0xFE6, ACCESS
155BE  0E84     MOVLW 0x84
155C0  6EE6     MOVWF 0xFE6, ACCESS
155C2  0E40     MOVLW 0x40
155C4  6EE6     MOVWF 0xFE6, ACCESS
155C6  0EF7     MOVLW 0xF7
155C8  50E3     MOVF 0xFE3, W, ACCESS
155CA  6EE6     MOVWF 0xFE6, ACCESS
155CC  EC22     CALL 0x1BE44, 0
155CE  F0DF     NOP
155D2  F004     NOP
155D4  F00B     NOP
155D8  F008     NOP
155DA  F00C     NOP
155DC  500B     MOVF wtemp5, W, ACCESS
155DE  6E05     MOVWF ltemp1, ACCESS
155E0  500C     MOVF 0xC, W, ACCESS
155E2  6E06     MOVWF 0x6, ACCESS
155E4  6A07     CLRF ttemp2, ACCESS
155E6  6A08     CLRF 0x8, ACCESS
155EA  F017     NOP
155EC  FFE6     NOP
155F0  F01B     NOP
155F2  FFE6     NOP
155F6  F01F     NOP
155F8  FFE6     NOP
155FC  F023     NOP
155FE  FFE6     NOP
15600  0E00     MOVLW 0x0
15602  6EE6     MOVWF 0xFE6, ACCESS
15604  EC3D     CALL 0x1847A, 0
15606  F0C2     NOP
1560A  F007     NOP
1560C  FFE6     NOP
15610  F00B     NOP
15612  FFE6     NOP
15616  F00F     NOP
15618  FFE6     NOP
1561C  F013     NOP
1561E  FFE6     NOP
15620  ECC1     CALL 0x13D82, 0
15622  F09E     NOP
15626  F007     NOP
15628  FFE6     NOP
1562C  F00B     NOP
1562E  FFE6     NOP
15632  F00F     NOP
15634  FFE6     NOP
15638  F013     NOP
1563A  FFE6     NOP
1563C  ECB4     CALL 0x14D68, 0
1563E  F0A6     NOP
15640  D0D7     BRA 0x57F0
117:           			}
118:           		}
119:           		break;
120:           	case O_CONV:
121:           		if (ADC_C_CHAN >> chan & 0x1 || ADC_T_CHAN >> chan & 0x1)
15642  0EFF     MOVLW 0xFF
15646  FF8C     NOP
15648  F00C     NOP
1564A  0E03     MOVLW 0x3
1564C  6E09     MOVWF ltemp2, ACCESS
1564E  0E00     MOVLW 0x0
15650  6E0A     MOVWF ttemp3, ACCESS
15652  2A0C     INCF 0xC, F, ACCESS
15654  D003     BRA 0x565C
15656  340A     RLCF ttemp3, W, ACCESS
15658  320A     RRCF ttemp3, F, ACCESS
1565A  3209     RRCF ltemp2, F, ACCESS
1565C  2E0C     DECFSZ 0xC, F, ACCESS
1565E  D7FB     BRA 0x5656
15660  B009     BTFSC ltemp2, 0, ACCESS
15662  D011     BRA 0x5686
15664  0EFF     MOVLW 0xFF
15668  FF8C     NOP
1566A  F00C     NOP
1566C  0E00     MOVLW 0x0
1566E  6E09     MOVWF ltemp2, ACCESS
15670  0E08     MOVLW 0x8
15672  6E0A     MOVWF ttemp3, ACCESS
15674  2A0C     INCF 0xC, F, ACCESS
15676  D003     BRA 0x567E
15678  340A     RLCF ttemp3, W, ACCESS
1567A  320A     RRCF ttemp3, F, ACCESS
1567C  3209     RRCF ltemp2, F, ACCESS
1567E  2E0C     DECFSZ 0xC, F, ACCESS
15680  D7FB     BRA 0x5678
15682  A009     BTFSS ltemp2, 0, ACCESS
15684  D04E     BRA 0x5722
122:           			return((float) get_raw_result(chan) * C_SCALE) / 1000.0;
15686  0E00     MOVLW 0x0
15688  6EE6     MOVWF 0xFE6, ACCESS
1568A  0E00     MOVLW 0x0
1568C  6EE6     MOVWF 0xFE6, ACCESS
1568E  0E7A     MOVLW 0x7A
15690  6EE6     MOVWF 0xFE6, ACCESS
15692  0E44     MOVLW 0x44
15694  6EE6     MOVWF 0xFE6, ACCESS
15696  0E00     MOVLW 0x0
15698  6EE6     MOVWF 0xFE6, ACCESS
1569A  0E00     MOVLW 0x0
1569C  6EE6     MOVWF 0xFE6, ACCESS
1569E  0E20     MOVLW 0x20
156A0  6EE6     MOVWF 0xFE6, ACCESS
156A2  0E3F     MOVLW 0x3F
156A4  6EE6     MOVWF 0xFE6, ACCESS
156A6  0EF7     MOVLW 0xF7
156A8  50E3     MOVF 0xFE3, W, ACCESS
156AA  6EE6     MOVWF 0xFE6, ACCESS
156AC  EC22     CALL 0x1BE44, 0
156AE  F0DF     NOP
156B2  F004     NOP
156B4  F00B     NOP
156B8  F008     NOP
156BA  F00C     NOP
156BC  500B     MOVF wtemp5, W, ACCESS
156BE  6E05     MOVWF ltemp1, ACCESS
156C0  500C     MOVF 0xC, W, ACCESS
156C2  6E06     MOVWF 0x6, ACCESS
156C4  6A07     CLRF ttemp2, ACCESS
156C6  6A08     CLRF 0x8, ACCESS
156CA  F017     NOP
156CC  FFE6     NOP
156D0  F01B     NOP
156D2  FFE6     NOP
156D6  F01F     NOP
156D8  FFE6     NOP
156DC  F023     NOP
156DE  FFE6     NOP
156E0  0E00     MOVLW 0x0
156E2  6EE6     MOVWF 0xFE6, ACCESS
156E4  EC3D     CALL 0x1847A, 0
156E6  F0C2     NOP
156EA  F007     NOP
156EC  FFE6     NOP
156F0  F00B     NOP
156F2  FFE6     NOP
156F6  F00F     NOP
156F8  FFE6     NOP
156FC  F013     NOP
156FE  FFE6     NOP
15700  ECC1     CALL 0x13D82, 0
15702  F09E     NOP
15706  F007     NOP
15708  FFE6     NOP
1570C  F00B     NOP
1570E  FFE6     NOP
15712  F00F     NOP
15714  FFE6     NOP
15718  F013     NOP
1571A  FFE6     NOP
1571C  ECB4     CALL 0x14D68, 0
1571E  F0A6     NOP
15720  D067     BRA 0x57F0
123:           
124:           		return((float) get_raw_result(chan) * V_SCALE) / 1000.0;
15722  0E00     MOVLW 0x0
15724  6EE6     MOVWF 0xFE6, ACCESS
15726  0E00     MOVLW 0x0
15728  6EE6     MOVWF 0xFE6, ACCESS
1572A  0E7A     MOVLW 0x7A
1572C  6EE6     MOVWF 0xFE6, ACCESS
1572E  0E44     MOVLW 0x44
15730  6EE6     MOVWF 0xFE6, ACCESS
15732  0E61     MOVLW 0x61
15734  6EE6     MOVWF 0xFE6, ACCESS
15736  0E03     MOVLW 0x3
15738  6EE6     MOVWF 0xFE6, ACCESS
1573A  0E84     MOVLW 0x84
1573C  6EE6     MOVWF 0xFE6, ACCESS
1573E  0E40     MOVLW 0x40
15740  6EE6     MOVWF 0xFE6, ACCESS
15742  0EF7     MOVLW 0xF7
15744  50E3     MOVF 0xFE3, W, ACCESS
15746  6EE6     MOVWF 0xFE6, ACCESS
15748  EC22     CALL 0x1BE44, 0
1574A  F0DF     NOP
1574E  F004     NOP
15750  F00B     NOP
15754  F008     NOP
15756  F00C     NOP
15758  500B     MOVF wtemp5, W, ACCESS
1575A  6E05     MOVWF ltemp1, ACCESS
1575C  500C     MOVF 0xC, W, ACCESS
1575E  6E06     MOVWF 0x6, ACCESS
15760  6A07     CLRF ttemp2, ACCESS
15762  6A08     CLRF 0x8, ACCESS
15766  F017     NOP
15768  FFE6     NOP
1576C  F01B     NOP
1576E  FFE6     NOP
15772  F01F     NOP
15774  FFE6     NOP
15778  F023     NOP
1577A  FFE6     NOP
1577C  0E00     MOVLW 0x0
1577E  6EE6     MOVWF 0xFE6, ACCESS
15780  EC3D     CALL 0x1847A, 0
15782  F0C2     NOP
15786  F007     NOP
15788  FFE6     NOP
1578C  F00B     NOP
1578E  FFE6     NOP
15792  F00F     NOP
15794  FFE6     NOP
15798  F013     NOP
1579A  FFE6     NOP
1579C  ECC1     CALL 0x13D82, 0
1579E  F09E     NOP
157A2  F007     NOP
157A4  FFE6     NOP
157A8  F00B     NOP
157AA  FFE6     NOP
157AE  F00F     NOP
157B0  FFE6     NOP
157B4  F013     NOP
157B6  FFE6     NOP
157B8  ECB4     CALL 0x14D68, 0
157BA  F0A6     NOP
157BC  D019     BRA 0x57F0
125:           		break;
126:           	default:
127:           		return 0.0;
157BE  0E00     MOVLW 0x0
157C0  6E01     MOVWF ltemp0, ACCESS
157C2  0E00     MOVLW 0x0
157C4  6E02     MOVWF ttemp5, ACCESS
157C6  0E00     MOVLW 0x0
157C8  6E03     MOVWF wtemp1, ACCESS
157CA  0E00     MOVLW 0x0
157CC  6E04     MOVWF ttemp1, ACCESS
157CE  D010     BRA 0x57F0
128:           		break;
129:           	}
157D0  0EFE     MOVLW 0xFE
157D2  50E3     MOVF 0xFE3, W, ACCESS
157D4  6E0B     MOVWF wtemp5, ACCESS
157D6  6A0C     CLRF 0xC, ACCESS
157D8  500C     MOVF 0xC, W, ACCESS
157DA  0A00     XORLW 0x0
157DC  A4D8     BTFSS 0xFD8, 2, ACCESS
157DE  D7EF     BRA 0x57BE
157E0  500B     MOVF wtemp5, W, ACCESS
157E2  0A00     XORLW 0x0
157E4  B4D8     BTFSC 0xFD8, 2, ACCESS
157E6  D57E     BRA 0x52E4
157E8  0A01     XORLW 0x1
157EA  B4D8     BTFSC 0xFD8, 2, ACCESS
157EC  D72A     BRA 0x5642
157EE  D7E7     BRA 0x57BE
130:           	return 0.0;
131:           }
157F0  52E5     MOVF 0xFE5, F, ACCESS
157F2  52E5     MOVF 0xFE5, F, ACCESS
157F4  0012     RETURN 0
132:           
133:           /*
134:            * ADC per conversion interrupt
135:            */
136:           static void adc_int_handler(void)
137:           {
138:           #ifdef DEBUG_DAQ2
139:           	DEBUG2_Toggle();
140:           #endif
141:           }
1C166  0012     RETURN 0
142:           
143:           /*
144:            * ADC per channel average interrupt
145:            */
146:           static void adc_int_t_handler(void)
147:           {
148:           	/*
149:           	 * use the filter result buffer for raw adc data
150:           	 */
151:           	R.raw_adc[R.scan_index] = ((adc_result_t) ((ADFLTRH << 8) + ADFLTRL));
1AD5C  013E     MOVLB 0x3E
1AD5E  51E6     MOVF 0xE6, W, BANKED
1AD62  FB9C     NOP
1AD64  F001     NOP
1AD66  6A02     CLRF ttemp5, ACCESS
1AD6A  F004     NOP
1AD6C  F002     NOP
1AD6E  6A01     CLRF ltemp0, ACCESS
1AD70  2601     ADDWF ltemp0, F, ACCESS
1AD72  0E00     MOVLW 0x0
1AD74  2202     ADDWFC ttemp5, F, ACCESS
1AD76  0101     MOVLB 0x1
1AD78  512C     MOVF 0x2C, W, BANKED
1AD7A  0D02     MULLW 0x2
1AD7C  0E00     MOVLW 0x0
1AD7E  24F3     ADDWF 0xFF3, W, ACCESS
1AD80  6ED9     MOVWF 0xFD9, ACCESS
1AD82  0E01     MOVLW 0x1
1AD84  20F4     ADDWFC 0xFF4, W, ACCESS
1AD86  6EDA     MOVWF 0xFDA, ACCESS
1AD8A  F007     NOP
1AD8C  FFDE     NOP
1AD90  F00B     NOP
1AD92  FFDD     NOP
152:           	do {
153:           		if (++R.scan_index > LAST_ADC_CHAN) {
1AD94  0101     MOVLB 0x1
1AD96  2B2C     INCF 0x2C, F, BANKED
1AD98  0E0D     MOVLW 0xD
1AD9A  652C     CPFSGT 0x2C, BANKED
1AD9C  D003     BRA 0xADA4
154:           			R.done = true;
1AD9E  0E01     MOVLW 0x1
1ADA0  6F2F     MOVWF 0x2F, BANKED
1ADA2  0012     RETURN 0
155:           #ifdef DEBUG_DAQ1
156:           			DEBUG1_SetLow();
157:           #endif
158:           			return;
159:           		}
160:           	} while (!((R.scan_select >> R.scan_index) &0x1)); // check for analog port bit
1ADA6  F4B0     NOP
1ADA8  F00C     NOP
1ADAA  EE20     LFSR 2, 0x12D
1ADAC  F12D     NOP
1ADB0  FF78     NOP
1ADB2  F009     NOP
1ADB6  FF74     NOP
1ADB8  F00A     NOP
1ADBA  2A0C     INCF 0xC, F, ACCESS
1ADBC  D003     BRA 0xADC4
1ADBE  90D8     BCF 0xFD8, 0, ACCESS
1ADC0  320A     RRCF ttemp3, F, ACCESS
1ADC2  3209     RRCF ltemp2, F, ACCESS
1ADC4  2E0C     DECFSZ 0xC, F, ACCESS
1ADC6  D7FB     BRA 0xADBE
1ADC8  A009     BTFSS ltemp2, 0, ACCESS
1ADCA  D7E4     BRA 0xAD94
161:           	ADCC_DischargeSampleCapacitor(); // short ADC sample cap before next channel sampling
1ADCC  EC8B     CALL 0x1C116, 0
1ADCE  F0E0     NOP
162:           	ADCC_StartConversion(R.scan_index & 0xf);
1ADD0  0101     MOVLB 0x1
1ADD2  512C     MOVF 0x2C, W, BANKED
1ADD4  0B0F     ANDLW 0xF
1ADD6  6EE6     MOVWF 0xFE6, ACCESS
1ADD8  EC1A     CALL 0x1C034, 0
1ADDA  F0E0     NOP
163:           #ifdef DEBUG_DAQ1
164:           	DEBUG1_Toggle();
165:           #endif
166:           }
1ADDC  0012     RETURN 0
---  /root/MPLABXProjects/vtouch_v2/touch_v2.X/bsoc.c  --------------------------------------------------
1:             #include "bsoc.h"
2:             #include "mcc_generated_files/interrupt_manager.h"
3:             
4:             extern C_data C;
5:             extern V_data V;
6:             
7:             const uint32_t BVSOC_TABLE[BVSOC_SLOTS][2] = {
8:             	23000, 5,
9:             	23400, 10,
10:            	23600, 20,
11:            	24120, 25,
12:            	24200, 30,
13:            	24440, 40,
14:            	24540, 45,
15:            	24600, 50,
16:            	24646, 53,
17:            	24700, 55,
18:            	24750, 57,
19:            	24800, 60,
20:            	24850, 63,
21:            	24925, 67,
22:            	25000, 70,
23:            	25020, 72,
24:            	25040, 75,
25:            	25050, 80,
26:            	25060, 85,
27:            	25080, 90,
28:            	25096, 92,
29:            	25122, 93,
30:            	25140, 95,
31:            	25160, 97,
32:            	25180, 100,
33:            	26500, 98 // charging voltage guess
34:            };
35:            
36:            /*
37:             * low-pri interrupt ISR the runs every second for simple coulomb counting
38:             */
39:            void calc_bsoc(void)
1334C  0E06     MOVLW 0x6
1334E  26E1     ADDWF 0xFE1, F, ACCESS
13350  0E00     MOVLW 0x0
13352  22E2     ADDWFC 0xFE2, F, ACCESS
40:            {
41:            	uint8_t * log_ptr;
42:            	static uint8_t log_update_wait = 0;
43:            	float adj = 1.0;
13354  0E00     MOVLW 0x0
13356  6E09     MOVWF ltemp2, ACCESS
13358  0E00     MOVLW 0x0
1335A  6E0A     MOVWF ttemp3, ACCESS
1335C  0E80     MOVLW 0x80
1335E  6E0B     MOVWF wtemp5, ACCESS
13360  0E3F     MOVLW 0x3F
13362  6E0C     MOVWF 0xC, ACCESS
13364  0EFA     MOVLW 0xFA
13368  F027     NOP
1336A  FFE3     NOP
1336C  0EFB     MOVLW 0xFB
13370  F02B     NOP
13372  FFE3     NOP
13374  0EFC     MOVLW 0xFC
13378  F02F     NOP
1337A  FFE3     NOP
1337C  0EFD     MOVLW 0xFD
13380  F033     NOP
13382  FFE3     NOP
44:            #ifdef DEBUG_BSOC1
45:            	DEBUG1_SetHigh();
13384  82BE     BSF 0xFBE, 1, ACCESS
46:            #endif
47:            	C.dynamic_ah += (C.c_bat / SSLICE); // Ah
13386  0E00     MOVLW 0x0
13388  6EE6     MOVWF 0xFE6, ACCESS
1338A  0E00     MOVLW 0x0
1338C  6EE6     MOVWF 0xFE6, ACCESS
1338E  0E61     MOVLW 0x61
13390  6EE6     MOVWF 0xFE6, ACCESS
13392  0E45     MOVLW 0x45
13394  6EE6     MOVWF 0xFE6, ACCESS
13396  EE21     LFSR 2, 0x743
13398  F343     NOP
1339C  FF7B     NOP
1339E  FFE6     NOP
133A2  FF7B     NOP
133A4  FFE6     NOP
133A8  FF7B     NOP
133AA  FFE6     NOP
133AE  FF7B     NOP
133B0  FFE6     NOP
133B2  ECB4     CALL 0x14D68, 0
133B4  F0A6     NOP
133B8  F007     NOP
133BA  FFE6     NOP
133BE  F00B     NOP
133C0  FFE6     NOP
133C4  F00F     NOP
133C6  FFE6     NOP
133CA  F013     NOP
133CC  FFE6     NOP
133CE  0E8F     MOVLW 0x8F
133D0  6EE6     MOVWF 0xFE6, ACCESS
133D2  0E07     MOVLW 0x7
133D4  6EE6     MOVWF 0xFE6, ACCESS
133D6  ECEF     CALL 0x1ADDE, 0
133D8  F0D6     NOP
48:            	if (C.dynamic_ah > (C.bank_ah))
133DA  EE21     LFSR 2, 0x78F
133DC  F38F     NOP
133E0  FF7B     NOP
133E2  FFE6     NOP
133E6  FF7B     NOP
133E8  FFE6     NOP
133EC  FF7B     NOP
133EE  FFE6     NOP
133F2  FF7B     NOP
133F4  FFE6     NOP
133F6  EE21     LFSR 2, 0x78B
133F8  F38B     NOP
133FC  FF7B     NOP
133FE  FFE6     NOP
13402  FF7B     NOP
13404  FFE6     NOP
13408  FF7B     NOP
1340A  FFE6     NOP
1340E  FF7B     NOP
13410  FFE6     NOP
13412  ECF4     CALL 0x18FE8, 0
13414  F0C7     NOP
13416  B001     BTFSC ltemp0, 0, ACCESS
13418  D00E     BRA 0x3436
49:            		C.dynamic_ah = C.bank_ah;
1341A  EE21     LFSR 2, 0x78B
1341C  F38B     NOP
13420  FF78     NOP
13422  F78F     NOP
13426  FF78     NOP
13428  F790     NOP
1342C  FF78     NOP
1342E  F791     NOP
13432  FF74     NOP
13434  F792     NOP
50:            	if (C.dynamic_ah < 0.1)
13436  0ECD     MOVLW 0xCD
13438  6EE6     MOVWF 0xFE6, ACCESS
1343A  0ECC     MOVLW 0xCC
1343C  6EE6     MOVWF 0xFE6, ACCESS
1343E  0ECC     MOVLW 0xCC
13440  6EE6     MOVWF 0xFE6, ACCESS
13442  0E3D     MOVLW 0x3D
13444  6EE6     MOVWF 0xFE6, ACCESS
13446  EE21     LFSR 2, 0x78F
13448  F38F     NOP
1344C  FF7B     NOP
1344E  FFE6     NOP
13452  FF7B     NOP
13454  FFE6     NOP
13458  FF7B     NOP
1345A  FFE6     NOP
1345E  FF7B     NOP
13460  FFE6     NOP
13462  ECF4     CALL 0x18FE8, 0
13464  F0C7     NOP
13466  B001     BTFSC ltemp0, 0, ACCESS
13468  D010     BRA 0x348A
51:            		C.dynamic_ah = 0.1;
1346A  0ECD     MOVLW 0xCD
1346E  FFA0     NOP
13470  F78F     NOP
13472  0ECC     MOVLW 0xCC
13476  FFA0     NOP
13478  F790     NOP
1347A  0ECC     MOVLW 0xCC
1347E  FFA0     NOP
13480  F791     NOP
13482  0E3D     MOVLW 0x3D
13486  FFA0     NOP
13488  F792     NOP
52:            
53:            	if (C.c_bat > 0.01)
1348A  EE21     LFSR 2, 0x743
1348C  F343     NOP
13490  FF7B     NOP
13492  FFE6     NOP
13496  FF7B     NOP
13498  FFE6     NOP
1349C  FF7B     NOP
1349E  FFE6     NOP
134A2  FF7B     NOP
134A4  FFE6     NOP
134A6  0E0A     MOVLW 0xA
134A8  6EE6     MOVWF 0xFE6, ACCESS
134AA  0ED7     MOVLW 0xD7
134AC  6EE6     MOVWF 0xFE6, ACCESS
134AE  0E23     MOVLW 0x23
134B0  6EE6     MOVWF 0xFE6, ACCESS
134B2  0E3C     MOVLW 0x3C
134B4  6EE6     MOVWF 0xFE6, ACCESS
134B6  ECF4     CALL 0x18FE8, 0
134B8  F0C7     NOP
134BA  B001     BTFSC ltemp0, 0, ACCESS
134BC  D01C     BRA 0x34F6
54:            		adj = C.hist[0].cef;
134C0  FEF4     NOP
134C2  F009     NOP
134C6  FEF8     NOP
134C8  F00A     NOP
134CC  FEFC     NOP
134CE  F00B     NOP
134D2  FF00     NOP
134D4  F00C     NOP
134D6  0EFA     MOVLW 0xFA
134DA  F027     NOP
134DC  FFE3     NOP
134DE  0EFB     MOVLW 0xFB
134E2  F02B     NOP
134E4  FFE3     NOP
134E6  0EFC     MOVLW 0xFC
134EA  F02F     NOP
134EC  FFE3     NOP
134EE  0EFD     MOVLW 0xFD
134F2  F033     NOP
134F4  FFE3     NOP
55:            	if (C.c_bat < 0.01)
134F6  0E0A     MOVLW 0xA
134F8  6EE6     MOVWF 0xFE6, ACCESS
134FA  0ED7     MOVLW 0xD7
134FC  6EE6     MOVWF 0xFE6, ACCESS
134FE  0E23     MOVLW 0x23
13500  6EE6     MOVWF 0xFE6, ACCESS
13502  0E3C     MOVLW 0x3C
13504  6EE6     MOVWF 0xFE6, ACCESS
13506  EE21     LFSR 2, 0x743
13508  F343     NOP
1350C  FF7B     NOP
1350E  FFE6     NOP
13512  FF7B     NOP
13514  FFE6     NOP
13518  FF7B     NOP
1351A  FFE6     NOP
1351E  FF7B     NOP
13520  FFE6     NOP
13522  ECF4     CALL 0x18FE8, 0
13524  F0C7     NOP
13526  B001     BTFSC ltemp0, 0, ACCESS
13528  D01C     BRA 0x3562
56:            		adj = C.hist[0].peukert;
1352C  FEE4     NOP
1352E  F009     NOP
13532  FEE8     NOP
13534  F00A     NOP
13538  FEEC     NOP
1353A  F00B     NOP
1353E  FEF0     NOP
13540  F00C     NOP
13542  0EFA     MOVLW 0xFA
13546  F027     NOP
13548  FFE3     NOP
1354A  0EFB     MOVLW 0xFB
1354E  F02B     NOP
13550  FFE3     NOP
13552  0EFC     MOVLW 0xFC
13556  F02F     NOP
13558  FFE3     NOP
1355A  0EFD     MOVLW 0xFD
1355E  F033     NOP
13560  FFE3     NOP
57:            	C.dynamic_ah += ((C.c_bat * adj) / SSLICE); // Ah
13562  0E00     MOVLW 0x0
13564  6EE6     MOVWF 0xFE6, ACCESS
13566  0E00     MOVLW 0x0
13568  6EE6     MOVWF 0xFE6, ACCESS
1356A  0E61     MOVLW 0x61
1356C  6EE6     MOVWF 0xFE6, ACCESS
1356E  0E45     MOVLW 0x45
13570  6EE6     MOVWF 0xFE6, ACCESS
13572  0EF6     MOVLW 0xF6
13576  FF8F     NOP
13578  FFE6     NOP
1357C  FF8F     NOP
1357E  FFE6     NOP
13582  FF8F     NOP
13584  FFE6     NOP
13588  FF8F     NOP
1358A  FFE6     NOP
1358C  EE21     LFSR 2, 0x743
1358E  F343     NOP
13592  FF7B     NOP
13594  FFE6     NOP
13598  FF7B     NOP
1359A  FFE6     NOP
1359E  FF7B     NOP
135A0  FFE6     NOP
135A4  FF7B     NOP
135A6  FFE6     NOP
135A8  ECC1     CALL 0x13D82, 0
135AA  F09E     NOP
135AE  F007     NOP
135B0  FFE6     NOP
135B4  F00B     NOP
135B6  FFE6     NOP
135BA  F00F     NOP
135BC  FFE6     NOP
135C0  F013     NOP
135C2  FFE6     NOP
135C4  ECB4     CALL 0x14D68, 0
135C6  F0A6     NOP
135CA  F007     NOP
135CC  FFE6     NOP
135D0  F00B     NOP
135D2  FFE6     NOP
135D6  F00F     NOP
135D8  FFE6     NOP
135DC  F013     NOP
135DE  FFE6     NOP
135E0  0E8F     MOVLW 0x8F
135E2  6EE6     MOVWF 0xFE6, ACCESS
135E4  0E07     MOVLW 0x7
135E6  6EE6     MOVWF 0xFE6, ACCESS
135E8  ECEF     CALL 0x1ADDE, 0
135EA  F0D6     NOP
58:            
59:            	C.dynamic_ah_adj = C.dynamic_ah; // need to add peukert factor here
135EC  EE21     LFSR 2, 0x78F
135EE  F38F     NOP
135F2  FF78     NOP
135F4  F79B     NOP
135F8  FF78     NOP
135FA  F79C     NOP
135FE  FF78     NOP
13600  F79D     NOP
13604  FF74     NOP
13606  F79E     NOP
60:            	if (C.dynamic_ah_adj > (C.bank_ah))
13608  EE21     LFSR 2, 0x79B
1360A  F39B     NOP
1360E  FF7B     NOP
13610  FFE6     NOP
13614  FF7B     NOP
13616  FFE6     NOP
1361A  FF7B     NOP
1361C  FFE6     NOP
13620  FF7B     NOP
13622  FFE6     NOP
13624  EE21     LFSR 2, 0x78B
13626  F38B     NOP
1362A  FF7B     NOP
1362C  FFE6     NOP
13630  FF7B     NOP
13632  FFE6     NOP
13636  FF7B     NOP
13638  FFE6     NOP
1363C  FF7B     NOP
1363E  FFE6     NOP
13640  ECF4     CALL 0x18FE8, 0
13642  F0C7     NOP
13644  B001     BTFSC ltemp0, 0, ACCESS
13646  D00E     BRA 0x3664
61:            		C.dynamic_ah_adj = C.bank_ah;
13648  EE21     LFSR 2, 0x78B
1364A  F38B     NOP
1364E  FF78     NOP
13650  F79B     NOP
13654  FF78     NOP
13656  F79C     NOP
1365A  FF78     NOP
1365C  F79D     NOP
13660  FF74     NOP
13662  F79E     NOP
62:            	if (C.dynamic_ah_adj < 0.1)
13664  0ECD     MOVLW 0xCD
13666  6EE6     MOVWF 0xFE6, ACCESS
13668  0ECC     MOVLW 0xCC
1366A  6EE6     MOVWF 0xFE6, ACCESS
1366C  0ECC     MOVLW 0xCC
1366E  6EE6     MOVWF 0xFE6, ACCESS
13670  0E3D     MOVLW 0x3D
13672  6EE6     MOVWF 0xFE6, ACCESS
13674  EE21     LFSR 2, 0x79B
13676  F39B     NOP
1367A  FF7B     NOP
1367C  FFE6     NOP
13680  FF7B     NOP
13682  FFE6     NOP
13686  FF7B     NOP
13688  FFE6     NOP
1368C  FF7B     NOP
1368E  FFE6     NOP
13690  ECF4     CALL 0x18FE8, 0
13692  F0C7     NOP
13694  B001     BTFSC ltemp0, 0, ACCESS
13696  D010     BRA 0x36B8
63:            		C.dynamic_ah_adj = 0.1;
13698  0ECD     MOVLW 0xCD
1369C  FFA0     NOP
1369E  F79B     NOP
136A0  0ECC     MOVLW 0xCC
136A4  FFA0     NOP
136A6  F79C     NOP
136A8  0ECC     MOVLW 0xCC
136AC  FFA0     NOP
136AE  F79D     NOP
136B0  0E3D     MOVLW 0x3D
136B4  FFA0     NOP
136B6  F79E     NOP
64:            
65:            
66:            	C.pv_ah += (C.c_pv / SSLICE);
136B8  0E00     MOVLW 0x0
136BA  6EE6     MOVWF 0xFE6, ACCESS
136BC  0E00     MOVLW 0x0
136BE  6EE6     MOVWF 0xFE6, ACCESS
136C0  0E61     MOVLW 0x61
136C2  6EE6     MOVWF 0xFE6, ACCESS
136C4  0E45     MOVLW 0x45
136C6  6EE6     MOVWF 0xFE6, ACCESS
136C8  EE21     LFSR 2, 0x747
136CA  F347     NOP
136CE  FF7B     NOP
136D0  FFE6     NOP
136D4  FF7B     NOP
136D6  FFE6     NOP
136DA  FF7B     NOP
136DC  FFE6     NOP
136E0  FF7B     NOP
136E2  FFE6     NOP
136E4  ECB4     CALL 0x14D68, 0
136E6  F0A6     NOP
136EA  F007     NOP
136EC  FFE6     NOP
136F0  F00B     NOP
136F2  FFE6     NOP
136F6  F00F     NOP
136F8  FFE6     NOP
136FC  F013     NOP
136FE  FFE6     NOP
13700  0E93     MOVLW 0x93
13702  6EE6     MOVWF 0xFE6, ACCESS
13704  0E07     MOVLW 0x7
13706  6EE6     MOVWF 0xFE6, ACCESS
13708  ECEF     CALL 0x1ADDE, 0
1370A  F0D6     NOP
67:            	C.pvkw += (C.p_pv / SSLICE);
1370C  0E00     MOVLW 0x0
1370E  6EE6     MOVWF 0xFE6, ACCESS
13710  0E00     MOVLW 0x0
13712  6EE6     MOVWF 0xFE6, ACCESS
13714  0E61     MOVLW 0x61
13716  6EE6     MOVWF 0xFE6, ACCESS
13718  0E45     MOVLW 0x45
1371A  6EE6     MOVWF 0xFE6, ACCESS
1371C  EE21     LFSR 2, 0x77B
1371E  F37B     NOP
13722  FF7B     NOP
13724  FFE6     NOP
13728  FF7B     NOP
1372A  FFE6     NOP
1372E  FF7B     NOP
13730  FFE6     NOP
13734  FF7B     NOP
13736  FFE6     NOP
13738  ECB4     CALL 0x14D68, 0
1373A  F0A6     NOP
1373E  F007     NOP
13740  FFE6     NOP
13744  F00B     NOP
13746  FFE6     NOP
1374A  F00F     NOP
1374C  FFE6     NOP
13750  F013     NOP
13752  FFE6     NOP
13754  0EA7     MOVLW 0xA7
13756  6EE6     MOVWF 0xFE6, ACCESS
13758  0E07     MOVLW 0x7
1375A  6EE6     MOVWF 0xFE6, ACCESS
1375C  ECEF     CALL 0x1ADDE, 0
1375E  F0D6     NOP
68:            	C.invkw += (C.p_inverter / SSLICE);
13760  0E00     MOVLW 0x0
13762  6EE6     MOVWF 0xFE6, ACCESS
13764  0E00     MOVLW 0x0
13766  6EE6     MOVWF 0xFE6, ACCESS
13768  0E61     MOVLW 0x61
1376A  6EE6     MOVWF 0xFE6, ACCESS
1376C  0E45     MOVLW 0x45
1376E  6EE6     MOVWF 0xFE6, ACCESS
13770  EE21     LFSR 2, 0x777
13772  F377     NOP
13776  FF7B     NOP
13778  FFE6     NOP
1377C  FF7B     NOP
1377E  FFE6     NOP
13782  FF7B     NOP
13784  FFE6     NOP
13788  FF7B     NOP
1378A  FFE6     NOP
1378C  ECB4     CALL 0x14D68, 0
1378E  F0A6     NOP
13792  F007     NOP
13794  FFE6     NOP
13798  F00B     NOP
1379A  FFE6     NOP
1379E  F00F     NOP
137A0  FFE6     NOP
137A4  F013     NOP
137A6  FFE6     NOP
137A8  0EAB     MOVLW 0xAB
137AA  6EE6     MOVWF 0xFE6, ACCESS
137AC  0E07     MOVLW 0x7
137AE  6EE6     MOVWF 0xFE6, ACCESS
137B0  ECEF     CALL 0x1ADDE, 0
137B2  F0D6     NOP
69:            	C.loadkw += (C.p_load / SSLICE);
137B4  0E00     MOVLW 0x0
137B6  6EE6     MOVWF 0xFE6, ACCESS
137B8  0E00     MOVLW 0x0
137BA  6EE6     MOVWF 0xFE6, ACCESS
137BC  0E61     MOVLW 0x61
137BE  6EE6     MOVWF 0xFE6, ACCESS
137C0  0E45     MOVLW 0x45
137C2  6EE6     MOVWF 0xFE6, ACCESS
137C4  EE21     LFSR 2, 0x773
137C6  F373     NOP
137CA  FF7B     NOP
137CC  FFE6     NOP
137D0  FF7B     NOP
137D2  FFE6     NOP
137D6  FF7B     NOP
137D8  FFE6     NOP
137DC  FF7B     NOP
137DE  FFE6     NOP
137E0  ECB4     CALL 0x14D68, 0
137E2  F0A6     NOP
137E6  F007     NOP
137E8  FFE6     NOP
137EC  F00B     NOP
137EE  FFE6     NOP
137F2  F00F     NOP
137F4  FFE6     NOP
137F8  F013     NOP
137FA  FFE6     NOP
137FC  0EAF     MOVLW 0xAF
137FE  6EE6     MOVWF 0xFE6, ACCESS
13800  0E07     MOVLW 0x7
13802  6EE6     MOVWF 0xFE6, ACCESS
13804  ECEF     CALL 0x1ADDE, 0
13806  F0D6     NOP
70:            	if (C.p_bat > 0.0)
13808  EE21     LFSR 2, 0x77F
1380A  F37F     NOP
1380E  FF7B     NOP
13810  FFE6     NOP
13814  FF7B     NOP
13816  FFE6     NOP
1381A  FF7B     NOP
1381C  FFE6     NOP
13820  FF7B     NOP
13822  FFE6     NOP
13824  0E00     MOVLW 0x0
13826  6EE6     MOVWF 0xFE6, ACCESS
13828  0E00     MOVLW 0x0
1382A  6EE6     MOVWF 0xFE6, ACCESS
1382C  0E00     MOVLW 0x0
1382E  6EE6     MOVWF 0xFE6, ACCESS
13830  0E00     MOVLW 0x0
13832  6EE6     MOVWF 0xFE6, ACCESS
13834  ECF4     CALL 0x18FE8, 0
13836  F0C7     NOP
13838  B001     BTFSC ltemp0, 0, ACCESS
1383A  D02A     BRA 0x3890
71:            		C.bkwi += (C.p_bat / SSLICE);
1383C  0E00     MOVLW 0x0
1383E  6EE6     MOVWF 0xFE6, ACCESS
13840  0E00     MOVLW 0x0
13842  6EE6     MOVWF 0xFE6, ACCESS
13844  0E61     MOVLW 0x61
13846  6EE6     MOVWF 0xFE6, ACCESS
13848  0E45     MOVLW 0x45
1384A  6EE6     MOVWF 0xFE6, ACCESS
1384C  EE21     LFSR 2, 0x77F
1384E  F37F     NOP
13852  FF7B     NOP
13854  FFE6     NOP
13858  FF7B     NOP
1385A  FFE6     NOP
1385E  FF7B     NOP
13860  FFE6     NOP
13864  FF7B     NOP
13866  FFE6     NOP
13868  ECB4     CALL 0x14D68, 0
1386A  F0A6     NOP
1386E  F007     NOP
13870  FFE6     NOP
13874  F00B     NOP
13876  FFE6     NOP
1387A  F00F     NOP
1387C  FFE6     NOP
13880  F013     NOP
13882  FFE6     NOP
13884  0E9F     MOVLW 0x9F
13886  6EE6     MOVWF 0xFE6, ACCESS
13888  0E07     MOVLW 0x7
1388A  6EE6     MOVWF 0xFE6, ACCESS
1388C  ECEF     CALL 0x1ADDE, 0
1388E  F0D6     NOP
72:            	if (C.p_bat < 0.0)
13890  EE21     LFSR 2, 0x77F
13892  F37F     NOP
13894  0E03     MOVLW 0x3
13896  AEDB     BTFSS 0xFDB, 7, ACCESS
13898  D038     BRA 0x390A
73:            		C.bkwo += fabs(C.p_bat / SSLICE);
1389A  0E00     MOVLW 0x0
1389C  6EE6     MOVWF 0xFE6, ACCESS
1389E  0E00     MOVLW 0x0
138A0  6EE6     MOVWF 0xFE6, ACCESS
138A2  0E61     MOVLW 0x61
138A4  6EE6     MOVWF 0xFE6, ACCESS
138A6  0E45     MOVLW 0x45
138A8  6EE6     MOVWF 0xFE6, ACCESS
138AA  EE21     LFSR 2, 0x77F
138AC  F37F     NOP
138B0  FF7B     NOP
138B2  FFE6     NOP
138B6  FF7B     NOP
138B8  FFE6     NOP
138BC  FF7B     NOP
138BE  FFE6     NOP
138C2  FF7B     NOP
138C4  FFE6     NOP
138C6  ECB4     CALL 0x14D68, 0
138C8  F0A6     NOP
138CC  F007     NOP
138CE  FFE6     NOP
138D2  F00B     NOP
138D4  FFE6     NOP
138D8  F00F     NOP
138DA  FFE6     NOP
138DE  F013     NOP
138E0  FFE6     NOP
138E2  ECC6     CALL 0x1A58C, 0
138E4  F0D2     NOP
138E8  F007     NOP
138EA  FFE6     NOP
138EE  F00B     NOP
138F0  FFE6     NOP
138F4  F00F     NOP
138F6  FFE6     NOP
138FA  F013     NOP
138FC  FFE6     NOP
138FE  0EA3     MOVLW 0xA3
13900  6EE6     MOVWF 0xFE6, ACCESS
13902  0E07     MOVLW 0x7
13904  6EE6     MOVWF 0xFE6, ACCESS
13906  ECEF     CALL 0x1ADDE, 0
13908  F0D6     NOP
74:            
75:            	C.soc = ((uint16_t) ((C.dynamic_ah_adj / C.bank_ah)*100.0) + 1);
1390A  0E00     MOVLW 0x0
1390C  6EE6     MOVWF 0xFE6, ACCESS
1390E  0E00     MOVLW 0x0
13910  6EE6     MOVWF 0xFE6, ACCESS
13912  0EC8     MOVLW 0xC8
13914  6EE6     MOVWF 0xFE6, ACCESS
13916  0E42     MOVLW 0x42
13918  6EE6     MOVWF 0xFE6, ACCESS
1391A  EE21     LFSR 2, 0x78B
1391C  F38B     NOP
13920  FF7B     NOP
13922  FFE6     NOP
13926  FF7B     NOP
13928  FFE6     NOP
1392C  FF7B     NOP
1392E  FFE6     NOP
13932  FF7B     NOP
13934  FFE6     NOP
13936  EE21     LFSR 2, 0x79B
13938  F39B     NOP
1393C  FF7B     NOP
1393E  FFE6     NOP
13942  FF7B     NOP
13944  FFE6     NOP
13948  FF7B     NOP
1394A  FFE6     NOP
1394E  FF7B     NOP
13950  FFE6     NOP
13952  ECB4     CALL 0x14D68, 0
13954  F0A6     NOP
13958  F007     NOP
1395A  FFE6     NOP
1395E  F00B     NOP
13960  FFE6     NOP
13964  F00F     NOP
13966  FFE6     NOP
1396A  F013     NOP
1396C  FFE6     NOP
1396E  ECC1     CALL 0x13D82, 0
13970  F09E     NOP
13974  F007     NOP
13976  FFE6     NOP
1397A  F00B     NOP
1397C  FFE6     NOP
13980  F00F     NOP
13982  FFE6     NOP
13986  F013     NOP
13988  FFE6     NOP
1398A  EC3B     CALL 0x18E76, 0
1398C  F0C7     NOP
13990  F004     NOP
13992  F00B     NOP
13996  F008     NOP
13998  F00C     NOP
1399A  0E01     MOVLW 0x1
1399C  260B     ADDWF wtemp5, F, ACCESS
1399E  0E00     MOVLW 0x0
139A0  220C     ADDWFC 0xC, F, ACCESS
139A4  F02C     NOP
139A6  F7B5     NOP
139AA  F030     NOP
139AC  F7B6     NOP
76:            	if (C.soc > 100)
139AE  EE21     LFSR 2, 0x7B5
139B0  F3B5     NOP
139B2  0E01     MOVLW 0x1
139B4  50DB     MOVF 0xFDB, W, ACCESS
139B6  E104     BNZ 0x39C0
139B8  0E65     MOVLW 0x65
139BA  5CDE     SUBWF 0xFDE, W, ACCESS
139BC  A0D8     BTFSS 0xFD8, 0, ACCESS
139BE  D008     BRA 0x39D0
77:            		C.soc = 100;
139C0  0E64     MOVLW 0x64
139C4  FFA0     NOP
139C6  F7B5     NOP
139C8  0E00     MOVLW 0x0
139CC  FFA0     NOP
139CE  F7B6     NOP
78:            
79:            	if (C.c_bat < 0.0) {
139D0  EE21     LFSR 2, 0x743
139D2  F343     NOP
139D4  0E03     MOVLW 0x3
139D6  AEDB     BTFSS 0xFDB, 7, ACCESS
139D8  D047     BRA 0x3A68
80:            		C.runtime = (uint16_t) (-(C.dynamic_ah_adj / C.c_bat));
139DA  EE21     LFSR 2, 0x743
139DC  F343     NOP
139E0  FF7B     NOP
139E2  FFE6     NOP
139E6  FF7B     NOP
139E8  FFE6     NOP
139EC  FF7B     NOP
139EE  FFE6     NOP
139F2  FF7B     NOP
139F4  FFE6     NOP
139F6  EE21     LFSR 2, 0x79B
139F8  F39B     NOP
139FC  FF7B     NOP
139FE  FFE6     NOP
13A02  FF7B     NOP
13A04  FFE6     NOP
13A08  FF7B     NOP
13A0A  FFE6     NOP
13A0E  FF7B     NOP
13A10  FFE6     NOP
13A12  ECB4     CALL 0x14D68, 0
13A14  F0A6     NOP
13A18  F007     NOP
13A1A  FFE6     NOP
13A1E  F00B     NOP
13A20  FFE6     NOP
13A24  F00F     NOP
13A26  FFE6     NOP
13A2A  F013     NOP
13A2C  FFE6     NOP
13A2E  EC0C     CALL 0x1B418, 0
13A30  F0DA     NOP
13A34  F007     NOP
13A36  FFE6     NOP
13A3A  F00B     NOP
13A3C  FFE6     NOP
13A40  F00F     NOP
13A42  FFE6     NOP
13A46  F013     NOP
13A48  FFE6     NOP
13A4A  EC3B     CALL 0x18E76, 0
13A4C  F0C7     NOP
13A50  F004     NOP
13A52  F00B     NOP
13A56  F008     NOP
13A58  F00C     NOP
13A5C  F02C     NOP
13A5E  F7B3     NOP
13A62  F030     NOP
13A64  F7B4     NOP
81:            	} else {
13A66  D008     BRA 0x3A78
82:            		C.runtime = 120;
13A68  0E78     MOVLW 0x78
13A6C  FFA0     NOP
13A6E  F7B3     NOP
13A70  0E00     MOVLW 0x0
13A74  FFA0     NOP
13A76  F7B4     NOP
83:            	}
84:            	if (C.runtime > 120)
13A78  EE21     LFSR 2, 0x7B3
13A7A  F3B3     NOP
13A7C  0E01     MOVLW 0x1
13A7E  50DB     MOVF 0xFDB, W, ACCESS
13A80  E104     BNZ 0x3A8A
13A82  0E79     MOVLW 0x79
13A84  5CDE     SUBWF 0xFDE, W, ACCESS
13A86  A0D8     BTFSS 0xFD8, 0, ACCESS
13A88  D008     BRA 0x3A9A
85:            		C.runtime = 120;
13A8A  0E78     MOVLW 0x78
13A8E  FFA0     NOP
13A90  F7B3     NOP
13A92  0E00     MOVLW 0x0
13A96  FFA0     NOP
13A98  F7B4     NOP
86:            
87:            	V.lowint_count++;
13A9A  0E01     MOVLW 0x1
13A9C  0101     MOVLB 0x1
13A9E  27E3     ADDWF 0xE3, F, BANKED
13AA0  0E00     MOVLW 0x0
13AA2  23E4     ADDWFC 0xE4, F, BANKED
13AA4  23E5     ADDWFC 0xE5, F, BANKED
13AA6  23E6     ADDWFC 0xE6, F, BANKED
88:            
89:            	if (!log_update_wait++ && V.system_stable) {
13AA8  2A41     INCF log_update_wait, F, ACCESS
13AAA  0441     DECF log_update_wait, W, ACCESS
13AAC  A4D8     BTFSS 0xFD8, 2, ACCESS
13AAE  D15B     BRA 0x3D66
13AB0  51DE     MOVF 0xDE, W, BANKED
13AB2  B4D8     BTFSC 0xFD8, 2, ACCESS
13AB4  D158     BRA 0x3D66
90:            		log_ptr = port_data_dma_ptr();
13AB6  EC74     CALL 0x1C0E8, 0
13AB8  F0E0     NOP
13ABA  0EFF     MOVLW 0xFF
13ABE  F00B     NOP
13AC0  FFE3     NOP
13AC2  0EFE     MOVLW 0xFE
13AC6  F007     NOP
13AC8  FFE3     NOP
91:            		sprintf((char*) log_ptr, " %c ,%lu,%4.4f,%4.4f,%4.4f,%4.4f,%4.3f,%4.3f,%4.3f,%4.3f,%4.3f,%4.3f,%d,%d,%2.6f,%4.3f,%d,%d,%lu,%lu,%4.3f,%4.3f,%4.3f\r\n",
13ACA  EE21     LFSR 2, 0x7B9
13ACC  F3B9     NOP
13AD0  FF7B     NOP
13AD2  FFE6     NOP
13AD6  FF7B     NOP
13AD8  FFE6     NOP
13ADC  FF7B     NOP
13ADE  FFE6     NOP
13AE2  FF7B     NOP
13AE4  FFE6     NOP
13AE6  EE21     LFSR 2, 0x7BD
13AE8  F3BD     NOP
13AEC  FF7B     NOP
13AEE  FFE6     NOP
13AF2  FF7B     NOP
13AF4  FFE6     NOP
13AF8  FF7B     NOP
13AFA  FFE6     NOP
13AFE  FF7B     NOP
13B00  FFE6     NOP
13B02  EE21     LFSR 2, 0x79B
13B04  F39B     NOP
13B08  FF7B     NOP
13B0A  FFE6     NOP
13B0E  FF7B     NOP
13B10  FFE6     NOP
13B14  FF7B     NOP
13B16  FFE6     NOP
13B1A  FF7B     NOP
13B1C  FFE6     NOP
13B1E  EE22     LFSR 2, 0x826
13B20  F026     NOP
13B24  FF7B     NOP
13B26  FFE6     NOP
13B2A  FF7B     NOP
13B2C  FFE6     NOP
13B30  FF7B     NOP
13B32  FFE6     NOP
13B36  FF7B     NOP
13B38  FFE6     NOP
13B3A  EE22     LFSR 2, 0x822
13B3C  F022     NOP
13B40  FF7B     NOP
13B42  FFE6     NOP
13B46  FF7B     NOP
13B48  FFE6     NOP
13B4C  FF7B     NOP
13B4E  FFE6     NOP
13B52  FF7B     NOP
13B54  FFE6     NOP
13B56  EE22     LFSR 2, 0x821
13B58  F021     NOP
13B5A  50DF     MOVF 0xFDF, W, ACCESS
13B5C  6EE6     MOVWF 0xFE6, ACCESS
13B5E  0E00     MOVLW 0x0
13B60  6EE6     MOVWF 0xFE6, ACCESS
13B62  EC58     CALL 0x1C0B0, 0
13B64  F0E0     NOP
13B66  5001     MOVF ltemp0, W, ACCESS
13B68  6EE6     MOVWF 0xFE6, ACCESS
13B6A  0E00     MOVLW 0x0
13B6C  6EE6     MOVWF 0xFE6, ACCESS
13B6E  EE21     LFSR 2, 0x767
13B70  F367     NOP
13B74  FF7B     NOP
13B76  FFE6     NOP
13B7A  FF7B     NOP
13B7C  FFE6     NOP
13B80  FF7B     NOP
13B82  FFE6     NOP
13B86  FF7B     NOP
13B88  FFE6     NOP
13B8A  EE21     LFSR 2, 0x787
13B8C  F387     NOP
13B90  FF7B     NOP
13B92  FFE6     NOP
13B96  FF7B     NOP
13B98  FFE6     NOP
13B9C  FF7B     NOP
13B9E  FFE6     NOP
13BA2  FF7B     NOP
13BA4  FFE6     NOP
13BA6  EE21     LFSR 2, 0x7B3
13BA8  F3B3     NOP
13BAC  FF78     NOP
13BAE  F00B     NOP
13BB2  FF74     NOP
13BB4  F00C     NOP
13BB8  F02F     NOP
13BBA  FFE6     NOP
13BBE  F033     NOP
13BC0  FFE6     NOP
13BC2  EE21     LFSR 2, 0x7B5
13BC4  F3B5     NOP
13BC8  FF78     NOP
13BCA  F00B     NOP
13BCE  FF74     NOP
13BD0  F00C     NOP
13BD4  F02F     NOP
13BD6  FFE6     NOP
13BDA  F033     NOP
13BDC  FFE6     NOP
13BDE  EE21     LFSR 2, 0x793
13BE0  F393     NOP
13BE4  FF7B     NOP
13BE6  FFE6     NOP
13BEA  FF7B     NOP
13BEC  FFE6     NOP
13BF0  FF7B     NOP
13BF2  FFE6     NOP
13BF6  FF7B     NOP
13BF8  FFE6     NOP
13BFA  EE21     LFSR 2, 0x78F
13BFC  F38F     NOP
13C00  FF7B     NOP
13C02  FFE6     NOP
13C06  FF7B     NOP
13C08  FFE6     NOP
13C0C  FF7B     NOP
13C0E  FFE6     NOP
13C12  FF7B     NOP
13C14  FFE6     NOP
13C16  EE21     LFSR 2, 0x777
13C18  F377     NOP
13C1C  FF7B     NOP
13C1E  FFE6     NOP
13C22  FF7B     NOP
13C24  FFE6     NOP
13C28  FF7B     NOP
13C2A  FFE6     NOP
13C2E  FF7B     NOP
13C30  FFE6     NOP
13C32  EE21     LFSR 2, 0x773
13C34  F373     NOP
13C38  FF7B     NOP
13C3A  FFE6     NOP
13C3E  FF7B     NOP
13C40  FFE6     NOP
13C44  FF7B     NOP
13C46  FFE6     NOP
13C4A  FF7B     NOP
13C4C  FFE6     NOP
13C4E  EE21     LFSR 2, 0x77B
13C50  F37B     NOP
13C54  FF7B     NOP
13C56  FFE6     NOP
13C5A  FF7B     NOP
13C5C  FFE6     NOP
13C60  FF7B     NOP
13C62  FFE6     NOP
13C66  FF7B     NOP
13C68  FFE6     NOP
13C6A  EE21     LFSR 2, 0x77F
13C6C  F37F     NOP
13C70  FF7B     NOP
13C72  FFE6     NOP
13C76  FF7B     NOP
13C78  FFE6     NOP
13C7C  FF7B     NOP
13C7E  FFE6     NOP
13C82  FF7B     NOP
13C84  FFE6     NOP
13C86  EE21     LFSR 2, 0x763
13C88  F363     NOP
13C8C  FF7B     NOP
13C8E  FFE6     NOP
13C92  FF7B     NOP
13C94  FFE6     NOP
13C98  FF7B     NOP
13C9A  FFE6     NOP
13C9E  FF7B     NOP
13CA0  FFE6     NOP
13CA2  EE21     LFSR 2, 0x74B
13CA4  F34B     NOP
13CA8  FF7B     NOP
13CAA  FFE6     NOP
13CAE  FF7B     NOP
13CB0  FFE6     NOP
13CB4  FF7B     NOP
13CB6  FFE6     NOP
13CBA  FF7B     NOP
13CBC  FFE6     NOP
13CBE  EE21     LFSR 2, 0x74F
13CC0  F34F     NOP
13CC4  FF7B     NOP
13CC6  FFE6     NOP
13CCA  FF7B     NOP
13CCC  FFE6     NOP
13CD0  FF7B     NOP
13CD2  FFE6     NOP
13CD6  FF7B     NOP
13CD8  FFE6     NOP
13CDA  EE21     LFSR 2, 0x753
13CDC  F353     NOP
13CE0  FF7B     NOP
13CE2  FFE6     NOP
13CE6  FF7B     NOP
13CE8  FFE6     NOP
13CEC  FF7B     NOP
13CEE  FFE6     NOP
13CF2  FF7B     NOP
13CF4  FFE6     NOP
13CF8  F6C7     NOP
13CFA  FFE6     NOP
13CFE  F6CB     NOP
13D00  FFE6     NOP
13D04  F6CF     NOP
13D06  FFE6     NOP
13D0A  F6D3     NOP
13D0C  FFE6     NOP
13D0E  0E31     MOVLW 0x31
13D10  6EE6     MOVWF 0xFE6, ACCESS
13D12  0E00     MOVLW 0x0
13D14  6EE6     MOVWF 0xFE6, ACCESS
13D16  0ED7     MOVLW 0xD7
13D18  6EE6     MOVWF 0xFE6, ACCESS
13D1A  0EFB     MOVLW 0xFB
13D1C  6EE6     MOVWF 0xFE6, ACCESS
13D1E  0EAA     MOVLW 0xAA
13D22  FF8F     NOP
13D24  FFE6     NOP
13D28  FF8F     NOP
13D2A  FFE6     NOP
13D2C  0E56     MOVLW 0x56
13D2E  6EE6     MOVWF 0xFE6, ACCESS
13D30  EC00     CALL 0x19C00, 0
13D32  F0CE     NOP
92:            			D_CODE, V.ticks,
93:            			C.v_bat, C.v_pv, C.v_cc, C.v_inverter,
94:            			C.p_bat, C.p_pv, C.p_load, C.p_inverter,
95:            			C.dynamic_ah, C.pv_ah, C.soc, C.runtime,
96:            			C.esr, C.v_sensor, get_ac_charger_relay(), C.day, C.day_start, C.day_end, C.dynamic_ah_adj, C.hist[0].cef, C.hist[0].peukert);
97:            		StartTimer(TMR_DISPLAY, SOCDELAY); // sync the spi dma display updates
13D34  0E7D     MOVLW 0x7D
13D36  6EE6     MOVWF 0xFE6, ACCESS
13D38  0E00     MOVLW 0x0
13D3A  6EE6     MOVWF 0xFE6, ACCESS
13D3C  0E0A     MOVLW 0xA
13D3E  6EE6     MOVWF 0xFE6, ACCESS
13D40  EC65     CALL 0x1B6CA, 0
13D42  F0DB     NOP
98:            		send_port_data_dma(strlen((char*) log_ptr));
13D44  0EFE     MOVLW 0xFE
13D48  FF8F     NOP
13D4A  FFE6     NOP
13D4E  FF8F     NOP
13D50  FFE6     NOP
13D52  EC6F     CALL 0x1A8DE, 0
13D54  F0D4     NOP
13D58  F007     NOP
13D5A  FFE6     NOP
13D5E  F00B     NOP
13D60  FFE6     NOP
13D62  EC72     CALL 0x1B2E4, 0
13D64  F0D9     NOP
99:            	}
100:           	if (log_update_wait >= LOG_WAIT)
13D66  0E09     MOVLW 0x9
13D68  6441     CPFSGT log_update_wait, ACCESS
13D6A  D001     BRA 0x3D6E
101:           		log_update_wait = 0;
13D6C  6A41     CLRF log_update_wait, ACCESS
102:           
103:           	C.update = false;
13D6E  0E00     MOVLW 0x0
13D72  FFA0     NOP
13D74  F7B7     NOP
104:           #ifdef DEBUG_BSOC1
105:           	DEBUG1_SetLow();
13D76  92BE     BCF 0xFBE, 1, ACCESS
106:           #endif
107:           }
13D78  0EFA     MOVLW 0xFA
13D7A  26E1     ADDWF 0xFE1, F, ACCESS
13D7C  0EFF     MOVLW 0xFF
13D7E  22E2     ADDWFC 0xFE2, F, ACCESS
13D80  0012     RETURN 0
108:           
109:           void init_bsoc(void)
110:           {
111:           	/*
112:           	 * use raw battery voltage
113:           	 */
114:           	C.soc = Volts_to_SOC((uint32_t) conv_raw_result(V_BAT, CONV) * 1000.0);
17BC2  0E00     MOVLW 0x0
17BC4  6EE6     MOVWF 0xFE6, ACCESS
17BC6  0E00     MOVLW 0x0
17BC8  6EE6     MOVWF 0xFE6, ACCESS
17BCA  0E7A     MOVLW 0x7A
17BCC  6EE6     MOVWF 0xFE6, ACCESS
17BCE  0E44     MOVLW 0x44
17BD0  6EE6     MOVWF 0xFE6, ACCESS
17BD2  0E00     MOVLW 0x0
17BD4  6EE6     MOVWF 0xFE6, ACCESS
17BD6  0E04     MOVLW 0x4
17BD8  6EE6     MOVWF 0xFE6, ACCESS
17BDA  EC71     CALL 0x152E2, 0
17BDC  F0A9     NOP
17BE0  F007     NOP
17BE2  FFE6     NOP
17BE6  F00B     NOP
17BE8  FFE6     NOP
17BEC  F00F     NOP
17BEE  FFE6     NOP
17BF2  F013     NOP
17BF4  FFE6     NOP
17BF6  EC3B     CALL 0x18E76, 0
17BF8  F0C7     NOP
17BFC  F007     NOP
17BFE  FFE6     NOP
17C02  F00B     NOP
17C04  FFE6     NOP
17C08  F00F     NOP
17C0A  FFE6     NOP
17C0E  F013     NOP
17C10  FFE6     NOP
17C12  0E00     MOVLW 0x0
17C14  6EE6     MOVWF 0xFE6, ACCESS
17C16  EC3D     CALL 0x1847A, 0
17C18  F0C2     NOP
17C1C  F007     NOP
17C1E  FFE6     NOP
17C22  F00B     NOP
17C24  FFE6     NOP
17C28  F00F     NOP
17C2A  FFE6     NOP
17C2E  F013     NOP
17C30  FFE6     NOP
17C32  ECC1     CALL 0x13D82, 0
17C34  F09E     NOP
17C38  F007     NOP
17C3A  FFE6     NOP
17C3E  F00B     NOP
17C40  FFE6     NOP
17C44  F00F     NOP
17C46  FFE6     NOP
17C4A  F013     NOP
17C4C  FFE6     NOP
17C4E  EC3B     CALL 0x18E76, 0
17C50  F0C7     NOP
17C54  F007     NOP
17C56  FFE6     NOP
17C5A  F00B     NOP
17C5C  FFE6     NOP
17C60  F00F     NOP
17C62  FFE6     NOP
17C66  F013     NOP
17C68  FFE6     NOP
17C6A  EC0D     CALL 0x1A41A, 0
17C6C  F0D2     NOP
17C70  F004     NOP
17C72  F7B5     NOP
17C76  F008     NOP
17C78  F7B6     NOP
115:           	C.dynamic_ah = C.bank_ah * (Volts_to_SOC((uint32_t) conv_raw_result(V_BAT, CONV) * 1000.0) / 100.0);
17C7A  EE21     LFSR 2, 0x78B
17C7C  F38B     NOP
17C80  FF7B     NOP
17C82  FFE6     NOP
17C86  FF7B     NOP
17C88  FFE6     NOP
17C8C  FF7B     NOP
17C8E  FFE6     NOP
17C92  FF7B     NOP
17C94  FFE6     NOP
17C96  0E00     MOVLW 0x0
17C98  6EE6     MOVWF 0xFE6, ACCESS
17C9A  0E00     MOVLW 0x0
17C9C  6EE6     MOVWF 0xFE6, ACCESS
17C9E  0EC8     MOVLW 0xC8
17CA0  6EE6     MOVWF 0xFE6, ACCESS
17CA2  0E42     MOVLW 0x42
17CA4  6EE6     MOVWF 0xFE6, ACCESS
17CA6  0E00     MOVLW 0x0
17CA8  6EE6     MOVWF 0xFE6, ACCESS
17CAA  0E00     MOVLW 0x0
17CAC  6EE6     MOVWF 0xFE6, ACCESS
17CAE  0E7A     MOVLW 0x7A
17CB0  6EE6     MOVWF 0xFE6, ACCESS
17CB2  0E44     MOVLW 0x44
17CB4  6EE6     MOVWF 0xFE6, ACCESS
17CB6  0E00     MOVLW 0x0
17CB8  6EE6     MOVWF 0xFE6, ACCESS
17CBA  0E04     MOVLW 0x4
17CBC  6EE6     MOVWF 0xFE6, ACCESS
17CBE  EC71     CALL 0x152E2, 0
17CC0  F0A9     NOP
17CC4  F007     NOP
17CC6  FFE6     NOP
17CCA  F00B     NOP
17CCC  FFE6     NOP
17CD0  F00F     NOP
17CD2  FFE6     NOP
17CD6  F013     NOP
17CD8  FFE6     NOP
17CDA  EC3B     CALL 0x18E76, 0
17CDC  F0C7     NOP
17CE0  F007     NOP
17CE2  FFE6     NOP
17CE6  F00B     NOP
17CE8  FFE6     NOP
17CEC  F00F     NOP
17CEE  FFE6     NOP
17CF2  F013     NOP
17CF4  FFE6     NOP
17CF6  0E00     MOVLW 0x0
17CF8  6EE6     MOVWF 0xFE6, ACCESS
17CFA  EC3D     CALL 0x1847A, 0
17CFC  F0C2     NOP
17D00  F007     NOP
17D02  FFE6     NOP
17D06  F00B     NOP
17D08  FFE6     NOP
17D0C  F00F     NOP
17D0E  FFE6     NOP
17D12  F013     NOP
17D14  FFE6     NOP
17D16  ECC1     CALL 0x13D82, 0
17D18  F09E     NOP
17D1C  F007     NOP
17D1E  FFE6     NOP
17D22  F00B     NOP
17D24  FFE6     NOP
17D28  F00F     NOP
17D2A  FFE6     NOP
17D2E  F013     NOP
17D30  FFE6     NOP
17D32  EC3B     CALL 0x18E76, 0
17D34  F0C7     NOP
17D38  F007     NOP
17D3A  FFE6     NOP
17D3E  F00B     NOP
17D40  FFE6     NOP
17D44  F00F     NOP
17D46  FFE6     NOP
17D4A  F013     NOP
17D4C  FFE6     NOP
17D4E  EC0D     CALL 0x1A41A, 0
17D50  F0D2     NOP
17D54  F004     NOP
17D56  F00B     NOP
17D5A  F008     NOP
17D5C  F00C     NOP
17D5E  500B     MOVF wtemp5, W, ACCESS
17D60  6E05     MOVWF ltemp1, ACCESS
17D62  500C     MOVF 0xC, W, ACCESS
17D64  6E06     MOVWF 0x6, ACCESS
17D66  6A07     CLRF ttemp2, ACCESS
17D68  6A08     CLRF 0x8, ACCESS
17D6C  F017     NOP
17D6E  FFE6     NOP
17D72  F01B     NOP
17D74  FFE6     NOP
17D78  F01F     NOP
17D7A  FFE6     NOP
17D7E  F023     NOP
17D80  FFE6     NOP
17D82  0E00     MOVLW 0x0
17D84  6EE6     MOVWF 0xFE6, ACCESS
17D86  EC3D     CALL 0x1847A, 0
17D88  F0C2     NOP
17D8C  F007     NOP
17D8E  FFE6     NOP
17D92  F00B     NOP
17D94  FFE6     NOP
17D98  F00F     NOP
17D9A  FFE6     NOP
17D9E  F013     NOP
17DA0  FFE6     NOP
17DA2  ECB4     CALL 0x14D68, 0
17DA4  F0A6     NOP
17DA8  F007     NOP
17DAA  FFE6     NOP
17DAE  F00B     NOP
17DB0  FFE6     NOP
17DB4  F00F     NOP
17DB6  FFE6     NOP
17DBA  F013     NOP
17DBC  FFE6     NOP
17DBE  ECC1     CALL 0x13D82, 0
17DC0  F09E     NOP
17DC4  F004     NOP
17DC6  F78F     NOP
17DCA  F008     NOP
17DCC  F790     NOP
17DD0  F00C     NOP
17DD2  F791     NOP
17DD6  F010     NOP
17DD8  F792     NOP
116:           	C.dynamic_ah_adj = C.dynamic_ah;
17DDA  EE21     LFSR 2, 0x78F
17DDC  F38F     NOP
17DE0  FF78     NOP
17DE2  F79B     NOP
17DE6  FF78     NOP
17DE8  F79C     NOP
17DEC  FF78     NOP
17DEE  F79D     NOP
17DF2  FF74     NOP
17DF4  F79E     NOP
117:           	TMR3_SetInterruptHandler(calc_bsoc);
17DF6  0E4C     MOVLW 0x4C
17DF8  6EE6     MOVWF 0xFE6, ACCESS
17DFA  0E33     MOVLW 0x33
17DFC  6EE6     MOVWF 0xFE6, ACCESS
17DFE  0E01     MOVLW 0x1
17E00  6EE6     MOVWF 0xFE6, ACCESS
17E02  EC03     CALL 0x1BC06, 0
17E04  F0DE     NOP
118:           }
17E06  0012     RETURN 0
119:           
120:           void start_bsoc(void)
121:           {
122:           	// Enabling TMR3 interrupt.
123:           	PIE6bits.TMR3IE = 1;
1BE66  0139     MOVLB 0x39
1BE68  8D96     BSF utctime, 6, BANKED
124:           #ifdef DEBUG_BSOC2
125:           	DEBUG2_Toggle();
1BE6A  A4BE     BTFSS 0xFBE, 2, ACCESS
1BE6C  D002     BRA 0xBE72
1BE6E  0E01     MOVLW 0x1
1BE70  D001     BRA 0xBE74
1BE72  0E00     MOVLW 0x0
1BE74  0AFF     XORLW 0xFF
1BE76  6E0C     MOVWF 0xC, ACCESS
1BE78  460C     RLNCF 0xC, F, ACCESS
1BE7A  460C     RLNCF 0xC, F, ACCESS
1BE7C  50BE     MOVF 0xFBE, W, ACCESS
1BE7E  180C     XORWF 0xC, W, ACCESS
1BE80  0BFB     ANDLW 0xFB
1BE82  180C     XORWF 0xC, W, ACCESS
1BE84  6EBE     MOVWF 0xFBE, ACCESS
126:           #endif
127:           }
1BE86  0012     RETURN 0
128:           
129:           void stop_bsoc(void)
130:           {
131:           	// Disabling TMR3 interrupt.
132:           	PIE6bits.TMR3IE = 0;
1C150  0139     MOVLB 0x39
1C152  9D96     BCF utctime, 6, BANKED
133:           }
1C154  0012     RETURN 0
134:           
135:           void reset_bsoc(const R_CODES rmode)
136:           {
137:           	switch (rmode) {
138:           	default:
139:           		C.pv_ah = 0.0;
140:           		break;
141:           	}
142:           }
143:           
144:           /* Current is in 0.1A units */
145:           uint32_t peukert(uint16_t brate, float bcurrent, float peukert, int16_t bsoc)
146:           {
147:           	float t1, t2, t3, t4, t5, t6, t7, t_time;
148:           
149:           	t1 = (float) bcurrent; // Load on battery in 0.1A units
150:           	t1 /= 10.0; // convert back to A
151:           	if (t1 < 1.0) t1 = 1.0; // inverter current floor is 1.0 amp
152:           	t2 = (float) brate; // Battery capacity in 1.0A units
153:           	t3 = (float) ((float) bsoc / 100.0); // State of Charge
154:           	if (t3 > 0.0) t2 = t2 * t3; // only decrease battery Ah
155:           	if (t2 < 1.0) t2 = 1.0; // Ah floor is 1.0
156:           	t4 = t2 * (float) (pow((t2 / (float) 20.0), ((float) peukert - (float) 1.0)));
157:           	t_time = pow((t2 / (float) 20.0), peukert); // factor at 20h rate
158:           	t5 = pow(t1, peukert); // factor at load current rate
159:           	t6 = t4 / t5; // runtime in hours at the current draw
160:           	if (t6 > MAXRUNTIME) t6 = MAXRUNTIME; // max time is 4 days in hours
161:           	if (t6 < MINRUNTIME) t6 = MINRUNTIME;
162:           	t7 = t4 / t_time; // time at fixed 20h rate
163:           
164:           	C.hist[0].peukert_adj = t7 / t6; // Peukert factor to resize Ah usage, t7=runtime at the 20h current rate/t6=runtime at the inverter load current value
165:           	if (C.hist[0].peukert_adj < Perk_ADJ_FL)
166:           		C.hist[0].peukert_adj = Perk_ADJ_FL; // limit how LOW
167:           	if (C.hist[0].peukert_adj > Perk_ADJ_FH)
168:           		C.hist[0].peukert_adj = Perk_ADJ_FH; // limit how HIGH
169:           
170:           	t6 = t6 * 3600.0; // convert to seconds for runtime at current discharge rate
171:           	return(uint32_t) t6;
172:           }
173:           
174:           uint16_t Volts_to_SOC(const uint32_t cvoltage)
1A41A  52E6     MOVF 0xFE6, F, ACCESS
1A41C  52E6     MOVF 0xFE6, F, ACCESS
1A41E  52E6     MOVF 0xFE6, F, ACCESS
175:           {
176:           	uint8_t slot;
177:           	uint16_t soc = 0;
1A420  0EFD     MOVLW 0xFD
1A422  6AE3     CLRF 0xFE3, ACCESS
1A424  0EFE     MOVLW 0xFE
1A426  6AE3     CLRF 0xFE3, ACCESS
178:           
179:           	for (slot = 0; slot < BVSOC_SLOTS; slot++) {
1A428  0EFF     MOVLW 0xFF
1A42A  6AE3     CLRF 0xFE3, ACCESS
180:           		if (cvoltage > BVSOC_TABLE[slot][0]) {
1A42C  0EFF     MOVLW 0xFF
1A42E  50E3     MOVF 0xFE3, W, ACCESS
1A430  0D08     MULLW 0x8
1A432  0EEB     MOVLW 0xEB
1A434  24F3     ADDWF 0xFF3, W, ACCESS
1A436  6EF6     MOVWF 0xFF6, ACCESS
1A438  0EF9     MOVLW 0xF9
1A43A  20F4     ADDWFC 0xFF4, W, ACCESS
1A43C  6EF7     MOVWF 0xFF7, ACCESS
1A43E  6AF8     CLRF 0xFF8, ACCESS
1A440  0E00     MOVLW 0x0
1A442  22F8     ADDWFC 0xFF8, F, ACCESS
1A444  0EF9     MOVLW 0xF9
1A446  50E3     MOVF 0xFE3, W, ACCESS
1A448  0009     TBLRD*+
1A44A  5CF5     SUBWF 0xFF5, W, ACCESS
1A44C  0EFA     MOVLW 0xFA
1A44E  50E3     MOVF 0xFE3, W, ACCESS
1A450  0009     TBLRD*+
1A452  58F5     SUBWFB 0xFF5, W, ACCESS
1A454  0EFB     MOVLW 0xFB
1A456  50E3     MOVF 0xFE3, W, ACCESS
1A458  0009     TBLRD*+
1A45A  58F5     SUBWFB 0xFF5, W, ACCESS
1A45C  0EFC     MOVLW 0xFC
1A45E  50E3     MOVF 0xFE3, W, ACCESS
1A460  0009     TBLRD*+
1A462  58F5     SUBWFB 0xFF5, W, ACCESS
1A464  B0D8     BTFSC 0xFD8, 0, ACCESS
1A466  D020     BRA 0xA4A8
181:           			soc = BVSOC_TABLE[slot][1];
1A468  0EFF     MOVLW 0xFF
1A46A  50E3     MOVF 0xFE3, W, ACCESS
1A46C  0D08     MULLW 0x8
1A46E  0E04     MOVLW 0x4
1A470  26F3     ADDWF 0xFF3, F, ACCESS
1A472  0E00     MOVLW 0x0
1A474  22F4     ADDWFC 0xFF4, F, ACCESS
1A476  0EEB     MOVLW 0xEB
1A478  24F3     ADDWF 0xFF3, W, ACCESS
1A47A  6EF6     MOVWF 0xFF6, ACCESS
1A47C  0EF9     MOVLW 0xF9
1A47E  20F4     ADDWFC 0xFF4, W, ACCESS
1A480  6EF7     MOVWF 0xFF7, ACCESS
1A482  6AF8     CLRF 0xFF8, ACCESS
1A484  0E00     MOVLW 0x0
1A486  22F8     ADDWFC 0xFF8, F, ACCESS
1A488  0009     TBLRD*+
1A48C  FFD4     NOP
1A48E  F00B     NOP
1A490  0009     TBLRD*+
1A494  FFD4     NOP
1A496  F00C     NOP
1A498  0EFD     MOVLW 0xFD
1A49C  F02F     NOP
1A49E  FFE3     NOP
1A4A0  0EFE     MOVLW 0xFE
1A4A4  F033     NOP
1A4A6  FFE3     NOP
182:           		}
183:           	}
1A4A8  0EFF     MOVLW 0xFF
1A4AA  2AE3     INCF 0xFE3, F, ACCESS
1A4AC  0EFF     MOVLW 0xFF
1A4B0  FF8C     NOP
1A4B2  F001     NOP
1A4B4  0E19     MOVLW 0x19
1A4B6  6401     CPFSGT ltemp0, ACCESS
1A4B8  D7B9     BRA 0xA42C
184:           	return soc;
1A4BA  0EFD     MOVLW 0xFD
1A4BE  FF8C     NOP
1A4C0  F001     NOP
1A4C2  0EFE     MOVLW 0xFE
1A4C6  FF8C     NOP
1A4C8  F002     NOP
185:           }
1A4CA  0EF9     MOVLW 0xF9
1A4CC  26E1     ADDWF 0xFE1, F, ACCESS
1A4CE  0EFF     MOVLW 0xFF
1A4D0  22E2     ADDWFC 0xFE2, F, ACCESS
1A4D2  0012     RETURN 0
186:           
187:           /*
188:            * check battery ESR, returns positive ESR value when done,
189:            * a negative number code when running the sequence and
190:            * -1.0 when each FSM sequence is done
191:            * (fsm 'true' will init the state machine and return the init code)
192:            */
193:           float esr_check(const uint8_t fsm)
194:           {
195:           	static uint8_t esr_state = 0;
196:           
197:           	if (fsm) {
17140  0EFF     MOVLW 0xFF
17142  50E3     MOVF 0xFE3, W, ACCESS
17144  B4D8     BTFSC 0xFD8, 2, ACCESS
17146  D146     BRA 0x73D4
198:           		esr_state = 0;
17148  6A40     CLRF esr_state, ACCESS
199:           		return -10.0;
1714A  0E00     MOVLW 0x0
1714C  6E01     MOVWF ltemp0, ACCESS
1714E  0E00     MOVLW 0x0
17150  6E02     MOVWF ttemp5, ACCESS
17152  0E20     MOVLW 0x20
17154  6E03     MOVWF wtemp1, ACCESS
17156  0EC1     MOVLW 0xC1
17158  D158     BRA 0x740A
200:           	}
201:           
202:           	switch (esr_state) {
203:           	case 0:
204:           		StartTimer(TMR_ESR, 10000); // start the sequence timer
1715A  0E10     MOVLW 0x10
1715C  6EE6     MOVWF 0xFE6, ACCESS
1715E  0E27     MOVLW 0x27
17160  6EE6     MOVWF 0xFE6, ACCESS
17162  0E0C     MOVLW 0xC
17164  6EE6     MOVWF 0xFE6, ACCESS
17166  EC65     CALL 0x1B6CA, 0
17168  F0DB     NOP
205:           		esr_state++; // move to the next state of the FSM
1716A  2A40     INCF esr_state, F, ACCESS
206:           		break;
1716C  D147     BRA 0x73FC
207:           	case 1:
208:           		/*
209:           		 * set the load resistors to all off
210:           		 */
211:           		set_load_relay_one(false);
1716E  0E00     MOVLW 0x0
17170  6EE6     MOVWF 0xFE6, ACCESS
17172  EC2B     CALL 0x1C056, 0
17174  F0E0     NOP
212:           		set_load_relay_two(false);
17176  0E00     MOVLW 0x0
17178  6EE6     MOVWF 0xFE6, ACCESS
1717A  EC23     CALL 0x1C046, 0
1717C  F0E0     NOP
213:           		if (TimerDone(TMR_ESR)) { // check for expired timer
1717E  0E0C     MOVLW 0xC
17180  6EE6     MOVWF 0xFE6, ACCESS
17182  EC8B     CALL 0x1BB16, 0
17184  F0DD     NOP
17186  5001     MOVF ltemp0, W, ACCESS
17188  B4D8     BTFSC 0xFD8, 2, ACCESS
1718A  D009     BRA 0x719E
214:           			StartTimer(TMR_ESR, 10000); // done, restart the timer, complete sequence, return -1.0
1718C  0E10     MOVLW 0x10
1718E  6EE6     MOVWF 0xFE6, ACCESS
17190  0E27     MOVLW 0x27
17192  6EE6     MOVWF 0xFE6, ACCESS
17194  0E0C     MOVLW 0xC
17196  6EE6     MOVWF 0xFE6, ACCESS
17198  EC65     CALL 0x1B6CA, 0
1719A  F0DB     NOP
215:           		} else {
1719C  D006     BRA 0x71AA
216:           			return -2.0; // nope, return with a progress code
1719E  0E00     MOVLW 0x0
171A0  6E01     MOVWF ltemp0, ACCESS
171A2  0E00     MOVLW 0x0
171A4  6E02     MOVWF ttemp5, ACCESS
171A6  0E00     MOVLW 0x0
171A8  D066     BRA 0x7276
217:           		}
218:           		/*
219:           		 * save unloaded battery voltage
220:           		 */
221:           		update_adc_result();
171AA  EC05     CALL 0x1B80A, 0
171AC  F0DC     NOP
222:           		C.bv_noload = conv_raw_result(V_BAT, CONV);
171AE  0E00     MOVLW 0x0
171B0  6EE6     MOVWF 0xFE6, ACCESS
171B2  0E04     MOVLW 0x4
171B4  6EE6     MOVWF 0xFE6, ACCESS
171B6  EC71     CALL 0x152E2, 0
171B8  F0A9     NOP
171BC  F004     NOP
171BE  F815     NOP
171C2  F008     NOP
171C4  F816     NOP
171C8  F00C     NOP
171CA  F817     NOP
171CE  F010     NOP
171D0  F818     NOP
171D2  D7CB     BRA 0x716A
223:           		esr_state++; // move to the next state of the FSM
224:           		break;
225:           	case 2:
226:           		set_load_relay_one(true);
171D4  0E01     MOVLW 0x1
171D6  6EE6     MOVWF 0xFE6, ACCESS
171D8  EC2B     CALL 0x1C056, 0
171DA  F0E0     NOP
227:           		if (TimerDone(TMR_ESR)) {
171DC  0E0C     MOVLW 0xC
171DE  6EE6     MOVWF 0xFE6, ACCESS
171E0  EC8B     CALL 0x1BB16, 0
171E2  F0DD     NOP
171E4  5001     MOVF ltemp0, W, ACCESS
171E6  B4D8     BTFSC 0xFD8, 2, ACCESS
171E8  D009     BRA 0x71FC
228:           			StartTimer(TMR_ESR, 10000);
171EA  0E10     MOVLW 0x10
171EC  6EE6     MOVWF 0xFE6, ACCESS
171EE  0E27     MOVLW 0x27
171F0  6EE6     MOVWF 0xFE6, ACCESS
171F2  0E0C     MOVLW 0xC
171F4  6EE6     MOVWF 0xFE6, ACCESS
171F6  EC65     CALL 0x1B6CA, 0
171F8  F0DB     NOP
229:           		} else {
171FA  D006     BRA 0x7208
230:           			return -3.0;
171FC  0E00     MOVLW 0x0
171FE  6E01     MOVWF ltemp0, ACCESS
17200  0E00     MOVLW 0x0
17202  6E02     MOVWF ttemp5, ACCESS
17204  0E40     MOVLW 0x40
17206  D037     BRA 0x7276
231:           		}
232:           
233:           		update_adc_result();
17208  EC05     CALL 0x1B80A, 0
1720A  F0DC     NOP
234:           		C.bv_one_load = conv_raw_result(V_BAT, CONV);
1720C  0E00     MOVLW 0x0
1720E  6EE6     MOVWF 0xFE6, ACCESS
17210  0E04     MOVLW 0x4
17212  6EE6     MOVWF 0xFE6, ACCESS
17214  EC71     CALL 0x152E2, 0
17216  F0A9     NOP
1721A  F004     NOP
1721C  F819     NOP
17220  F008     NOP
17222  F81A     NOP
17226  F00C     NOP
17228  F81B     NOP
1722C  F010     NOP
1722E  F81C     NOP
235:           		C.load_i1 = conv_raw_result(C_BATT, CONV); // get current
17230  0E00     MOVLW 0x0
17232  6EE6     MOVWF 0xFE6, ACCESS
17234  0E00     MOVLW 0x0
17236  6EE6     MOVWF 0xFE6, ACCESS
17238  EC71     CALL 0x152E2, 0
1723A  F0A9     NOP
1723E  F004     NOP
17240  F80D     NOP
17244  F008     NOP
17246  F80E     NOP
1724A  F00C     NOP
1724C  F80F     NOP
17250  F010     NOP
17252  F810     NOP
17254  D78A     BRA 0x716A
236:           		esr_state++;
237:           		break;
238:           	case 3:
239:           		set_load_relay_two(true);
17256  0E01     MOVLW 0x1
17258  6EE6     MOVWF 0xFE6, ACCESS
1725A  EC23     CALL 0x1C046, 0
1725C  F0E0     NOP
240:           		if (!TimerDone(TMR_ESR))
1725E  0E0C     MOVLW 0xC
17260  6EE6     MOVWF 0xFE6, ACCESS
17262  EC8B     CALL 0x1BB16, 0
17264  F0DD     NOP
17266  5001     MOVF ltemp0, W, ACCESS
17268  A4D8     BTFSS 0xFD8, 2, ACCESS
1726A  D008     BRA 0x727C
241:           			return -4.0;
1726C  0E00     MOVLW 0x0
1726E  6E01     MOVWF ltemp0, ACCESS
17270  0E00     MOVLW 0x0
17272  6E02     MOVWF ttemp5, ACCESS
17274  0E80     MOVLW 0x80
17276  6E03     MOVWF wtemp1, ACCESS
17278  0EC0     MOVLW 0xC0
1727A  D0C7     BRA 0x740A
242:           
243:           		update_adc_result();
1727C  EC05     CALL 0x1B80A, 0
1727E  F0DC     NOP
244:           		C.bv_full_load = conv_raw_result(V_BAT, CONV);
17280  0E00     MOVLW 0x0
17282  6EE6     MOVWF 0xFE6, ACCESS
17284  0E04     MOVLW 0x4
17286  6EE6     MOVWF 0xFE6, ACCESS
17288  EC71     CALL 0x152E2, 0
1728A  F0A9     NOP
1728E  F004     NOP
17290  F81D     NOP
17294  F008     NOP
17296  F81E     NOP
1729A  F00C     NOP
1729C  F81F     NOP
172A0  F010     NOP
172A2  F820     NOP
245:           		C.load_i2 = conv_raw_result(C_BATT, CONV); // get current
172A4  0E00     MOVLW 0x0
172A6  6EE6     MOVWF 0xFE6, ACCESS
172A8  0E00     MOVLW 0x0
172AA  6EE6     MOVWF 0xFE6, ACCESS
172AC  EC71     CALL 0x152E2, 0
172AE  F0A9     NOP
172B2  F004     NOP
172B4  F811     NOP
172B8  F008     NOP
172BA  F812     NOP
172BE  F00C     NOP
172C0  F813     NOP
172C4  F010     NOP
172C6  F814     NOP
246:           
247:           		C.esr = fabs((C.bv_one_load - C.bv_full_load) / (C.load_i1 - C.load_i2)); // find internal resistance causing voltage drop (sorta)
172C8  EE22     LFSR 2, 0x811
172CA  F011     NOP
172CE  FF7B     NOP
172D0  FFE6     NOP
172D4  FF7B     NOP
172D6  FFE6     NOP
172DA  FF7B     NOP
172DC  FFE6     NOP
172E0  FF7B     NOP
172E2  FFE6     NOP
172E4  EE22     LFSR 2, 0x80D
172E6  F00D     NOP
172EA  FF7B     NOP
172EC  FFE6     NOP
172F0  FF7B     NOP
172F2  FFE6     NOP
172F6  FF7B     NOP
172F8  FFE6     NOP
172FC  FF7B     NOP
172FE  FFE6     NOP
17300  ECBF     CALL 0x1B57E, 0
17302  F0DA     NOP
17306  F007     NOP
17308  FFE6     NOP
1730C  F00B     NOP
1730E  FFE6     NOP
17312  F00F     NOP
17314  FFE6     NOP
17318  F013     NOP
1731A  FFE6     NOP
1731C  EE22     LFSR 2, 0x81D
1731E  F01D     NOP
17322  FF7B     NOP
17324  FFE6     NOP
17328  FF7B     NOP
1732A  FFE6     NOP
1732E  FF7B     NOP
17330  FFE6     NOP
17334  FF7B     NOP
17336  FFE6     NOP
17338  EE22     LFSR 2, 0x819
1733A  F019     NOP
1733E  FF7B     NOP
17340  FFE6     NOP
17344  FF7B     NOP
17346  FFE6     NOP
1734A  FF7B     NOP
1734C  FFE6     NOP
17350  FF7B     NOP
17352  FFE6     NOP
17354  ECBF     CALL 0x1B57E, 0
17356  F0DA     NOP
1735A  F007     NOP
1735C  FFE6     NOP
17360  F00B     NOP
17362  FFE6     NOP
17366  F00F     NOP
17368  FFE6     NOP
1736C  F013     NOP
1736E  FFE6     NOP
17370  ECB4     CALL 0x14D68, 0
17372  F0A6     NOP
17376  F007     NOP
17378  FFE6     NOP
1737C  F00B     NOP
1737E  FFE6     NOP
17382  F00F     NOP
17384  FFE6     NOP
17388  F013     NOP
1738A  FFE6     NOP
1738C  ECC6     CALL 0x1A58C, 0
1738E  F0D2     NOP
17392  F004     NOP
17394  F787     NOP
17398  F008     NOP
1739A  F788     NOP
1739E  F00C     NOP
173A0  F789     NOP
173A4  F010     NOP
173A6  F78A     NOP
248:           		set_load_relay_one(false);
173A8  0E00     MOVLW 0x0
173AA  6EE6     MOVWF 0xFE6, ACCESS
173AC  EC2B     CALL 0x1C056, 0
173AE  F0E0     NOP
249:           		set_load_relay_two(false);
173B0  0E00     MOVLW 0x0
173B2  6EE6     MOVWF 0xFE6, ACCESS
173B4  EC23     CALL 0x1C046, 0
173B6  F0E0     NOP
250:           		esr_state = 0;
173B8  6A40     CLRF esr_state, ACCESS
251:           		return C.esr;
173BC  FE1C     NOP
173BE  F001     NOP
173C2  FE20     NOP
173C4  F002     NOP
173C8  FE24     NOP
173CA  F003     NOP
173CE  FE28     NOP
173D0  F004     NOP
173D2  D01C     BRA 0x740C
252:           		break;
253:           	default:
254:           		break;
255:           	}
173D4  5040     MOVF esr_state, W, ACCESS
173D6  6E0B     MOVWF wtemp5, ACCESS
173D8  6A0C     CLRF 0xC, ACCESS
173DA  500C     MOVF 0xC, W, ACCESS
173DC  0A00     XORLW 0x0
173DE  A4D8     BTFSS 0xFD8, 2, ACCESS
173E0  D00D     BRA 0x73FC
173E2  500B     MOVF wtemp5, W, ACCESS
173E4  0A00     XORLW 0x0
173E6  B4D8     BTFSC 0xFD8, 2, ACCESS
173E8  D6B8     BRA 0x715A
173EA  0A01     XORLW 0x1
173EC  B4D8     BTFSC 0xFD8, 2, ACCESS
173EE  D6BF     BRA 0x716E
173F0  0A03     XORLW 0x3
173F2  B4D8     BTFSC 0xFD8, 2, ACCESS
173F4  D6EF     BRA 0x71D4
173F6  0A01     XORLW 0x1
173F8  B4D8     BTFSC 0xFD8, 2, ACCESS
173FA  D72D     BRA 0x7256
256:           	return -1.0;
173FC  0E00     MOVLW 0x0
173FE  6E01     MOVWF ltemp0, ACCESS
17400  0E00     MOVLW 0x0
17402  6E02     MOVWF ttemp5, ACCESS
17404  0E80     MOVLW 0x80
17406  6E03     MOVWF wtemp1, ACCESS
17408  0EBF     MOVLW 0xBF
1740A  6E04     MOVWF ttemp1, ACCESS
257:           }
1740C  52E5     MOVF 0xFE5, F, ACCESS
1740E  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/pic18/asfladd.c  ------------------------------------------
1:             #include <inline.h>
2:             
3:             extern double __fladd(double, double);
4:             
5:             double _INLINE
6:             __asfladd(double * f1p, double f2)
7:             {
8:             	return *f1p = __fladd(*f1p, f2);
1ADDE  0EFA     MOVLW 0xFA
1ADE2  FF8F     NOP
1ADE4  FFE6     NOP
1ADE8  FF8F     NOP
1ADEA  FFE6     NOP
1ADEE  FF8F     NOP
1ADF0  FFE6     NOP
1ADF4  FF8F     NOP
1ADF6  FFE6     NOP
1ADF8  0EFA     MOVLW 0xFA
1ADFC  FF8F     NOP
1ADFE  FFD9     NOP
1AE00  0EFB     MOVLW 0xFB
1AE04  FF8F     NOP
1AE06  FFDA     NOP
1AE0A  FF7B     NOP
1AE0C  FFE6     NOP
1AE10  FF7B     NOP
1AE12  FFE6     NOP
1AE16  FF7B     NOP
1AE18  FFE6     NOP
1AE1C  FF7B     NOP
1AE1E  FFE6     NOP
1AE20  ECD6     CALL 0x145AC, 0
1AE22  F0A2     NOP
1AE24  0EFE     MOVLW 0xFE
1AE28  FF8F     NOP
1AE2A  FFD9     NOP
1AE2C  0EFF     MOVLW 0xFF
1AE30  FF8F     NOP
1AE32  FFDA     NOP
1AE36  F007     NOP
1AE38  FFDE     NOP
1AE3C  F00B     NOP
1AE3E  FFDE     NOP
1AE42  F00F     NOP
1AE44  FFDE     NOP
1AE48  F013     NOP
1AE4A  FFDE     NOP
9:             }
1AE4C  0EFA     MOVLW 0xFA
1C0C0  EE14     LFSR 1, 0x115E
10:            
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/xxtofl.c  ------------------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
1847A  0E05     MOVLW 0x5
1847C  26E1     ADDWF 0xFE1, F, ACCESS
1847E  0E00     MOVLW 0x0
18480  22E2     ADDWFC 0xFE2, F, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
18482  0EFA     MOVLW 0xFA
18484  50E3     MOVF 0xFE3, W, ACCESS
18486  B4D8     BTFSC 0xFD8, 2, ACCESS
18488  D01D     BRA 0x84C4
1848A  0EF9     MOVLW 0xF9
1848C  AEE3     BTFSS 0xFE3, 7, ACCESS
1848E  D01A     BRA 0x84C4
16:            		arg = -val;
18490  0EF6     MOVLW 0xF6
18494  FF8C     NOP
18496  F009     NOP
18498  0EF7     MOVLW 0xF7
1849C  FF8C     NOP
1849E  F00A     NOP
184A0  0EF8     MOVLW 0xF8
184A4  FF8C     NOP
184A6  F00B     NOP
184A8  0EF9     MOVLW 0xF9
184AC  FF8C     NOP
184AE  F00C     NOP
184B0  1E09     COMF ltemp2, F, ACCESS
184B2  1E0A     COMF ttemp3, F, ACCESS
184B4  1E0B     COMF wtemp5, F, ACCESS
184B6  1E0C     COMF 0xC, F, ACCESS
184B8  2A09     INCF ltemp2, F, ACCESS
184BA  0E00     MOVLW 0x0
184BC  220A     ADDWFC ttemp3, F, ACCESS
184BE  220B     ADDWFC wtemp5, F, ACCESS
184C0  220C     ADDWFC 0xC, F, ACCESS
184C2  D010     BRA 0x84E4
17:            	}
18:            	else {
19:            		arg = val;
184C4  0EF6     MOVLW 0xF6
184C8  FF8C     NOP
184CA  F009     NOP
184CC  0EF7     MOVLW 0xF7
184D0  FF8C     NOP
184D2  F00A     NOP
184D4  0EF8     MOVLW 0xF8
184D8  FF8C     NOP
184DA  F00B     NOP
184DC  0EF9     MOVLW 0xF9
184E0  FF8C     NOP
184E2  F00C     NOP
184E4  0EFB     MOVLW 0xFB
184E8  F027     NOP
184EA  FFE3     NOP
184EC  0EFC     MOVLW 0xFC
184F0  F02B     NOP
184F2  FFE3     NOP
184F4  0EFD     MOVLW 0xFD
184F8  F02F     NOP
184FA  FFE3     NOP
184FC  0EFE     MOVLW 0xFE
18500  F033     NOP
18502  FFE3     NOP
20:            	}
21:            	if(val == 0)
18504  0EF6     MOVLW 0xF6
18506  50E3     MOVF 0xFE3, W, ACCESS
18508  E113     BNZ 0x8530
1850A  0EF7     MOVLW 0xF7
1850C  50E3     MOVF 0xFE3, W, ACCESS
1850E  E110     BNZ 0x8530
18510  0EF8     MOVLW 0xF8
18512  50E3     MOVF 0xFE3, W, ACCESS
18514  E10D     BNZ 0x8530
18516  0EF9     MOVLW 0xF9
18518  50E3     MOVF 0xFE3, W, ACCESS
1851A  A4D8     BTFSS 0xFD8, 2, ACCESS
1851C  D009     BRA 0x8530
22:            		return 0.0;
1851E  0E00     MOVLW 0x0
18520  6E01     MOVWF ltemp0, ACCESS
18522  0E00     MOVLW 0x0
18524  6E02     MOVWF ttemp5, ACCESS
18526  0E00     MOVLW 0x0
18528  6E03     MOVWF wtemp1, ACCESS
1852A  0E00     MOVLW 0x0
1852C  6E04     MOVWF ttemp1, ACCESS
1852E  D0A2     BRA 0x8674
23:            	exp = (127 + 23);
18530  0E96     MOVLW 0x96
18532  6E0C     MOVWF 0xC, ACCESS
18534  0EFF     MOVLW 0xFF
18538  F033     NOP
1853A  FFE3     NOP
24:            	while(arg & ~0x1FFFFFFUL) {
1853C  D00B     BRA 0x8554
18554  50E1     MOVF 0xFE1, W, ACCESS
18556  0FFB     ADDLW 0xFB
18558  6ED9     MOVWF 0xFD9, ACCESS
1855A  50E2     MOVF 0xFE2, W, ACCESS
1855C  6EDA     MOVWF 0xFDA, ACCESS
1855E  0EFF     MOVLW 0xFF
18560  22DA     ADDWFC 0xFDA, F, ACCESS
18562  52DE     MOVF 0xFDE, F, ACCESS
18564  52DE     MOVF 0xFDE, F, ACCESS
18566  52DE     MOVF 0xFDE, F, ACCESS
18568  0EFE     MOVLW 0xFE
1856A  14DD     ANDWF 0xFDD, W, ACCESS
1856C  B4D8     BTFSC 0xFD8, 2, ACCESS
1856E  D018     BRA 0x85A0
18570  D7E6     BRA 0x853E
25:            		++exp;
1853E  0EFF     MOVLW 0xFF
18540  2AE3     INCF 0xFE3, F, ACCESS
26:            		arg >>= 1;
18542  90D8     BCF 0xFD8, 0, ACCESS
18544  0EFE     MOVLW 0xFE
18546  32E3     RRCF 0xFE3, F, ACCESS
18548  0EFD     MOVLW 0xFD
1854A  32E3     RRCF 0xFE3, F, ACCESS
1854C  0EFC     MOVLW 0xFC
1854E  32E3     RRCF 0xFE3, F, ACCESS
18550  0EFB     MOVLW 0xFB
18552  32E3     RRCF 0xFE3, F, ACCESS
27:            	}
28:            	while(arg & ~0xFFFFFFUL) {
185A0  50E1     MOVF 0xFE1, W, ACCESS
185A2  0FFB     ADDLW 0xFB
185A4  6ED9     MOVWF 0xFD9, ACCESS
185A6  50E2     MOVF 0xFE2, W, ACCESS
185A8  6EDA     MOVWF 0xFDA, ACCESS
185AA  0EFF     MOVLW 0xFF
185AC  22DA     ADDWFC 0xFDA, F, ACCESS
185AE  52DE     MOVF 0xFDE, F, ACCESS
185B0  52DE     MOVF 0xFDE, F, ACCESS
185B2  52DE     MOVF 0xFDE, F, ACCESS
185B4  0EFF     MOVLW 0xFF
185B6  14DD     ANDWF 0xFDD, W, ACCESS
185B8  B4D8     BTFSC 0xFD8, 2, ACCESS
185BA  D00C     BRA 0x85D4
185BC  D7DA     BRA 0x8572
29:            		++exp;
18572  0EFF     MOVLW 0xFF
18574  2AE3     INCF 0xFE3, F, ACCESS
30:            		++arg;
18576  50E1     MOVF 0xFE1, W, ACCESS
18578  0FFB     ADDLW 0xFB
1857A  6ED9     MOVWF 0xFD9, ACCESS
1857C  50E2     MOVF 0xFE2, W, ACCESS
1857E  6EDA     MOVWF 0xFDA, ACCESS
18580  0EFF     MOVLW 0xFF
18582  22DA     ADDWFC 0xFDA, F, ACCESS
18584  2ADE     INCF 0xFDE, F, ACCESS
18586  0E00     MOVLW 0x0
18588  22DE     ADDWFC 0xFDE, F, ACCESS
1858A  22DE     ADDWFC 0xFDE, F, ACCESS
1858C  22DE     ADDWFC 0xFDE, F, ACCESS
31:            		arg >>= 1;
1858E  90D8     BCF 0xFD8, 0, ACCESS
18590  0EFE     MOVLW 0xFE
18592  32E3     RRCF 0xFE3, F, ACCESS
18594  0EFD     MOVLW 0xFD
18596  32E3     RRCF 0xFE3, F, ACCESS
18598  0EFC     MOVLW 0xFC
1859A  32E3     RRCF 0xFE3, F, ACCESS
1859C  0EFB     MOVLW 0xFB
1859E  32E3     RRCF 0xFE3, F, ACCESS
32:            	}
33:            	while(!(arg & 0x800000UL) && exp > 1) {
185D4  0EFD     MOVLW 0xFD
185D6  BEE3     BTFSC 0xFE3, 7, ACCESS
185D8  D007     BRA 0x85E8
185DA  0EFF     MOVLW 0xFF
185DE  FF8C     NOP
185E0  F001     NOP
185E2  0E02     MOVLW 0x2
185E4  6001     CPFSLT ltemp0, ACCESS
185E6  D7EB     BRA 0x85BE
34:            		--exp;
185BE  0EFF     MOVLW 0xFF
185C0  06E3     DECF 0xFE3, F, ACCESS
35:            		arg <<= 1;
185C2  90D8     BCF 0xFD8, 0, ACCESS
185C4  0EFB     MOVLW 0xFB
185C6  36E3     RLCF 0xFE3, F, ACCESS
185C8  0EFC     MOVLW 0xFC
185CA  36E3     RLCF 0xFE3, F, ACCESS
185CC  0EFD     MOVLW 0xFD
185CE  36E3     RLCF 0xFE3, F, ACCESS
185D0  0EFE     MOVLW 0xFE
185D2  36E3     RLCF 0xFE3, F, ACCESS
36:            	}
37:            	if(!(exp & 1))
185E8  0EFF     MOVLW 0xFF
185EA  B0E3     BTFSC 0xFE3, 0, ACCESS
185EC  D002     BRA 0x85F2
38:            		arg &= ~0x800000UL;
185EE  0EFD     MOVLW 0xFD
185F0  9EE3     BCF 0xFE3, 7, ACCESS
39:            	exp >>= 1;
185F2  50E1     MOVF 0xFE1, W, ACCESS
185F4  0FFF     ADDLW 0xFF
185F6  6ED9     MOVWF 0xFD9, ACCESS
185F8  50E2     MOVF 0xFE2, W, ACCESS
185FA  6EDA     MOVWF 0xFDA, ACCESS
185FC  0EFF     MOVLW 0xFF
185FE  22DA     ADDWFC 0xFDA, F, ACCESS
18600  90D8     BCF 0xFD8, 0, ACCESS
18602  32DF     RRCF 0xFDF, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
18604  0EFF     MOVLW 0xFF
18608  FF8C     NOP
1860A  F00C     NOP
1860E  F030     NOP
18610  F005     NOP
18612  6A06     CLRF 0x6, ACCESS
18614  6A07     CLRF ttemp2, ACCESS
18616  6A08     CLRF 0x8, ACCESS
1861A  F014     NOP
1861C  F008     NOP
1861E  6A07     CLRF ttemp2, ACCESS
18620  6A06     CLRF 0x6, ACCESS
18622  6A05     CLRF ltemp1, ACCESS
18624  50E1     MOVF 0xFE1, W, ACCESS
18626  0FFB     ADDLW 0xFB
18628  6ED9     MOVWF 0xFD9, ACCESS
1862A  50E2     MOVF 0xFE2, W, ACCESS
1862C  6EDA     MOVWF 0xFDA, ACCESS
1862E  0EFF     MOVLW 0xFF
18630  22DA     ADDWFC 0xFDA, F, ACCESS
18632  5005     MOVF ltemp1, W, ACCESS
18634  12DE     IORWF 0xFDE, F, ACCESS
18636  5006     MOVF 0x6, W, ACCESS
18638  12DE     IORWF 0xFDE, F, ACCESS
1863A  5007     MOVF ttemp2, W, ACCESS
1863C  12DE     IORWF 0xFDE, F, ACCESS
1863E  5008     MOVF 0x8, W, ACCESS
18640  12DE     IORWF 0xFDE, F, ACCESS
41:            	if(sign && val < 0)
18642  0EFA     MOVLW 0xFA
18644  50E3     MOVF 0xFE3, W, ACCESS
18646  B4D8     BTFSC 0xFD8, 2, ACCESS
18648  D005     BRA 0x8654
1864A  0EF9     MOVLW 0xF9
1864C  AEE3     BTFSS 0xFE3, 7, ACCESS
1864E  D002     BRA 0x8654
42:            		arg |= 0x80000000UL;
18650  0EFE     MOVLW 0xFE
18652  8EE3     BSF 0xFE3, 7, ACCESS
43:            	return *(double *)&arg;
18654  0EFB     MOVLW 0xFB
18658  FF8C     NOP
1865A  F001     NOP
1865C  0EFC     MOVLW 0xFC
18660  FF8C     NOP
18662  F002     NOP
18664  0EFD     MOVLW 0xFD
18668  FF8C     NOP
1866A  F003     NOP
1866C  0EFE     MOVLW 0xFE
18670  FF8C     NOP
18672  F004     NOP
44:            }
18674  0EF6     MOVLW 0xF6
18676  26E1     ADDWF 0xFE1, F, ACCESS
18678  0EFF     MOVLW 0xFF
1867A  22E2     ADDWFC 0xFE2, F, ACCESS
1867C  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/toupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
1AC54  52E6     MOVF 0xFE6, F, ACCESS
1AC56  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	if (islower(c)) return c & 0x5f;
1AC58  0EFC     MOVLW 0xFC
1AC5A  50E3     MOVF 0xFE3, W, ACCESS
1AC5C  0F9F     ADDLW 0x9F
1AC5E  6E0B     MOVWF wtemp5, ACCESS
1AC60  0EFD     MOVLW 0xFD
1AC64  FF8C     NOP
1AC66  F00C     NOP
1AC68  0EFF     MOVLW 0xFF
1AC6A  220C     ADDWFC 0xC, F, ACCESS
1AC6C  500C     MOVF 0xC, W, ACCESS
1AC6E  E106     BNZ 0xAC7C
1AC70  0E1A     MOVLW 0x1A
1AC72  5C0B     SUBWF wtemp5, W, ACCESS
1AC74  B0D8     BTFSC 0xFD8, 0, ACCESS
1AC76  D002     BRA 0xAC7C
1AC78  0E01     MOVLW 0x1
1AC7A  D001     BRA 0xAC7E
1AC7C  0E00     MOVLW 0x0
1AC7E  6E0B     MOVWF wtemp5, ACCESS
1AC80  6A0C     CLRF 0xC, ACCESS
1AC82  0EFE     MOVLW 0xFE
1AC86  F02F     NOP
1AC88  FFE3     NOP
1AC8A  0EFF     MOVLW 0xFF
1AC8E  F033     NOP
1AC90  FFE3     NOP
1AC92  0EFE     MOVLW 0xFE
1AC96  FF8C     NOP
1AC98  F001     NOP
1AC9A  0EFF     MOVLW 0xFF
1AC9C  50E3     MOVF 0xFE3, W, ACCESS
1AC9E  1001     IORWF ltemp0, W, ACCESS
1ACA0  B4D8     BTFSC 0xFD8, 2, ACCESS
1ACA2  D00D     BRA 0xACBE
1ACA4  0EFC     MOVLW 0xFC
1ACA8  FF8C     NOP
1ACAA  F001     NOP
1ACAC  0EFD     MOVLW 0xFD
1ACB0  FF8C     NOP
1ACB2  F002     NOP
1ACB4  0E5F     MOVLW 0x5F
1ACB6  1601     ANDWF ltemp0, F, ACCESS
1ACB8  0E00     MOVLW 0x0
1ACBA  1602     ANDWF ttemp5, F, ACCESS
1ACBC  D008     BRA 0xACCE
7:             	return c;
1ACBE  0EFC     MOVLW 0xFC
1ACC2  FF8C     NOP
1ACC4  F001     NOP
1ACC6  0EFD     MOVLW 0xFD
1ACCA  FF8C     NOP
1ACCC  F002     NOP
8:             }
1ACCE  52E5     MOVF 0xFE5, F, ACCESS
1ACD0  52E5     MOVF 0xFE5, F, ACCESS
1ACD2  52E5     MOVF 0xFE5, F, ACCESS
1ACD4  52E5     MOVF 0xFE5, F, ACCESS
1ACD6  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/tolower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int tolower(int c)
1ACD8  52E6     MOVF 0xFE6, F, ACCESS
1ACDA  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	if (isupper(c)) return c | 32;
1ACDC  0EFC     MOVLW 0xFC
1ACDE  50E3     MOVF 0xFE3, W, ACCESS
1ACE0  0FBF     ADDLW 0xBF
1ACE2  6E0B     MOVWF wtemp5, ACCESS
1ACE4  0EFD     MOVLW 0xFD
1ACE8  FF8C     NOP
1ACEA  F00C     NOP
1ACEC  0EFF     MOVLW 0xFF
1ACEE  220C     ADDWFC 0xC, F, ACCESS
1ACF0  500C     MOVF 0xC, W, ACCESS
1ACF2  E106     BNZ 0xAD00
1ACF4  0E1A     MOVLW 0x1A
1ACF6  5C0B     SUBWF wtemp5, W, ACCESS
1ACF8  B0D8     BTFSC 0xFD8, 0, ACCESS
1ACFA  D002     BRA 0xAD00
1ACFC  0E01     MOVLW 0x1
1ACFE  D001     BRA 0xAD02
1AD00  0E00     MOVLW 0x0
1AD02  6E0B     MOVWF wtemp5, ACCESS
1AD04  6A0C     CLRF 0xC, ACCESS
1AD06  0EFE     MOVLW 0xFE
1AD0A  F02F     NOP
1AD0C  FFE3     NOP
1AD0E  0EFF     MOVLW 0xFF
1AD12  F033     NOP
1AD14  FFE3     NOP
1AD16  0EFE     MOVLW 0xFE
1AD1A  FF8C     NOP
1AD1C  F001     NOP
1AD1E  0EFF     MOVLW 0xFF
1AD20  50E3     MOVF 0xFE3, W, ACCESS
1AD22  1001     IORWF ltemp0, W, ACCESS
1AD24  B4D8     BTFSC 0xFD8, 2, ACCESS
1AD26  D00D     BRA 0xAD42
1AD28  0EFC     MOVLW 0xFC
1AD2C  FF8C     NOP
1AD2E  F001     NOP
1AD30  0EFD     MOVLW 0xFD
1AD34  FF8C     NOP
1AD36  F002     NOP
1AD38  0E20     MOVLW 0x20
1AD3A  1201     IORWF ltemp0, F, ACCESS
1AD3C  0E00     MOVLW 0x0
1AD3E  1202     IORWF ttemp5, F, ACCESS
1AD40  D008     BRA 0xAD52
7:             	return c;
1AD42  0EFC     MOVLW 0xFC
1AD46  FF8C     NOP
1AD48  F001     NOP
1AD4A  0EFD     MOVLW 0xFD
1AD4E  FF8C     NOP
1AD50  F002     NOP
8:             }
1AD52  52E5     MOVF 0xFE5, F, ACCESS
1AD54  52E5     MOVF 0xFE5, F, ACCESS
1AD56  52E5     MOVF 0xFE5, F, ACCESS
1AD58  52E5     MOVF 0xFE5, F, ACCESS
1AD5A  0012     RETURN 0
9:             
10:            int __tolower_l(int c, locale_t l)
11:            {
12:            	return tolower(c);
13:            }
14:            
15:            weak_alias(__tolower_l, tolower_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strncmp.c  -----------------------------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
18048  52E6     MOVF 0xFE6, F, ACCESS
1804A  52E6     MOVF 0xFE6, F, ACCESS
1804C  52E6     MOVF 0xFE6, F, ACCESS
1804E  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
18050  0EFA     MOVLW 0xFA
18054  FF8C     NOP
18056  F00B     NOP
18058  0EFB     MOVLW 0xFB
1805C  FF8C     NOP
1805E  F00C     NOP
18060  0EFF     MOVLW 0xFF
18064  F033     NOP
18066  FFE3     NOP
18068  0EFE     MOVLW 0xFE
1806C  F02F     NOP
1806E  FFE3     NOP
18070  0EF8     MOVLW 0xF8
18074  FF8C     NOP
18076  F00B     NOP
18078  0EF9     MOVLW 0xF9
1807C  FF8C     NOP
1807E  F00C     NOP
18080  0EFD     MOVLW 0xFD
18084  F033     NOP
18086  FFE3     NOP
18088  0EFC     MOVLW 0xFC
1808C  F02F     NOP
1808E  FFE3     NOP
6:             	if (!n--) return 0;
18090  0EF6     MOVLW 0xF6
18094  FF8C     NOP
18096  F001     NOP
18098  0E01     MOVLW 0x1
1809A  5E01     SUBWF ltemp0, F, ACCESS
1809C  0EF6     MOVLW 0xF6
180A0  F007     NOP
180A2  FFE3     NOP
180A4  0EF7     MOVLW 0xF7
180A8  FF8C     NOP
180AA  F001     NOP
180AC  0E00     MOVLW 0x0
180AE  5A01     SUBWFB ltemp0, F, ACCESS
180B0  0EF7     MOVLW 0xF7
180B4  F007     NOP
180B6  FFE3     NOP
180B8  0EF6     MOVLW 0xF6
180BA  28E3     INCF 0xFE3, W, ACCESS
180BC  E13F     BNZ 0x813C
180BE  0EF7     MOVLW 0xF7
180C0  28E3     INCF 0xFE3, W, ACCESS
180C2  A4D8     BTFSS 0xFD8, 2, ACCESS
180C4  D03B     BRA 0x813C
180C6  0E00     MOVLW 0x0
180C8  6E01     MOVWF ltemp0, ACCESS
180CA  0E00     MOVLW 0x0
180CC  6E02     MOVWF ttemp5, ACCESS
180CE  D0C7     BRA 0x825E
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
180D0  0EFE     MOVLW 0xFE
180D2  50E3     MOVF 0xFE3, W, ACCESS
180D4  0F01     ADDLW 0x1
180D6  6E01     MOVWF ltemp0, ACCESS
180D8  0EFE     MOVLW 0xFE
180DC  F007     NOP
180DE  FFE3     NOP
180E0  6A01     CLRF ltemp0, ACCESS
180E2  0EFF     MOVLW 0xFF
180E4  50E3     MOVF 0xFE3, W, ACCESS
180E6  2001     ADDWFC ltemp0, W, ACCESS
180E8  6E01     MOVWF ltemp0, ACCESS
180EA  0EFF     MOVLW 0xFF
180EE  F007     NOP
180F0  FFE3     NOP
180F2  0EFC     MOVLW 0xFC
180F4  50E3     MOVF 0xFE3, W, ACCESS
180F6  0F01     ADDLW 0x1
180F8  6E01     MOVWF ltemp0, ACCESS
180FA  0EFC     MOVLW 0xFC
180FE  F007     NOP
18100  FFE3     NOP
18102  6A01     CLRF ltemp0, ACCESS
18104  0EFD     MOVLW 0xFD
18106  50E3     MOVF 0xFE3, W, ACCESS
18108  2001     ADDWFC ltemp0, W, ACCESS
1810A  6E01     MOVWF ltemp0, ACCESS
1810C  0EFD     MOVLW 0xFD
18110  F007     NOP
18112  FFE3     NOP
18114  0EF6     MOVLW 0xF6
18118  FF8C     NOP
1811A  F001     NOP
1811C  0E01     MOVLW 0x1
1811E  5E01     SUBWF ltemp0, F, ACCESS
18120  0EF6     MOVLW 0xF6
18124  F007     NOP
18126  FFE3     NOP
18128  0EF7     MOVLW 0xF7
1812C  FF8C     NOP
1812E  F001     NOP
18130  0E00     MOVLW 0x0
18132  5A01     SUBWFB ltemp0, F, ACCESS
18134  0EF7     MOVLW 0xF7
18138  F007     NOP
1813A  FFE3     NOP
1813C  0EFE     MOVLW 0xFE
18140  FF8F     NOP
18142  FFF6     NOP
18144  0EFF     MOVLW 0xFF
18148  FF8F     NOP
1814A  FFF7     NOP
1814C  0E00     MOVLW 0x0
1814E  6EF8     MOVWF 0xFF8, ACCESS
18150  0E1F     MOVLW 0x1F
18152  64F7     CPFSGT 0xFF7, ACCESS
18154  D003     BRA 0x815C
18156  0008     TBLRD*
18158  50F5     MOVF 0xFF5, W, ACCESS
1815A  D007     BRA 0x816A
1815E  FFDB     NOP
18160  FFE9     NOP
18164  FFDF     NOP
18166  FFEA     NOP
18168  50EF     MOVF 0xFEF, W, ACCESS
1816A  0900     IORLW 0x0
1816C  B4D8     BTFSC 0xFD8, 2, ACCESS
1816E  D04A     BRA 0x8204
18170  50E1     MOVF 0xFE1, W, ACCESS
18172  0FFC     ADDLW 0xFC
18174  6ED9     MOVWF 0xFD9, ACCESS
18176  50E2     MOVF 0xFE2, W, ACCESS
18178  6EDA     MOVWF 0xFDA, ACCESS
1817A  0EFF     MOVLW 0xFF
1817C  22DA     ADDWFC 0xFDA, F, ACCESS
18180  FF7B     NOP
18182  FFF6     NOP
18186  FF77     NOP
18188  FFF7     NOP
1818A  0E00     MOVLW 0x0
1818C  6EF8     MOVWF 0xFF8, ACCESS
1818E  0008     TBLRD*
18190  50F5     MOVF 0xFF5, W, ACCESS
18192  0900     IORLW 0x0
18194  B4D8     BTFSC 0xFD8, 2, ACCESS
18196  D036     BRA 0x8204
18198  0EF6     MOVLW 0xF6
1819C  FF8C     NOP
1819E  F001     NOP
181A0  0EF7     MOVLW 0xF7
181A2  50E3     MOVF 0xFE3, W, ACCESS
181A4  1001     IORWF ltemp0, W, ACCESS
181A6  B4D8     BTFSC 0xFD8, 2, ACCESS
181A8  D02D     BRA 0x8204
181AA  50E1     MOVF 0xFE1, W, ACCESS
181AC  0FFC     ADDLW 0xFC
181AE  6ED9     MOVWF 0xFD9, ACCESS
181B0  50E2     MOVF 0xFE2, W, ACCESS
181B2  6EDA     MOVWF 0xFDA, ACCESS
181B4  0EFF     MOVLW 0xFF
181B6  22DA     ADDWFC 0xFDA, F, ACCESS
181BA  FF7B     NOP
181BC  FFF6     NOP
181C0  FF77     NOP
181C2  FFF7     NOP
181C4  0E00     MOVLW 0x0
181C6  6EF8     MOVWF 0xFF8, ACCESS
181C8  0008     TBLRD*
181CC  FFD4     NOP
181CE  F00C     NOP
181D0  0EFE     MOVLW 0xFE
181D4  FF8F     NOP
181D6  FFF6     NOP
181D8  0EFF     MOVLW 0xFF
181DC  FF8F     NOP
181DE  FFF7     NOP
181E0  0E00     MOVLW 0x0
181E2  6EF8     MOVWF 0xFF8, ACCESS
181E4  0E1F     MOVLW 0x1F
181E6  64F7     CPFSGT 0xFF7, ACCESS
181E8  D003     BRA 0x81F0
181EA  0008     TBLRD*
181EC  50F5     MOVF 0xFF5, W, ACCESS
181EE  D007     BRA 0x81FE
181F2  FFDB     NOP
181F4  FFE9     NOP
181F8  FFDF     NOP
181FA  FFEA     NOP
181FC  50EF     MOVF 0xFEF, W, ACCESS
181FE  180C     XORWF 0xC, W, ACCESS
18200  B4D8     BTFSC 0xFD8, 2, ACCESS
18202  D766     BRA 0x80D0
8:             	return *l - *r;
18204  0EFE     MOVLW 0xFE
18208  FF8F     NOP
1820A  FFF6     NOP
1820C  0EFF     MOVLW 0xFF
18210  FF8F     NOP
18212  FFF7     NOP
18214  0E00     MOVLW 0x0
18216  6EF8     MOVWF 0xFF8, ACCESS
18218  0E1F     MOVLW 0x1F
1821A  64F7     CPFSGT 0xFF7, ACCESS
1821C  D003     BRA 0x8224
1821E  0008     TBLRD*
18220  50F5     MOVF 0xFF5, W, ACCESS
18222  D007     BRA 0x8232
18226  FFDB     NOP
18228  FFE9     NOP
1822C  FFDF     NOP
1822E  FFEA     NOP
18230  50EF     MOVF 0xFEF, W, ACCESS
18232  6E01     MOVWF ltemp0, ACCESS
18234  6A02     CLRF ttemp5, ACCESS
18236  50E1     MOVF 0xFE1, W, ACCESS
18238  0FFC     ADDLW 0xFC
1823A  6ED9     MOVWF 0xFD9, ACCESS
1823C  50E2     MOVF 0xFE2, W, ACCESS
1823E  6EDA     MOVWF 0xFDA, ACCESS
18240  0EFF     MOVLW 0xFF
18242  22DA     ADDWFC 0xFDA, F, ACCESS
18246  FF7B     NOP
18248  FFF6     NOP
1824C  FF77     NOP
1824E  FFF7     NOP
18250  0E00     MOVLW 0x0
18252  6EF8     MOVWF 0xFF8, ACCESS
18254  0008     TBLRD*
18256  50F5     MOVF 0xFF5, W, ACCESS
18258  5E01     SUBWF ltemp0, F, ACCESS
1825A  0E00     MOVLW 0x0
1825C  5A02     SUBWFB ttemp5, F, ACCESS
9:             }
1825E  0EF6     MOVLW 0xF6
18260  26E1     ADDWF 0xFE1, F, ACCESS
18262  0EFF     MOVLW 0xFF
18264  22E2     ADDWFC 0xFE2, F, ACCESS
18266  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             size_t strlen(const char *s)
1A8DE  52E6     MOVF 0xFE6, F, ACCESS
1A8E0  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	const char *a = s;
1A8E2  0EFC     MOVLW 0xFC
1A8E6  FF8C     NOP
1A8E8  F00B     NOP
1A8EA  0EFD     MOVLW 0xFD
1A8EE  FF8C     NOP
1A8F0  F00C     NOP
1A8F2  0EFF     MOVLW 0xFF
1A8F6  F033     NOP
1A8F8  FFE3     NOP
1A8FA  0EFE     MOVLW 0xFE
1A8FE  F02F     NOP
1A900  FFE3     NOP
8:             	while(*s) {
1A902  D011     BRA 0xA926
1A926  0EFC     MOVLW 0xFC
1A92A  FF8F     NOP
1A92C  FFF6     NOP
1A92E  0EFD     MOVLW 0xFD
1A932  FF8F     NOP
1A934  FFF7     NOP
1A936  0E00     MOVLW 0x0
1A938  6EF8     MOVWF 0xFF8, ACCESS
1A93A  0E1F     MOVLW 0x1F
1A93C  64F7     CPFSGT 0xFF7, ACCESS
1A93E  D003     BRA 0xA946
1A940  0008     TBLRD*
1A942  50F5     MOVF 0xFF5, W, ACCESS
1A944  D007     BRA 0xA954
1A948  FFDB     NOP
1A94A  FFE9     NOP
1A94E  FFDF     NOP
1A950  FFEA     NOP
1A952  50EF     MOVF 0xFEF, W, ACCESS
1A954  0900     IORLW 0x0
1A956  A4D8     BTFSS 0xFD8, 2, ACCESS
1A958  D7D5     BRA 0xA904
9:             		s++;
1A904  0EFC     MOVLW 0xFC
1A906  50E3     MOVF 0xFE3, W, ACCESS
1A908  0F01     ADDLW 0x1
1A90A  6E01     MOVWF ltemp0, ACCESS
1A90C  0EFC     MOVLW 0xFC
1A910  F007     NOP
1A912  FFE3     NOP
1A914  6A01     CLRF ltemp0, ACCESS
1A916  0EFD     MOVLW 0xFD
1A918  50E3     MOVF 0xFE3, W, ACCESS
1A91A  2001     ADDWFC ltemp0, W, ACCESS
1A91C  6E01     MOVWF ltemp0, ACCESS
1A91E  0EFD     MOVLW 0xFD
1A922  F007     NOP
1A924  FFE3     NOP
10:            	}
11:            	return s-a;
1A95A  0EFC     MOVLW 0xFC
1A95E  FF8C     NOP
1A960  F001     NOP
1A962  0EFD     MOVLW 0xFD
1A966  FF8C     NOP
1A968  F002     NOP
1A96A  0EFE     MOVLW 0xFE
1A96C  50E3     MOVF 0xFE3, W, ACCESS
1A96E  5E01     SUBWF ltemp0, F, ACCESS
1A970  0EFF     MOVLW 0xFF
1A972  50E3     MOVF 0xFE3, W, ACCESS
1A974  5A02     SUBWFB ttemp5, F, ACCESS
12:            }
1A976  52E5     MOVF 0xFE5, F, ACCESS
1A978  52E5     MOVF 0xFE5, F, ACCESS
1A97A  52E5     MOVF 0xFE5, F, ACCESS
1A97C  52E5     MOVF 0xFE5, F, ACCESS
1A97E  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/strcpy.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             char *strcpy(char *restrict dest, const char *restrict src)
1A282  52E6     MOVF 0xFE6, F, ACCESS
1A284  52E6     MOVF 0xFE6, F, ACCESS
1A286  52E6     MOVF 0xFE6, F, ACCESS
1A288  52E6     MOVF 0xFE6, F, ACCESS
4:             {
5:             	const char *s = src;
1A28A  0EF8     MOVLW 0xF8
1A28E  FF8C     NOP
1A290  F00B     NOP
1A292  0EF9     MOVLW 0xF9
1A296  FF8C     NOP
1A298  F00C     NOP
1A29A  0EFF     MOVLW 0xFF
1A29E  F033     NOP
1A2A0  FFE3     NOP
1A2A2  0EFE     MOVLW 0xFE
1A2A6  F02F     NOP
1A2A8  FFE3     NOP
6:             	char *d = dest;
1A2AA  0EFA     MOVLW 0xFA
1A2AE  FF8C     NOP
1A2B0  F00B     NOP
1A2B2  0EFB     MOVLW 0xFB
1A2B6  FF8C     NOP
1A2B8  F00C     NOP
1A2BA  0EFD     MOVLW 0xFD
1A2BE  F033     NOP
1A2C0  FFE3     NOP
1A2C2  0EFC     MOVLW 0xFC
1A2C6  F02F     NOP
1A2C8  FFE3     NOP
7:             	while ((*d++ = *s++));
1A2CA  50E1     MOVF 0xFE1, W, ACCESS
1A2CC  0FFE     ADDLW 0xFE
1A2CE  6ED9     MOVWF 0xFD9, ACCESS
1A2D0  50E2     MOVF 0xFE2, W, ACCESS
1A2D2  6EDA     MOVWF 0xFDA, ACCESS
1A2D4  0EFF     MOVLW 0xFF
1A2D6  22DA     ADDWFC 0xFDA, F, ACCESS
1A2DA  FF7C     NOP
1A2DC  F00B     NOP
1A2DE  0E01     MOVLW 0x1
1A2E0  26DE     ADDWF 0xFDE, F, ACCESS
1A2E4  FF7C     NOP
1A2E6  F00C     NOP
1A2E8  0E00     MOVLW 0x0
1A2EA  22DD     ADDWFC 0xFDD, F, ACCESS
1A2EE  F02F     NOP
1A2F0  FFF6     NOP
1A2F4  F033     NOP
1A2F6  FFF7     NOP
1A2F8  0E00     MOVLW 0x0
1A2FA  6EF8     MOVWF 0xFF8, ACCESS
1A2FC  50E1     MOVF 0xFE1, W, ACCESS
1A2FE  0FFC     ADDLW 0xFC
1A300  6ED9     MOVWF 0xFD9, ACCESS
1A302  50E2     MOVF 0xFE2, W, ACCESS
1A304  6EDA     MOVWF 0xFDA, ACCESS
1A306  0EFF     MOVLW 0xFF
1A308  22DA     ADDWFC 0xFDA, F, ACCESS
1A30C  FF7C     NOP
1A30E  F00B     NOP
1A310  0E01     MOVLW 0x1
1A312  26DE     ADDWF 0xFDE, F, ACCESS
1A316  FF7C     NOP
1A318  F00C     NOP
1A31A  0E00     MOVLW 0x0
1A31C  22DD     ADDWFC 0xFDD, F, ACCESS
1A320  F02F     NOP
1A322  FFD9     NOP
1A326  F033     NOP
1A328  FFDA     NOP
1A32A  0E1F     MOVLW 0x1F
1A32C  64F7     CPFSGT 0xFF7, ACCESS
1A32E  D003     BRA 0xA336
1A330  0008     TBLRD*
1A332  50F5     MOVF 0xFF5, W, ACCESS
1A334  D007     BRA 0xA344
1A338  FFDB     NOP
1A33A  FFE9     NOP
1A33E  FFDF     NOP
1A340  FFEA     NOP
1A342  50EF     MOVF 0xFEF, W, ACCESS
1A344  6EDF     MOVWF 0xFDF, ACCESS
1A346  50DF     MOVF 0xFDF, W, ACCESS
1A348  A4D8     BTFSS 0xFD8, 2, ACCESS
1A34A  D7BF     BRA 0xA2CA
8:             	return dest;
9:             }
1A34C  0EF8     MOVLW 0xF8
1A34E  26E1     ADDWF 0xFE1, F, ACCESS
1A350  0EFF     MOVLW 0xFF
1A352  22E2     ADDWFC 0xFE2, F, ACCESS
1A354  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcmul.c  -----------------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
13D82  0E0D     MOVLW 0xD
13D84  26E1     ADDWF 0xFE1, F, ACCESS
13D86  0E00     MOVLW 0x0
13D88  22E2     ADDWFC 0xFE2, F, ACCESS
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
13D8A  0EF2     MOVLW 0xF2
13D8C  24E1     ADDWF 0xFE1, W, ACCESS
13D8E  6ED9     MOVWF 0xFD9, ACCESS
13D90  0EFF     MOVLW 0xFF
13D92  20E2     ADDWFC 0xFE2, W, ACCESS
13D94  6EDA     MOVWF 0xFDA, ACCESS
13D96  50DF     MOVF 0xFDF, W, ACCESS
13D98  6E0C     MOVWF 0xC, ACCESS
13D9A  0E80     MOVLW 0x80
13D9C  160C     ANDWF 0xC, F, ACCESS
13D9E  0EFF     MOVLW 0xFF
13DA2  F033     NOP
13DA4  FFE3     NOP
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
13DA6  0EF2     MOVLW 0xF2
13DA8  24E1     ADDWF 0xFE1, W, ACCESS
13DAA  6ED9     MOVWF 0xFD9, ACCESS
13DAC  0EFF     MOVLW 0xFF
13DAE  20E2     ADDWFC 0xFE2, W, ACCESS
13DB0  6EDA     MOVWF 0xFDA, ACCESS
13DB2  50DF     MOVF 0xFDF, W, ACCESS
13DB4  6E0C     MOVWF 0xC, ACCESS
13DB6  90D8     BCF 0xFD8, 0, ACCESS
13DB8  340C     RLCF 0xC, W, ACCESS
13DBA  6E0B     MOVWF wtemp5, ACCESS
13DBC  0EFD     MOVLW 0xFD
13DC0  F02F     NOP
13DC2  FFE3     NOP
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
13DC4  0EF1     MOVLW 0xF1
13DC6  24E1     ADDWF 0xFE1, W, ACCESS
13DC8  6ED9     MOVWF 0xFD9, ACCESS
13DCA  0EFF     MOVLW 0xFF
13DCC  20E2     ADDWFC 0xFE2, W, ACCESS
13DCE  6EDA     MOVWF 0xFDA, ACCESS
13DD0  AEDF     BTFSS 0xFDF, 7, ACCESS
13DD2  D002     BRA 0x3DD8
20:            		bexp |= 0x1;
13DD4  0EFD     MOVLW 0xFD
13DD6  80E3     BSF 0xFE3, 0, ACCESS
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
13DD8  0EFD     MOVLW 0xFD
13DDA  50E3     MOVF 0xFE3, W, ACCESS
13DDC  B4D8     BTFSC 0xFD8, 2, ACCESS
13DDE  D01F     BRA 0x3E1E
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
13DE0  0EFD     MOVLW 0xFD
13DE2  28E3     INCF 0xFE3, W, ACCESS
13DE4  A4D8     BTFSS 0xFD8, 2, ACCESS
13DE6  D018     BRA 0x3E18
27:            			/* Make it inf */
28:            			b = 0;
13DE8  0E00     MOVLW 0x0
13DEA  6E09     MOVWF ltemp2, ACCESS
13DEC  0E00     MOVLW 0x0
13DEE  6E0A     MOVWF ttemp3, ACCESS
13DF0  0E00     MOVLW 0x0
13DF2  6E0B     MOVWF wtemp5, ACCESS
13DF4  0E00     MOVLW 0x0
13DF6  6E0C     MOVWF 0xC, ACCESS
13DF8  0EEF     MOVLW 0xEF
13DFC  F027     NOP
13DFE  FFE3     NOP
13E00  0EF0     MOVLW 0xF0
13E04  F02B     NOP
13E06  FFE3     NOP
13E08  0EF1     MOVLW 0xF1
13E0C  F02F     NOP
13E0E  FFE3     NOP
13E10  0EF2     MOVLW 0xF2
13E14  F033     NOP
13E16  FFE3     NOP
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
13E18  0EF1     MOVLW 0xF1
13E1A  8EE3     BSF 0xFE3, 7, ACCESS
32:            
33:            	}
13E1C  D018     BRA 0x3E4E
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
13E1E  0E00     MOVLW 0x0
13E20  6E09     MOVWF ltemp2, ACCESS
13E22  0E00     MOVLW 0x0
13E24  6E0A     MOVWF ttemp3, ACCESS
13E26  0E00     MOVLW 0x0
13E28  6E0B     MOVWF wtemp5, ACCESS
13E2A  0E00     MOVLW 0x0
13E2C  6E0C     MOVWF 0xC, ACCESS
13E2E  0EEF     MOVLW 0xEF
13E32  F027     NOP
13E34  FFE3     NOP
13E36  0EF0     MOVLW 0xF0
13E3A  F02B     NOP
13E3C  FFE3     NOP
13E3E  0EF1     MOVLW 0xF1
13E42  F02F     NOP
13E44  FFE3     NOP
13E46  0EF2     MOVLW 0xF2
13E4A  F033     NOP
13E4C  FFE3     NOP
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
13E4E  0EEE     MOVLW 0xEE
13E50  24E1     ADDWF 0xFE1, W, ACCESS
13E52  6ED9     MOVWF 0xFD9, ACCESS
13E54  0EFF     MOVLW 0xFF
13E56  20E2     ADDWFC 0xFE2, W, ACCESS
13E58  6EDA     MOVWF 0xFDA, ACCESS
13E5A  50DF     MOVF 0xFDF, W, ACCESS
13E5C  6E0C     MOVWF 0xC, ACCESS
13E5E  0E80     MOVLW 0x80
13E60  160C     ANDWF 0xC, F, ACCESS
13E62  50E1     MOVF 0xFE1, W, ACCESS
13E64  0FFF     ADDLW 0xFF
13E66  6ED9     MOVWF 0xFD9, ACCESS
13E68  50E2     MOVF 0xFE2, W, ACCESS
13E6A  6EDA     MOVWF 0xFDA, ACCESS
13E6C  0EFF     MOVLW 0xFF
13E6E  22DA     ADDWFC 0xFDA, F, ACCESS
13E70  500C     MOVF 0xC, W, ACCESS
13E72  1ADF     XORWF 0xFDF, F, ACCESS
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
13E74  0EEE     MOVLW 0xEE
13E76  24E1     ADDWF 0xFE1, W, ACCESS
13E78  6ED9     MOVWF 0xFD9, ACCESS
13E7A  0EFF     MOVLW 0xFF
13E7C  20E2     ADDWFC 0xFE2, W, ACCESS
13E7E  6EDA     MOVWF 0xFDA, ACCESS
13E80  50DF     MOVF 0xFDF, W, ACCESS
13E82  6E0C     MOVWF 0xC, ACCESS
13E84  90D8     BCF 0xFD8, 0, ACCESS
13E86  340C     RLCF 0xC, W, ACCESS
13E88  6E0B     MOVWF wtemp5, ACCESS
13E8A  0EFE     MOVLW 0xFE
13E8E  F02F     NOP
13E90  FFE3     NOP
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
13E92  0EED     MOVLW 0xED
13E94  24E1     ADDWF 0xFE1, W, ACCESS
13E96  6ED9     MOVWF 0xFD9, ACCESS
13E98  0EFF     MOVLW 0xFF
13E9A  20E2     ADDWFC 0xFE2, W, ACCESS
13E9C  6EDA     MOVWF 0xFDA, ACCESS
13E9E  AEDF     BTFSS 0xFDF, 7, ACCESS
13EA0  D002     BRA 0x3EA6
42:            		aexp |= 0x1;
13EA2  0EFE     MOVLW 0xFE
13EA4  80E3     BSF 0xFE3, 0, ACCESS
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
13EA6  0EFE     MOVLW 0xFE
13EA8  50E3     MOVF 0xFE3, W, ACCESS
13EAA  B4D8     BTFSC 0xFD8, 2, ACCESS
13EAC  D01F     BRA 0x3EEC
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
13EAE  0EFE     MOVLW 0xFE
13EB0  28E3     INCF 0xFE3, W, ACCESS
13EB2  A4D8     BTFSS 0xFD8, 2, ACCESS
13EB4  D018     BRA 0x3EE6
49:            			/* Make it inf */
50:            			a = 0;
13EB6  0E00     MOVLW 0x0
13EB8  6E09     MOVWF ltemp2, ACCESS
13EBA  0E00     MOVLW 0x0
13EBC  6E0A     MOVWF ttemp3, ACCESS
13EBE  0E00     MOVLW 0x0
13EC0  6E0B     MOVWF wtemp5, ACCESS
13EC2  0E00     MOVLW 0x0
13EC4  6E0C     MOVWF 0xC, ACCESS
13EC6  0EEB     MOVLW 0xEB
13ECA  F027     NOP
13ECC  FFE3     NOP
13ECE  0EEC     MOVLW 0xEC
13ED2  F02B     NOP
13ED4  FFE3     NOP
13ED6  0EED     MOVLW 0xED
13EDA  F02F     NOP
13EDC  FFE3     NOP
13EDE  0EEE     MOVLW 0xEE
13EE2  F033     NOP
13EE4  FFE3     NOP
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
13EE6  0EED     MOVLW 0xED
13EE8  8EE3     BSF 0xFE3, 7, ACCESS
54:            	}
13EEA  D018     BRA 0x3F1C
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
13EEC  0E00     MOVLW 0x0
13EEE  6E09     MOVWF ltemp2, ACCESS
13EF0  0E00     MOVLW 0x0
13EF2  6E0A     MOVWF ttemp3, ACCESS
13EF4  0E00     MOVLW 0x0
13EF6  6E0B     MOVWF wtemp5, ACCESS
13EF8  0E00     MOVLW 0x0
13EFA  6E0C     MOVWF 0xC, ACCESS
13EFC  0EEB     MOVLW 0xEB
13F00  F027     NOP
13F02  FFE3     NOP
13F04  0EEC     MOVLW 0xEC
13F08  F02B     NOP
13F0A  FFE3     NOP
13F0C  0EED     MOVLW 0xED
13F10  F02F     NOP
13F12  FFE3     NOP
13F14  0EEE     MOVLW 0xEE
13F18  F033     NOP
13F1A  FFE3     NOP
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
13F1C  0EFE     MOVLW 0xFE
13F1E  50E3     MOVF 0xFE3, W, ACCESS
13F20  B4D8     BTFSC 0xFD8, 2, ACCESS
13F22  D004     BRA 0x3F2C
13F24  0EFD     MOVLW 0xFD
13F26  50E3     MOVF 0xFE3, W, ACCESS
13F28  A4D8     BTFSS 0xFD8, 2, ACCESS
13F2A  D009     BRA 0x3F3E
66:            		return 0.0;
13F2C  0E00     MOVLW 0x0
13F2E  6E01     MOVWF ltemp0, ACCESS
13F30  0E00     MOVLW 0x0
13F32  6E02     MOVWF ttemp5, ACCESS
13F34  0E00     MOVLW 0x0
13F36  6E03     MOVWF wtemp1, ACCESS
13F38  0E00     MOVLW 0x0
13F3A  6E04     MOVWF ttemp1, ACCESS
13F3C  D332     BRA 0x45A2
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
13F3E  0EEF     MOVLW 0xEF
13F42  FF8C     NOP
13F44  F00C     NOP
13F46  0EED     MOVLW 0xED
13F48  24E1     ADDWF 0xFE1, W, ACCESS
13F4A  6ED9     MOVWF 0xFD9, ACCESS
13F4C  0EFF     MOVLW 0xFF
13F4E  20E2     ADDWFC 0xFE2, W, ACCESS
13F50  6EDA     MOVWF 0xFDA, ACCESS
13F52  50DF     MOVF 0xFDF, W, ACCESS
13F54  020C     MULWF 0xC, ACCESS
13F56  0EFB     MOVLW 0xFB
13F5A  FFCF     NOP
13F5C  FFE3     NOP
13F5E  0EFC     MOVLW 0xFC
13F62  FFD3     NOP
13F64  FFE3     NOP
96:            	grs = temp.nAsBytes.a;
13F66  0EFB     MOVLW 0xFB
13F6A  FF8C     NOP
13F6C  F00C     NOP
13F70  F030     NOP
13F72  F005     NOP
13F74  6A06     CLRF 0x6, ACCESS
13F76  6A07     CLRF ttemp2, ACCESS
13F78  6A08     CLRF 0x8, ACCESS
13F7A  0EF7     MOVLW 0xF7
13F7E  F017     NOP
13F80  FFE3     NOP
13F82  0EF8     MOVLW 0xF8
13F86  F01B     NOP
13F88  FFE3     NOP
13F8A  0EF9     MOVLW 0xF9
13F8E  F01F     NOP
13F90  FFE3     NOP
13F92  0EFA     MOVLW 0xFA
13F96  F023     NOP
13F98  FFE3     NOP
97:            	prod.i = temp.nAsBytes.b;
13F9A  0EFC     MOVLW 0xFC
13F9C  24E1     ADDWF 0xFE1, W, ACCESS
13F9E  6ED9     MOVWF 0xFD9, ACCESS
13FA0  0EFF     MOVLW 0xFF
13FA2  20E2     ADDWFC 0xFE2, W, ACCESS
13FA4  6EDA     MOVWF 0xFDA, ACCESS
13FA6  50DF     MOVF 0xFDF, W, ACCESS
13FA8  6E0C     MOVWF 0xC, ACCESS
13FAC  F030     NOP
13FAE  F005     NOP
13FB0  6A06     CLRF 0x6, ACCESS
13FB2  6A07     CLRF ttemp2, ACCESS
13FB4  6A08     CLRF 0x8, ACCESS
13FB6  0EF3     MOVLW 0xF3
13FBA  F017     NOP
13FBC  FFE3     NOP
13FBE  0EF4     MOVLW 0xF4
13FC2  F01B     NOP
13FC4  FFE3     NOP
13FC6  0EF5     MOVLW 0xF5
13FCA  F01F     NOP
13FCC  FFE3     NOP
13FCE  0EF6     MOVLW 0xF6
13FD2  F023     NOP
13FD4  FFE3     NOP
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
13FD6  0EF0     MOVLW 0xF0
13FD8  24E1     ADDWF 0xFE1, W, ACCESS
13FDA  6ED9     MOVWF 0xFD9, ACCESS
13FDC  0EFF     MOVLW 0xFF
13FDE  20E2     ADDWFC 0xFE2, W, ACCESS
13FE0  6EDA     MOVWF 0xFDA, ACCESS
13FE2  50DF     MOVF 0xFDF, W, ACCESS
13FE4  6E0C     MOVWF 0xC, ACCESS
13FE6  0EEC     MOVLW 0xEC
13FE8  24E1     ADDWF 0xFE1, W, ACCESS
13FEA  6ED9     MOVWF 0xFD9, ACCESS
13FEC  0EFF     MOVLW 0xFF
13FEE  20E2     ADDWFC 0xFE2, W, ACCESS
13FF0  6EDA     MOVWF 0xFDA, ACCESS
13FF2  50DF     MOVF 0xFDF, W, ACCESS
13FF4  020C     MULWF 0xC, ACCESS
13FF6  0EFB     MOVLW 0xFB
13FFA  FFCF     NOP
13FFC  FFE3     NOP
13FFE  0EFC     MOVLW 0xFC
14002  FFD3     NOP
14004  FFE3     NOP
99:            	grs += temp.nAsBytes.a;
14006  50E1     MOVF 0xFE1, W, ACCESS
14008  0FF7     ADDLW 0xF7
1400A  6ED9     MOVWF 0xFD9, ACCESS
1400C  50E2     MOVF 0xFE2, W, ACCESS
1400E  6EDA     MOVWF 0xFDA, ACCESS
14010  0EFF     MOVLW 0xFF
14012  22DA     ADDWFC 0xFDA, F, ACCESS
14014  0EFB     MOVLW 0xFB
14016  50E3     MOVF 0xFE3, W, ACCESS
14018  26DE     ADDWF 0xFDE, F, ACCESS
1401A  0E00     MOVLW 0x0
1401C  22DE     ADDWFC 0xFDE, F, ACCESS
1401E  22DE     ADDWFC 0xFDE, F, ACCESS
14020  22DE     ADDWFC 0xFDE, F, ACCESS
100:           	prod.i += temp.nAsBytes.b;
14022  50E1     MOVF 0xFE1, W, ACCESS
14024  0FF3     ADDLW 0xF3
14026  6ED9     MOVWF 0xFD9, ACCESS
14028  50E2     MOVF 0xFE2, W, ACCESS
1402A  6EDA     MOVWF 0xFDA, ACCESS
1402C  0EFF     MOVLW 0xFF
1402E  22DA     ADDWFC 0xFDA, F, ACCESS
14030  0EFC     MOVLW 0xFC
14032  24E1     ADDWF 0xFE1, W, ACCESS
14034  6EE9     MOVWF 0xFE9, ACCESS
14036  0EFF     MOVLW 0xFF
14038  20E2     ADDWFC 0xFE2, W, ACCESS
1403A  6EEA     MOVWF 0xFEA, ACCESS
1403C  50EF     MOVF 0xFEF, W, ACCESS
1403E  26DE     ADDWF 0xFDE, F, ACCESS
14040  0E00     MOVLW 0x0
14042  22DE     ADDWFC 0xFDE, F, ACCESS
14044  22DE     ADDWFC 0xFDE, F, ACCESS
14046  22DE     ADDWFC 0xFDE, F, ACCESS
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
14048  0EF1     MOVLW 0xF1
1404A  24E1     ADDWF 0xFE1, W, ACCESS
1404C  6ED9     MOVWF 0xFD9, ACCESS
1404E  0EFF     MOVLW 0xFF
14050  20E2     ADDWFC 0xFE2, W, ACCESS
14052  6EDA     MOVWF 0xFDA, ACCESS
14054  50DF     MOVF 0xFDF, W, ACCESS
14056  6E0C     MOVWF 0xC, ACCESS
14058  0EEB     MOVLW 0xEB
1405A  50E3     MOVF 0xFE3, W, ACCESS
1405C  020C     MULWF 0xC, ACCESS
1405E  0EFB     MOVLW 0xFB
14062  FFCF     NOP
14064  FFE3     NOP
14066  0EFC     MOVLW 0xFC
1406A  FFD3     NOP
1406C  FFE3     NOP
102:           	grs += temp.nAsBytes.a;
1406E  50E1     MOVF 0xFE1, W, ACCESS
14070  0FF7     ADDLW 0xF7
14072  6ED9     MOVWF 0xFD9, ACCESS
14074  50E2     MOVF 0xFE2, W, ACCESS
14076  6EDA     MOVWF 0xFDA, ACCESS
14078  0EFF     MOVLW 0xFF
1407A  22DA     ADDWFC 0xFDA, F, ACCESS
1407C  0EFB     MOVLW 0xFB
1407E  50E3     MOVF 0xFE3, W, ACCESS
14080  26DE     ADDWF 0xFDE, F, ACCESS
14082  0E00     MOVLW 0x0
14084  22DE     ADDWFC 0xFDE, F, ACCESS
14086  22DE     ADDWFC 0xFDE, F, ACCESS
14088  22DE     ADDWFC 0xFDE, F, ACCESS
103:           	prod.i += temp.nAsBytes.b;
1408A  50E1     MOVF 0xFE1, W, ACCESS
1408C  0FF3     ADDLW 0xF3
1408E  6ED9     MOVWF 0xFD9, ACCESS
14090  50E2     MOVF 0xFE2, W, ACCESS
14092  6EDA     MOVWF 0xFDA, ACCESS
14094  0EFF     MOVLW 0xFF
14096  22DA     ADDWFC 0xFDA, F, ACCESS
14098  0EFC     MOVLW 0xFC
1409A  24E1     ADDWF 0xFE1, W, ACCESS
1409C  6EE9     MOVWF 0xFE9, ACCESS
1409E  0EFF     MOVLW 0xFF
140A0  20E2     ADDWFC 0xFE2, W, ACCESS
140A2  6EEA     MOVWF 0xFEA, ACCESS
140A4  50EF     MOVF 0xFEF, W, ACCESS
140A6  26DE     ADDWF 0xFDE, F, ACCESS
140A8  0E00     MOVLW 0x0
140AA  22DE     ADDWFC 0xFDE, F, ACCESS
140AC  22DE     ADDWFC 0xFDE, F, ACCESS
140AE  22DE     ADDWFC 0xFDE, F, ACCESS
104:           	grs <<= 8;
140B0  50E1     MOVF 0xFE1, W, ACCESS
140B2  0FF7     ADDLW 0xF7
140B4  6ED9     MOVWF 0xFD9, ACCESS
140B6  50E2     MOVF 0xFE2, W, ACCESS
140B8  6EDA     MOVWF 0xFDA, ACCESS
140BA  0EFF     MOVLW 0xFF
140BC  22DA     ADDWFC 0xFDA, F, ACCESS
140BE  0E08     MOVLW 0x8
140C0  90D8     BCF 0xFD8, 0, ACCESS
140C2  36DE     RLCF 0xFDE, F, ACCESS
140C4  36DE     RLCF 0xFDE, F, ACCESS
140C6  36DE     RLCF 0xFDE, F, ACCESS
140C8  36DD     RLCF 0xFDD, F, ACCESS
140CA  52DD     MOVF 0xFDD, F, ACCESS
140CC  52DD     MOVF 0xFDD, F, ACCESS
140CE  2EE8     DECFSZ 0xFE8, F, ACCESS
140D0  D7F7     BRA 0x40C0
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
140D2  0EF0     MOVLW 0xF0
140D4  24E1     ADDWF 0xFE1, W, ACCESS
140D6  6ED9     MOVWF 0xFD9, ACCESS
140D8  0EFF     MOVLW 0xFF
140DA  20E2     ADDWFC 0xFE2, W, ACCESS
140DC  6EDA     MOVWF 0xFDA, ACCESS
140DE  50DF     MOVF 0xFDF, W, ACCESS
140E0  6E0C     MOVWF 0xC, ACCESS
140E2  0EEB     MOVLW 0xEB
140E4  50E3     MOVF 0xFE3, W, ACCESS
140E6  020C     MULWF 0xC, ACCESS
140E8  0EFB     MOVLW 0xFB
140EC  FFCF     NOP
140EE  FFE3     NOP
140F0  0EFC     MOVLW 0xFC
140F4  FFD3     NOP
140F6  FFE3     NOP
106:           	grs += (unsigned long)temp.n;
140F8  0EFB     MOVLW 0xFB
140FC  FF8C     NOP
140FE  F00B     NOP
14100  0EFC     MOVLW 0xFC
14104  FF8C     NOP
14106  F00C     NOP
14108  50E1     MOVF 0xFE1, W, ACCESS
1410A  0FF7     ADDLW 0xF7
1410C  6ED9     MOVWF 0xFD9, ACCESS
1410E  50E2     MOVF 0xFE2, W, ACCESS
14110  6EDA     MOVWF 0xFDA, ACCESS
14112  0EFF     MOVLW 0xFF
14114  22DA     ADDWFC 0xFDA, F, ACCESS
14116  500B     MOVF wtemp5, W, ACCESS
14118  26DE     ADDWF 0xFDE, F, ACCESS
1411A  500C     MOVF 0xC, W, ACCESS
1411C  22DE     ADDWFC 0xFDE, F, ACCESS
1411E  0E00     MOVLW 0x0
14120  22DE     ADDWFC 0xFDE, F, ACCESS
14122  22DE     ADDWFC 0xFDE, F, ACCESS
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
14124  0EEF     MOVLW 0xEF
14128  FF8C     NOP
1412A  F00C     NOP
1412C  0EEC     MOVLW 0xEC
1412E  24E1     ADDWF 0xFE1, W, ACCESS
14130  6ED9     MOVWF 0xFD9, ACCESS
14132  0EFF     MOVLW 0xFF
14134  20E2     ADDWFC 0xFE2, W, ACCESS
14136  6EDA     MOVWF 0xFDA, ACCESS
14138  50DF     MOVF 0xFDF, W, ACCESS
1413A  020C     MULWF 0xC, ACCESS
1413C  0EFB     MOVLW 0xFB
14140  FFCF     NOP
14142  FFE3     NOP
14144  0EFC     MOVLW 0xFC
14148  FFD3     NOP
1414A  FFE3     NOP
108:           	grs += (unsigned long)temp.n;
1414C  0EFB     MOVLW 0xFB
14150  FF8C     NOP
14152  F00B     NOP
14154  0EFC     MOVLW 0xFC
14158  FF8C     NOP
1415A  F00C     NOP
1415C  50E1     MOVF 0xFE1, W, ACCESS
1415E  0FF7     ADDLW 0xF7
14160  6ED9     MOVWF 0xFD9, ACCESS
14162  50E2     MOVF 0xFE2, W, ACCESS
14164  6EDA     MOVWF 0xFDA, ACCESS
14166  0EFF     MOVLW 0xFF
14168  22DA     ADDWFC 0xFDA, F, ACCESS
1416A  500B     MOVF wtemp5, W, ACCESS
1416C  26DE     ADDWF 0xFDE, F, ACCESS
1416E  500C     MOVF 0xC, W, ACCESS
14170  22DE     ADDWFC 0xFDE, F, ACCESS
14172  0E00     MOVLW 0x0
14174  22DE     ADDWFC 0xFDE, F, ACCESS
14176  22DE     ADDWFC 0xFDE, F, ACCESS
109:           	grs <<= 8;
14178  50E1     MOVF 0xFE1, W, ACCESS
1417A  0FF7     ADDLW 0xF7
1417C  6ED9     MOVWF 0xFD9, ACCESS
1417E  50E2     MOVF 0xFE2, W, ACCESS
14180  6EDA     MOVWF 0xFDA, ACCESS
14182  0EFF     MOVLW 0xFF
14184  22DA     ADDWFC 0xFDA, F, ACCESS
14186  0E08     MOVLW 0x8
14188  90D8     BCF 0xFD8, 0, ACCESS
1418A  36DE     RLCF 0xFDE, F, ACCESS
1418C  36DE     RLCF 0xFDE, F, ACCESS
1418E  36DE     RLCF 0xFDE, F, ACCESS
14190  36DD     RLCF 0xFDD, F, ACCESS
14192  52DD     MOVF 0xFDD, F, ACCESS
14194  52DD     MOVF 0xFDD, F, ACCESS
14196  2EE8     DECFSZ 0xFE8, F, ACCESS
14198  D7F7     BRA 0x4188
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
1419A  0EEF     MOVLW 0xEF
1419E  FF8C     NOP
141A0  F00C     NOP
141A2  0EEB     MOVLW 0xEB
141A4  50E3     MOVF 0xFE3, W, ACCESS
141A6  020C     MULWF 0xC, ACCESS
141A8  0EFB     MOVLW 0xFB
141AC  FFCF     NOP
141AE  FFE3     NOP
141B0  0EFC     MOVLW 0xFC
141B4  FFD3     NOP
141B6  FFE3     NOP
111:           	grs += (unsigned long)temp.n;
141B8  0EFB     MOVLW 0xFB
141BC  FF8C     NOP
141BE  F00B     NOP
141C0  0EFC     MOVLW 0xFC
141C4  FF8C     NOP
141C6  F00C     NOP
141C8  50E1     MOVF 0xFE1, W, ACCESS
141CA  0FF7     ADDLW 0xF7
141CC  6ED9     MOVWF 0xFD9, ACCESS
141CE  50E2     MOVF 0xFE2, W, ACCESS
141D0  6EDA     MOVWF 0xFDA, ACCESS
141D2  0EFF     MOVLW 0xFF
141D4  22DA     ADDWFC 0xFDA, F, ACCESS
141D6  500B     MOVF wtemp5, W, ACCESS
141D8  26DE     ADDWF 0xFDE, F, ACCESS
141DA  500C     MOVF 0xC, W, ACCESS
141DC  22DE     ADDWFC 0xFDE, F, ACCESS
141DE  0E00     MOVLW 0x0
141E0  22DE     ADDWFC 0xFDE, F, ACCESS
141E2  22DE     ADDWFC 0xFDE, F, ACCESS
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
141E4  0EF0     MOVLW 0xF0
141E6  24E1     ADDWF 0xFE1, W, ACCESS
141E8  6ED9     MOVWF 0xFD9, ACCESS
141EA  0EFF     MOVLW 0xFF
141EC  20E2     ADDWFC 0xFE2, W, ACCESS
141EE  6EDA     MOVWF 0xFDA, ACCESS
141F0  50DF     MOVF 0xFDF, W, ACCESS
141F2  6E0C     MOVWF 0xC, ACCESS
141F4  0EED     MOVLW 0xED
141F6  24E1     ADDWF 0xFE1, W, ACCESS
141F8  6ED9     MOVWF 0xFD9, ACCESS
141FA  0EFF     MOVLW 0xFF
141FC  20E2     ADDWFC 0xFE2, W, ACCESS
141FE  6EDA     MOVWF 0xFDA, ACCESS
14200  50DF     MOVF 0xFDF, W, ACCESS
14202  020C     MULWF 0xC, ACCESS
14204  0EFB     MOVLW 0xFB
14208  FFCF     NOP
1420A  FFE3     NOP
1420C  0EFC     MOVLW 0xFC
14210  FFD3     NOP
14212  FFE3     NOP
113:           	prod.i += (unsigned long)temp.n;
14214  0EFB     MOVLW 0xFB
14218  FF8C     NOP
1421A  F00B     NOP
1421C  0EFC     MOVLW 0xFC
14220  FF8C     NOP
14222  F00C     NOP
14224  50E1     MOVF 0xFE1, W, ACCESS
14226  0FF3     ADDLW 0xF3
14228  6ED9     MOVWF 0xFD9, ACCESS
1422A  50E2     MOVF 0xFE2, W, ACCESS
1422C  6EDA     MOVWF 0xFDA, ACCESS
1422E  0EFF     MOVLW 0xFF
14230  22DA     ADDWFC 0xFDA, F, ACCESS
14232  500B     MOVF wtemp5, W, ACCESS
14234  26DE     ADDWF 0xFDE, F, ACCESS
14236  500C     MOVF 0xC, W, ACCESS
14238  22DE     ADDWFC 0xFDE, F, ACCESS
1423A  0E00     MOVLW 0x0
1423C  22DE     ADDWFC 0xFDE, F, ACCESS
1423E  22DE     ADDWFC 0xFDE, F, ACCESS
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
14240  0EF1     MOVLW 0xF1
14242  24E1     ADDWF 0xFE1, W, ACCESS
14244  6ED9     MOVWF 0xFD9, ACCESS
14246  0EFF     MOVLW 0xFF
14248  20E2     ADDWFC 0xFE2, W, ACCESS
1424A  6EDA     MOVWF 0xFDA, ACCESS
1424C  50DF     MOVF 0xFDF, W, ACCESS
1424E  6E0C     MOVWF 0xC, ACCESS
14250  0EEC     MOVLW 0xEC
14252  24E1     ADDWF 0xFE1, W, ACCESS
14254  6ED9     MOVWF 0xFD9, ACCESS
14256  0EFF     MOVLW 0xFF
14258  20E2     ADDWFC 0xFE2, W, ACCESS
1425A  6EDA     MOVWF 0xFDA, ACCESS
1425C  50DF     MOVF 0xFDF, W, ACCESS
1425E  020C     MULWF 0xC, ACCESS
14260  0EFB     MOVLW 0xFB
14264  FFCF     NOP
14266  FFE3     NOP
14268  0EFC     MOVLW 0xFC
1426C  FFD3     NOP
1426E  FFE3     NOP
115:           	prod.i += (unsigned long)temp.n;
14270  0EFB     MOVLW 0xFB
14274  FF8C     NOP
14276  F00B     NOP
14278  0EFC     MOVLW 0xFC
1427C  FF8C     NOP
1427E  F00C     NOP
14280  50E1     MOVF 0xFE1, W, ACCESS
14282  0FF3     ADDLW 0xF3
14284  6ED9     MOVWF 0xFD9, ACCESS
14286  50E2     MOVF 0xFE2, W, ACCESS
14288  6EDA     MOVWF 0xFDA, ACCESS
1428A  0EFF     MOVLW 0xFF
1428C  22DA     ADDWFC 0xFDA, F, ACCESS
1428E  500B     MOVF wtemp5, W, ACCESS
14290  26DE     ADDWF 0xFDE, F, ACCESS
14292  500C     MOVF 0xC, W, ACCESS
14294  22DE     ADDWFC 0xFDE, F, ACCESS
14296  0E00     MOVLW 0x0
14298  22DE     ADDWFC 0xFDE, F, ACCESS
1429A  22DE     ADDWFC 0xFDE, F, ACCESS
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
1429C  0EF1     MOVLW 0xF1
1429E  24E1     ADDWF 0xFE1, W, ACCESS
142A0  6ED9     MOVWF 0xFD9, ACCESS
142A2  0EFF     MOVLW 0xFF
142A4  20E2     ADDWFC 0xFE2, W, ACCESS
142A6  6EDA     MOVWF 0xFDA, ACCESS
142A8  50DF     MOVF 0xFDF, W, ACCESS
142AA  6E0C     MOVWF 0xC, ACCESS
142AC  0EED     MOVLW 0xED
142AE  24E1     ADDWF 0xFE1, W, ACCESS
142B0  6ED9     MOVWF 0xFD9, ACCESS
142B2  0EFF     MOVLW 0xFF
142B4  20E2     ADDWFC 0xFE2, W, ACCESS
142B6  6EDA     MOVWF 0xFDA, ACCESS
142B8  50DF     MOVF 0xFDF, W, ACCESS
142BA  020C     MULWF 0xC, ACCESS
142BC  0EFB     MOVLW 0xFB
142C0  FFCF     NOP
142C2  FFE3     NOP
142C4  0EFC     MOVLW 0xFC
142C8  FFD3     NOP
142CA  FFE3     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
142CC  0EFB     MOVLW 0xFB
142D0  FF8C     NOP
142D2  F00B     NOP
142D4  0EFC     MOVLW 0xFC
142D8  FF8C     NOP
142DA  F00C     NOP
142DC  500B     MOVF wtemp5, W, ACCESS
142DE  6E05     MOVWF ltemp1, ACCESS
142E0  500C     MOVF 0xC, W, ACCESS
142E2  6E06     MOVWF 0x6, ACCESS
142E4  6A07     CLRF ttemp2, ACCESS
142E6  6A08     CLRF 0x8, ACCESS
142EA  F01C     NOP
142EC  F008     NOP
142F0  F018     NOP
142F2  F007     NOP
142F6  F014     NOP
142F8  F006     NOP
142FA  6A05     CLRF ltemp1, ACCESS
142FC  50E1     MOVF 0xFE1, W, ACCESS
142FE  0FF3     ADDLW 0xF3
14300  6ED9     MOVWF 0xFD9, ACCESS
14302  50E2     MOVF 0xFE2, W, ACCESS
14304  6EDA     MOVWF 0xFDA, ACCESS
14306  0EFF     MOVLW 0xFF
14308  22DA     ADDWFC 0xFDA, F, ACCESS
1430A  5005     MOVF ltemp1, W, ACCESS
1430C  26DE     ADDWF 0xFDE, F, ACCESS
1430E  5006     MOVF 0x6, W, ACCESS
14310  22DE     ADDWFC 0xFDE, F, ACCESS
14312  5007     MOVF ttemp2, W, ACCESS
14314  22DE     ADDWFC 0xFDE, F, ACCESS
14316  5008     MOVF 0x8, W, ACCESS
14318  22DE     ADDWFC 0xFDE, F, ACCESS
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
1431A  50E1     MOVF 0xFE1, W, ACCESS
1431C  0FF3     ADDLW 0xF3
1431E  6ED9     MOVWF 0xFD9, ACCESS
14320  50E2     MOVF 0xFE2, W, ACCESS
14322  6EDA     MOVWF 0xFDA, ACCESS
14324  0EFF     MOVLW 0xFF
14326  22DA     ADDWFC 0xFDA, F, ACCESS
14328  0EFA     MOVLW 0xFA
1432A  24E1     ADDWF 0xFE1, W, ACCESS
1432C  6EE9     MOVWF 0xFE9, ACCESS
1432E  0EFF     MOVLW 0xFF
14330  20E2     ADDWFC 0xFE2, W, ACCESS
14332  6EEA     MOVWF 0xFEA, ACCESS
14334  50EF     MOVF 0xFEF, W, ACCESS
14336  26DE     ADDWF 0xFDE, F, ACCESS
14338  0E00     MOVLW 0x0
1433A  22DE     ADDWFC 0xFDE, F, ACCESS
1433C  22DE     ADDWFC 0xFDE, F, ACCESS
1433E  22DE     ADDWFC 0xFDE, F, ACCESS
146:           	grs <<= 8;
14340  50E1     MOVF 0xFE1, W, ACCESS
14342  0FF7     ADDLW 0xF7
14344  6ED9     MOVWF 0xFD9, ACCESS
14346  50E2     MOVF 0xFE2, W, ACCESS
14348  6EDA     MOVWF 0xFDA, ACCESS
1434A  0EFF     MOVLW 0xFF
1434C  22DA     ADDWFC 0xFDA, F, ACCESS
1434E  0E08     MOVLW 0x8
14350  90D8     BCF 0xFD8, 0, ACCESS
14352  36DE     RLCF 0xFDE, F, ACCESS
14354  36DE     RLCF 0xFDE, F, ACCESS
14356  36DE     RLCF 0xFDE, F, ACCESS
14358  36DD     RLCF 0xFDD, F, ACCESS
1435A  52DD     MOVF 0xFDD, F, ACCESS
1435C  52DD     MOVF 0xFDD, F, ACCESS
1435E  2EE8     DECFSZ 0xFE8, F, ACCESS
14360  D7F7     BRA 0x4350
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
14362  0E82     MOVLW 0x82
14364  6E0B     MOVWF wtemp5, ACCESS
14366  0EFF     MOVLW 0xFF
14368  6E0C     MOVWF 0xC, ACCESS
1436A  0EFD     MOVLW 0xFD
1436C  50E3     MOVF 0xFE3, W, ACCESS
1436E  6E09     MOVWF ltemp2, ACCESS
14370  6A0A     CLRF ttemp3, ACCESS
14372  0EFE     MOVLW 0xFE
14374  50E3     MOVF 0xFE3, W, ACCESS
14376  2609     ADDWF ltemp2, F, ACCESS
14378  0E00     MOVLW 0x0
1437A  220A     ADDWFC ttemp3, F, ACCESS
1437C  500B     MOVF wtemp5, W, ACCESS
1437E  2609     ADDWF ltemp2, F, ACCESS
14380  500C     MOVF 0xC, W, ACCESS
14382  220A     ADDWFC ttemp3, F, ACCESS
14384  0EFB     MOVLW 0xFB
14388  F027     NOP
1438A  FFE3     NOP
1438C  0EFC     MOVLW 0xFC
14390  F02B     NOP
14392  FFE3     NOP
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
14394  D021     BRA 0x43D8
143D8  0EF5     MOVLW 0xF5
143DA  AEE3     BTFSS 0xFE3, 7, ACCESS
143DC  D7DC     BRA 0x4396
153:           		prod.i <<= 1;
14396  90D8     BCF 0xFD8, 0, ACCESS
14398  0EF3     MOVLW 0xF3
1439A  36E3     RLCF 0xFE3, F, ACCESS
1439C  0EF4     MOVLW 0xF4
1439E  36E3     RLCF 0xFE3, F, ACCESS
143A0  0EF5     MOVLW 0xF5
143A2  36E3     RLCF 0xFE3, F, ACCESS
143A4  0EF6     MOVLW 0xF6
143A6  36E3     RLCF 0xFE3, F, ACCESS
154:           		if (grs & 0x80000000) {
143A8  0EFA     MOVLW 0xFA
143AA  AEE3     BTFSS 0xFE3, 7, ACCESS
143AC  D002     BRA 0x43B2
155:           			prod.i |= 0x1;
143AE  0EF3     MOVLW 0xF3
143B0  80E3     BSF 0xFE3, 0, ACCESS
156:           		}
157:           		grs <<= 1;
143B2  90D8     BCF 0xFD8, 0, ACCESS
143B4  0EF7     MOVLW 0xF7
143B6  36E3     RLCF 0xFE3, F, ACCESS
143B8  0EF8     MOVLW 0xF8
143BA  36E3     RLCF 0xFE3, F, ACCESS
143BC  0EF9     MOVLW 0xF9
143BE  36E3     RLCF 0xFE3, F, ACCESS
143C0  0EFA     MOVLW 0xFA
143C2  36E3     RLCF 0xFE3, F, ACCESS
158:           		--temp.i;
143C4  50E1     MOVF 0xFE1, W, ACCESS
143C6  0FFB     ADDLW 0xFB
143C8  6ED9     MOVWF 0xFD9, ACCESS
143CA  50E2     MOVF 0xFE2, W, ACCESS
143CC  6EDA     MOVWF 0xFDA, ACCESS
143CE  0EFF     MOVLW 0xFF
143D0  22DA     ADDWFC 0xFDA, F, ACCESS
143D2  06DE     DECF 0xFDE, F, ACCESS
143D4  0E00     MOVLW 0x0
143D6  5ADD     SUBWFB 0xFDD, F, ACCESS
159:           	}
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
143DE  0EFE     MOVLW 0xFE
143E0  6AE3     CLRF 0xFE3, ACCESS
164:           	if (grs & 0x80000000) {
143E2  0EFA     MOVLW 0xFA
143E4  AEE3     BTFSS 0xFE3, 7, ACCESS
143E6  D020     BRA 0x4428
165:           		if (grs & 0x7FFFFFFF) {
143E8  50E1     MOVF 0xFE1, W, ACCESS
143EA  0FF7     ADDLW 0xF7
143EC  6ED9     MOVWF 0xFD9, ACCESS
143EE  50E2     MOVF 0xFE2, W, ACCESS
143F0  6EDA     MOVWF 0xFDA, ACCESS
143F2  0EFF     MOVLW 0xFF
143F4  22DA     ADDWFC 0xFDA, F, ACCESS
143F6  0EFF     MOVLW 0xFF
143F8  14DE     ANDWF 0xFDE, W, ACCESS
143FA  6E09     MOVWF ltemp2, ACCESS
143FC  0EFF     MOVLW 0xFF
143FE  14DE     ANDWF 0xFDE, W, ACCESS
14400  6E0A     MOVWF ttemp3, ACCESS
14402  0EFF     MOVLW 0xFF
14404  14DE     ANDWF 0xFDE, W, ACCESS
14406  6E0B     MOVWF wtemp5, ACCESS
14408  0E7F     MOVLW 0x7F
1440A  14DE     ANDWF 0xFDE, W, ACCESS
1440C  6E0C     MOVWF 0xC, ACCESS
1440E  5009     MOVF ltemp2, W, ACCESS
14410  100A     IORWF ttemp3, W, ACCESS
14412  100B     IORWF wtemp5, W, ACCESS
14414  100C     IORWF 0xC, W, ACCESS
14416  B4D8     BTFSC 0xFD8, 2, ACCESS
14418  D004     BRA 0x4422
166:           			aexp = 1;
1441A  0EFE     MOVLW 0xFE
1441C  6AE3     CLRF 0xFE3, ACCESS
1441E  2AE3     INCF 0xFE3, F, ACCESS
167:           		}
14420  D003     BRA 0x4428
168:           		else {
169:           			if (prod.i & 1) {
14422  0EF3     MOVLW 0xF3
14424  B0E3     BTFSC 0xFE3, 0, ACCESS
14426  D7F9     BRA 0x441A
170:           				aexp = 1;
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
14428  0EFE     MOVLW 0xFE
1442A  50E3     MOVF 0xFE3, W, ACCESS
1442C  B4D8     BTFSC 0xFD8, 2, ACCESS
1442E  D036     BRA 0x449C
175:           		++prod.i;
14430  50E1     MOVF 0xFE1, W, ACCESS
14432  0FF3     ADDLW 0xF3
14434  6ED9     MOVWF 0xFD9, ACCESS
14436  50E2     MOVF 0xFE2, W, ACCESS
14438  6EDA     MOVWF 0xFDA, ACCESS
1443A  0EFF     MOVLW 0xFF
1443C  22DA     ADDWFC 0xFDA, F, ACCESS
1443E  2ADE     INCF 0xFDE, F, ACCESS
14440  0E00     MOVLW 0x0
14442  22DE     ADDWFC 0xFDE, F, ACCESS
14444  22DE     ADDWFC 0xFDE, F, ACCESS
14446  22DE     ADDWFC 0xFDE, F, ACCESS
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
14448  0EF6     MOVLW 0xF6
1444A  A0E3     BTFSS 0xFE3, 0, ACCESS
1444C  D027     BRA 0x449C
177:           			prod.i = prod.i >> 1;
1444E  0E01     MOVLW 0x1
14450  6E0C     MOVWF 0xC, ACCESS
14452  50E1     MOVF 0xFE1, W, ACCESS
14454  0FF3     ADDLW 0xF3
14456  6ED9     MOVWF 0xFD9, ACCESS
14458  50E2     MOVF 0xFE2, W, ACCESS
1445A  6EDA     MOVWF 0xFDA, ACCESS
1445C  0EFF     MOVLW 0xFF
1445E  22DA     ADDWFC 0xFDA, F, ACCESS
14460  280C     INCF 0xC, W, ACCESS
14462  52DE     MOVF 0xFDE, F, ACCESS
14464  D008     BRA 0x4476
14466  52DE     MOVF 0xFDE, F, ACCESS
14468  90D8     BCF 0xFD8, 0, ACCESS
1446A  BEDC     BTFSC 0xFDC, 7, ACCESS
1446C  80D8     BSF 0xFD8, 0, ACCESS
1446E  32DD     RRCF 0xFDD, F, ACCESS
14470  32DD     RRCF 0xFDD, F, ACCESS
14472  32DD     RRCF 0xFDD, F, ACCESS
14474  32DE     RRCF 0xFDE, F, ACCESS
14476  2EE8     DECFSZ 0xFE8, F, ACCESS
14478  D7F6     BRA 0x4466
178:           			++temp.i;
1447A  0EFB     MOVLW 0xFB
1447C  50E3     MOVF 0xFE3, W, ACCESS
1447E  0F01     ADDLW 0x1
14480  6E01     MOVWF ltemp0, ACCESS
14482  0EFB     MOVLW 0xFB
14486  F007     NOP
14488  FFE3     NOP
1448A  6A01     CLRF ltemp0, ACCESS
1448C  0EFC     MOVLW 0xFC
1448E  50E3     MOVF 0xFE3, W, ACCESS
14490  2001     ADDWFC ltemp0, W, ACCESS
14492  6E01     MOVWF ltemp0, ACCESS
14494  0EFC     MOVLW 0xFC
14498  F007     NOP
1449A  FFE3     NOP
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
1449C  0EFC     MOVLW 0xFC
1449E  BEE3     BTFSC 0xFE3, 7, ACCESS
144A0  D020     BRA 0x44E2
144A2  0EFC     MOVLW 0xFC
144A4  50E3     MOVF 0xFE3, W, ACCESS
144A6  E104     BNZ 0x44B0
144A8  0EFB     MOVLW 0xFB
144AA  28E3     INCF 0xFE3, W, ACCESS
144AC  A0D8     BTFSS 0xFD8, 0, ACCESS
144AE  D019     BRA 0x44E2
184:           		prod.i = 0x7F800000;
144B0  0E00     MOVLW 0x0
144B2  6E09     MOVWF ltemp2, ACCESS
144B4  0E00     MOVLW 0x0
144B6  6E0A     MOVWF ttemp3, ACCESS
144B8  0E80     MOVLW 0x80
144BA  6E0B     MOVWF wtemp5, ACCESS
144BC  0E7F     MOVLW 0x7F
144BE  6E0C     MOVWF 0xC, ACCESS
144C0  0EF3     MOVLW 0xF3
144C4  F027     NOP
144C6  FFE3     NOP
144C8  0EF4     MOVLW 0xF4
144CC  F02B     NOP
144CE  FFE3     NOP
144D0  0EF5     MOVLW 0xF5
144D4  F02F     NOP
144D6  FFE3     NOP
144D8  0EF6     MOVLW 0xF6
144DC  F033     NOP
144DE  FFE3     NOP
185:           	}
144E0  D044     BRA 0x456A
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
144E2  0EFC     MOVLW 0xFC
144E4  BEE3     BTFSC 0xFE3, 7, ACCESS
144E6  D007     BRA 0x44F6
144E8  0EFC     MOVLW 0xFC
144EA  50E3     MOVF 0xFE3, W, ACCESS
144EC  E10F     BNZ 0x450C
144EE  0EFB     MOVLW 0xFB
144F0  04E3     DECF 0xFE3, W, ACCESS
144F2  B0D8     BTFSC 0xFD8, 0, ACCESS
144F4  D00B     BRA 0x450C
188:           		prod.i = 0;
144F6  0EF3     MOVLW 0xF3
144F8  6AE3     CLRF 0xFE3, ACCESS
144FA  0EF4     MOVLW 0xF4
144FC  6AE3     CLRF 0xFE3, ACCESS
144FE  0EF5     MOVLW 0xF5
14500  6AE3     CLRF 0xFE3, ACCESS
14502  0EF6     MOVLW 0xF6
14504  6AE3     CLRF 0xFE3, ACCESS
189:                           // no negative 0 for now
190:                           sign=0;
14506  0EFF     MOVLW 0xFF
14508  6AE3     CLRF 0xFE3, ACCESS
191:           	}
1450A  D02F     BRA 0x456A
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
1450C  0EFB     MOVLW 0xFB
14510  FF8C     NOP
14512  F001     NOP
14514  0EFD     MOVLW 0xFD
14518  F007     NOP
1451A  FFE3     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
1451C  50E1     MOVF 0xFE1, W, ACCESS
1451E  0FF3     ADDLW 0xF3
14520  6ED9     MOVWF 0xFD9, ACCESS
14522  50E2     MOVF 0xFE2, W, ACCESS
14524  6EDA     MOVWF 0xFDA, ACCESS
14526  0EFF     MOVLW 0xFF
14528  22DA     ADDWFC 0xFDA, F, ACCESS
1452A  0EFF     MOVLW 0xFF
1452C  16DE     ANDWF 0xFDE, F, ACCESS
1452E  0EFF     MOVLW 0xFF
14530  16DE     ANDWF 0xFDE, F, ACCESS
14532  0E7F     MOVLW 0x7F
14534  16DE     ANDWF 0xFDE, F, ACCESS
14536  0E00     MOVLW 0x0
14538  16DE     ANDWF 0xFDE, F, ACCESS
196:           		if (bexp & 0x1) {
1453A  0EFD     MOVLW 0xFD
1453C  A0E3     BTFSS 0xFE3, 0, ACCESS
1453E  D008     BRA 0x4550
197:           			prod.fAsBytes.c |= 0x80;
14540  0EF5     MOVLW 0xF5
14542  24E1     ADDWF 0xFE1, W, ACCESS
14544  6ED9     MOVWF 0xFD9, ACCESS
14546  0EFF     MOVLW 0xFF
14548  20E2     ADDWFC 0xFE2, W, ACCESS
1454A  6EDA     MOVWF 0xFDA, ACCESS
1454C  0E00     MOVLW 0x0
1454E  8EDB     BSF 0xFDB, 7, ACCESS
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
14550  0EF6     MOVLW 0xF6
14552  24E1     ADDWF 0xFE1, W, ACCESS
14554  6ED9     MOVWF 0xFD9, ACCESS
14556  0EFF     MOVLW 0xFF
14558  20E2     ADDWFC 0xFE2, W, ACCESS
1455A  6EDA     MOVWF 0xFDA, ACCESS
1455C  0EFD     MOVLW 0xFD
14560  FF8C     NOP
14562  F00C     NOP
14564  90D8     BCF 0xFD8, 0, ACCESS
14566  300C     RRCF 0xC, W, ACCESS
14568  6EDF     MOVWF 0xFDF, ACCESS
200:           	}
201:           	prod.fAsBytes.d |= sign;
1456A  0EFF     MOVLW 0xFF
1456E  FF8C     NOP
14570  F00C     NOP
14572  0EF6     MOVLW 0xF6
14574  24E1     ADDWF 0xFE1, W, ACCESS
14576  6ED9     MOVWF 0xFD9, ACCESS
14578  0EFF     MOVLW 0xFF
1457A  20E2     ADDWFC 0xFE2, W, ACCESS
1457C  6EDA     MOVWF 0xFDA, ACCESS
1457E  500C     MOVF 0xC, W, ACCESS
14580  12DF     IORWF 0xFDF, F, ACCESS
202:           
203:           	return prod.f;
14582  0EF3     MOVLW 0xF3
14586  FF8C     NOP
14588  F001     NOP
1458A  0EF4     MOVLW 0xF4
1458E  FF8C     NOP
14590  F002     NOP
14592  0EF5     MOVLW 0xF5
14596  FF8C     NOP
14598  F003     NOP
1459A  0EF6     MOVLW 0xF6
1459E  FF8C     NOP
145A0  F004     NOP
204:           
205:           }
145A2  0EEB     MOVLW 0xEB
145A4  26E1     ADDWF 0xFE1, F, ACCESS
145A6  0EFF     MOVLW 0xFF
145A8  22E2     ADDWFC 0xFE2, F, ACCESS
145AA  0012     RETURN 0
206:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcdiv.c  -----------------------------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
14D68  0E0D     MOVLW 0xD
14D6A  26E1     ADDWF 0xFE1, F, ACCESS
14D6C  0E00     MOVLW 0x0
14D6E  22E2     ADDWFC 0xFE2, F, ACCESS
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
14D70  0EF2     MOVLW 0xF2
14D72  24E1     ADDWF 0xFE1, W, ACCESS
14D74  6ED9     MOVWF 0xFD9, ACCESS
14D76  0EFF     MOVLW 0xFF
14D78  20E2     ADDWFC 0xFE2, W, ACCESS
14D7A  6EDA     MOVWF 0xFDA, ACCESS
14D7C  50DF     MOVF 0xFDF, W, ACCESS
14D7E  6E0C     MOVWF 0xC, ACCESS
14D80  0E80     MOVLW 0x80
14D82  160C     ANDWF 0xC, F, ACCESS
14D84  0EFF     MOVLW 0xFF
14D88  F033     NOP
14D8A  FFE3     NOP
27:            	bexp = B_FRACTION.fAsBytes.d << 1;
14D8C  0EF2     MOVLW 0xF2
14D8E  24E1     ADDWF 0xFE1, W, ACCESS
14D90  6ED9     MOVWF 0xFD9, ACCESS
14D92  0EFF     MOVLW 0xFF
14D94  20E2     ADDWFC 0xFE2, W, ACCESS
14D96  6EDA     MOVWF 0xFDA, ACCESS
14D98  50DF     MOVF 0xFDF, W, ACCESS
14D9A  6E0C     MOVWF 0xC, ACCESS
14D9C  90D8     BCF 0xFD8, 0, ACCESS
14D9E  340C     RLCF 0xC, W, ACCESS
14DA0  6E0B     MOVWF wtemp5, ACCESS
14DA2  0EFE     MOVLW 0xFE
14DA6  F02F     NOP
14DA8  FFE3     NOP
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
14DAA  0EF1     MOVLW 0xF1
14DAC  24E1     ADDWF 0xFE1, W, ACCESS
14DAE  6ED9     MOVWF 0xFD9, ACCESS
14DB0  0EFF     MOVLW 0xFF
14DB2  20E2     ADDWFC 0xFE2, W, ACCESS
14DB4  6EDA     MOVWF 0xFDA, ACCESS
14DB6  AEDF     BTFSS 0xFDF, 7, ACCESS
14DB8  D002     BRA 0x4DBE
29:            		bexp |= 0x1;
14DBA  0EFE     MOVLW 0xFE
14DBC  80E3     BSF 0xFE3, 0, ACCESS
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
14DBE  0EFE     MOVLW 0xFE
14DC0  50E3     MOVF 0xFE3, W, ACCESS
14DC2  B4D8     BTFSC 0xFD8, 2, ACCESS
14DC4  D027     BRA 0x4E14
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
14DC6  0EFE     MOVLW 0xFE
14DC8  28E3     INCF 0xFE3, W, ACCESS
14DCA  A4D8     BTFSS 0xFD8, 2, ACCESS
14DCC  D018     BRA 0x4DFE
36:            			/* Make it inf */
37:            			b = 0;
14DCE  0E00     MOVLW 0x0
14DD0  6E09     MOVWF ltemp2, ACCESS
14DD2  0E00     MOVLW 0x0
14DD4  6E0A     MOVWF ttemp3, ACCESS
14DD6  0E00     MOVLW 0x0
14DD8  6E0B     MOVWF wtemp5, ACCESS
14DDA  0E00     MOVLW 0x0
14DDC  6E0C     MOVWF 0xC, ACCESS
14DDE  0EEF     MOVLW 0xEF
14DE2  F027     NOP
14DE4  FFE3     NOP
14DE6  0EF0     MOVLW 0xF0
14DEA  F02B     NOP
14DEC  FFE3     NOP
14DEE  0EF1     MOVLW 0xF1
14DF2  F02F     NOP
14DF4  FFE3     NOP
14DF6  0EF2     MOVLW 0xF2
14DFA  F033     NOP
14DFC  FFE3     NOP
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
14DFE  0EF1     MOVLW 0xF1
14E00  8EE3     BSF 0xFE3, 7, ACCESS
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
14E02  0EF2     MOVLW 0xF2
14E04  24E1     ADDWF 0xFE1, W, ACCESS
14E06  6ED9     MOVWF 0xFD9, ACCESS
14E08  0EFF     MOVLW 0xFF
14E0A  20E2     ADDWFC 0xFE2, W, ACCESS
14E0C  6EDA     MOVWF 0xFDA, ACCESS
14E0E  0E00     MOVLW 0x0
14E10  6EDF     MOVWF 0xFDF, ACCESS
43:            	}
14E12  D018     BRA 0x4E44
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
14E14  0E00     MOVLW 0x0
14E16  6E09     MOVWF ltemp2, ACCESS
14E18  0E00     MOVLW 0x0
14E1A  6E0A     MOVWF ttemp3, ACCESS
14E1C  0E00     MOVLW 0x0
14E1E  6E0B     MOVWF wtemp5, ACCESS
14E20  0E00     MOVLW 0x0
14E22  6E0C     MOVWF 0xC, ACCESS
14E24  0EEF     MOVLW 0xEF
14E28  F027     NOP
14E2A  FFE3     NOP
14E2C  0EF0     MOVLW 0xF0
14E30  F02B     NOP
14E32  FFE3     NOP
14E34  0EF1     MOVLW 0xF1
14E38  F02F     NOP
14E3A  FFE3     NOP
14E3C  0EF2     MOVLW 0xF2
14E40  F033     NOP
14E42  FFE3     NOP
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
14E44  0EEE     MOVLW 0xEE
14E46  24E1     ADDWF 0xFE1, W, ACCESS
14E48  6ED9     MOVWF 0xFD9, ACCESS
14E4A  0EFF     MOVLW 0xFF
14E4C  20E2     ADDWFC 0xFE2, W, ACCESS
14E4E  6EDA     MOVWF 0xFDA, ACCESS
14E50  50DF     MOVF 0xFDF, W, ACCESS
14E52  6E0C     MOVWF 0xC, ACCESS
14E54  0E80     MOVLW 0x80
14E56  160C     ANDWF 0xC, F, ACCESS
14E58  50E1     MOVF 0xFE1, W, ACCESS
14E5A  0FFF     ADDLW 0xFF
14E5C  6ED9     MOVWF 0xFD9, ACCESS
14E5E  50E2     MOVF 0xFE2, W, ACCESS
14E60  6EDA     MOVWF 0xFDA, ACCESS
14E62  0EFF     MOVLW 0xFF
14E64  22DA     ADDWFC 0xFDA, F, ACCESS
14E66  500C     MOVF 0xC, W, ACCESS
14E68  1ADF     XORWF 0xFDF, F, ACCESS
50:            	aexp = A_FRACTION.fAsBytes.d << 1;
14E6A  0EEE     MOVLW 0xEE
14E6C  24E1     ADDWF 0xFE1, W, ACCESS
14E6E  6ED9     MOVWF 0xFD9, ACCESS
14E70  0EFF     MOVLW 0xFF
14E72  20E2     ADDWFC 0xFE2, W, ACCESS
14E74  6EDA     MOVWF 0xFDA, ACCESS
14E76  50DF     MOVF 0xFDF, W, ACCESS
14E78  6E0C     MOVWF 0xC, ACCESS
14E7A  90D8     BCF 0xFD8, 0, ACCESS
14E7C  340C     RLCF 0xC, W, ACCESS
14E7E  6E0B     MOVWF wtemp5, ACCESS
14E80  0EFD     MOVLW 0xFD
14E84  F02F     NOP
14E86  FFE3     NOP
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
14E88  0EED     MOVLW 0xED
14E8A  24E1     ADDWF 0xFE1, W, ACCESS
14E8C  6ED9     MOVWF 0xFD9, ACCESS
14E8E  0EFF     MOVLW 0xFF
14E90  20E2     ADDWFC 0xFE2, W, ACCESS
14E92  6EDA     MOVWF 0xFDA, ACCESS
14E94  AEDF     BTFSS 0xFDF, 7, ACCESS
14E96  D002     BRA 0x4E9C
52:            		aexp |= 0x1;
14E98  0EFD     MOVLW 0xFD
14E9A  80E3     BSF 0xFE3, 0, ACCESS
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
14E9C  0EFD     MOVLW 0xFD
14E9E  50E3     MOVF 0xFE3, W, ACCESS
14EA0  B4D8     BTFSC 0xFD8, 2, ACCESS
14EA2  D027     BRA 0x4EF2
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
14EA4  0EFD     MOVLW 0xFD
14EA6  28E3     INCF 0xFE3, W, ACCESS
14EA8  A4D8     BTFSS 0xFD8, 2, ACCESS
14EAA  D018     BRA 0x4EDC
59:            			/* Make it inf */
60:            			a = 0;
14EAC  0E00     MOVLW 0x0
14EAE  6E09     MOVWF ltemp2, ACCESS
14EB0  0E00     MOVLW 0x0
14EB2  6E0A     MOVWF ttemp3, ACCESS
14EB4  0E00     MOVLW 0x0
14EB6  6E0B     MOVWF wtemp5, ACCESS
14EB8  0E00     MOVLW 0x0
14EBA  6E0C     MOVWF 0xC, ACCESS
14EBC  0EEB     MOVLW 0xEB
14EC0  F027     NOP
14EC2  FFE3     NOP
14EC4  0EEC     MOVLW 0xEC
14EC8  F02B     NOP
14ECA  FFE3     NOP
14ECC  0EED     MOVLW 0xED
14ED0  F02F     NOP
14ED2  FFE3     NOP
14ED4  0EEE     MOVLW 0xEE
14ED8  F033     NOP
14EDA  FFE3     NOP
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
14EDC  0EED     MOVLW 0xED
14EDE  8EE3     BSF 0xFE3, 7, ACCESS
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
14EE0  0EEE     MOVLW 0xEE
14EE2  24E1     ADDWF 0xFE1, W, ACCESS
14EE4  6ED9     MOVWF 0xFD9, ACCESS
14EE6  0EFF     MOVLW 0xFF
14EE8  20E2     ADDWFC 0xFE2, W, ACCESS
14EEA  6EDA     MOVWF 0xFDA, ACCESS
14EEC  0E00     MOVLW 0x0
14EEE  6EDF     MOVWF 0xFDF, ACCESS
66:            	}
14EF0  D018     BRA 0x4F22
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
14EF2  0E00     MOVLW 0x0
14EF4  6E09     MOVWF ltemp2, ACCESS
14EF6  0E00     MOVLW 0x0
14EF8  6E0A     MOVWF ttemp3, ACCESS
14EFA  0E00     MOVLW 0x0
14EFC  6E0B     MOVWF wtemp5, ACCESS
14EFE  0E00     MOVLW 0x0
14F00  6E0C     MOVWF 0xC, ACCESS
14F02  0EEB     MOVLW 0xEB
14F06  F027     NOP
14F08  FFE3     NOP
14F0A  0EEC     MOVLW 0xEC
14F0E  F02B     NOP
14F10  FFE3     NOP
14F12  0EED     MOVLW 0xED
14F16  F02F     NOP
14F18  FFE3     NOP
14F1A  0EEE     MOVLW 0xEE
14F1E  F033     NOP
14F20  FFE3     NOP
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
14F22  0EEB     MOVLW 0xEB
14F24  50E3     MOVF 0xFE3, W, ACCESS
14F26  E139     BNZ 0x4F9A
14F28  0EEC     MOVLW 0xEC
14F2A  50E3     MOVF 0xFE3, W, ACCESS
14F2C  E136     BNZ 0x4F9A
14F2E  0EED     MOVLW 0xED
14F30  50E3     MOVF 0xFE3, W, ACCESS
14F32  E133     BNZ 0x4F9A
14F34  0EEE     MOVLW 0xEE
14F36  50E3     MOVF 0xFE3, W, ACCESS
14F38  A4D8     BTFSS 0xFD8, 2, ACCESS
14F3A  D02F     BRA 0x4F9A
76:            		B_FRACTION.i = 0;
14F3C  0EEF     MOVLW 0xEF
14F3E  6AE3     CLRF 0xFE3, ACCESS
14F40  0EF0     MOVLW 0xF0
14F42  6AE3     CLRF 0xFE3, ACCESS
14F44  0EF1     MOVLW 0xF1
14F46  6AE3     CLRF 0xFE3, ACCESS
14F48  0EF2     MOVLW 0xF2
14F4A  6AE3     CLRF 0xFE3, ACCESS
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
14F4C  0EF1     MOVLW 0xF1
14F4E  24E1     ADDWF 0xFE1, W, ACCESS
14F50  6ED9     MOVWF 0xFD9, ACCESS
14F52  0EFF     MOVLW 0xFF
14F54  20E2     ADDWFC 0xFE2, W, ACCESS
14F56  6EDA     MOVWF 0xFDA, ACCESS
14F58  0E80     MOVLW 0x80
14F5A  12DE     IORWF 0xFDE, F, ACCESS
14F5C  0E7F     MOVLW 0x7F
14F5E  12DD     IORWF 0xFDD, F, ACCESS
78:            		B_FRACTION.fAsBytes.d |= sign;
14F60  0EFF     MOVLW 0xFF
14F64  FF8C     NOP
14F66  F00C     NOP
14F68  0EF2     MOVLW 0xF2
14F6A  24E1     ADDWF 0xFE1, W, ACCESS
14F6C  6ED9     MOVWF 0xFD9, ACCESS
14F6E  0EFF     MOVLW 0xFF
14F70  20E2     ADDWFC 0xFE2, W, ACCESS
14F72  6EDA     MOVWF 0xFDA, ACCESS
14F74  500C     MOVF 0xC, W, ACCESS
14F76  12DF     IORWF 0xFDF, F, ACCESS
79:            		return b;
14F78  0EEF     MOVLW 0xEF
14F7C  FF8C     NOP
14F7E  F001     NOP
14F80  0EF0     MOVLW 0xF0
14F84  FF8C     NOP
14F86  F002     NOP
14F88  0EF1     MOVLW 0xF1
14F8C  FF8C     NOP
14F8E  F003     NOP
14F90  0EF2     MOVLW 0xF2
14F94  FF8C     NOP
14F96  F004     NOP
14F98  D19F     BRA 0x52D8
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
14F9A  0EFE     MOVLW 0xFE
14F9C  50E3     MOVF 0xFE3, W, ACCESS
14F9E  A4D8     BTFSS 0xFD8, 2, ACCESS
14FA0  D009     BRA 0x4FB4
84:            		B_FRACTION.i = 0;
85:            		return b;
14FA2  0E00     MOVLW 0x0
14FA4  6E01     MOVWF ltemp0, ACCESS
14FA6  0E00     MOVLW 0x0
14FA8  6E02     MOVWF ttemp5, ACCESS
14FAA  0E00     MOVLW 0x0
14FAC  6E03     MOVWF wtemp1, ACCESS
14FAE  0E00     MOVLW 0x0
14FB0  6E04     MOVWF ttemp1, ACCESS
14FB2  D192     BRA 0x52D8
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
14FB4  0EFE     MOVLW 0xFE
14FB6  50E3     MOVF 0xFE3, W, ACCESS
14FB8  6E0B     MOVWF wtemp5, ACCESS
14FBA  6A0C     CLRF 0xC, ACCESS
14FBC  0EFD     MOVLW 0xFD
14FBE  50E3     MOVF 0xFE3, W, ACCESS
14FC0  5E0B     SUBWF wtemp5, F, ACCESS
14FC2  0E00     MOVLW 0x0
14FC4  5A0C     SUBWFB 0xC, F, ACCESS
14FC6  0E7F     MOVLW 0x7F
14FC8  260B     ADDWF wtemp5, F, ACCESS
14FCA  0E00     MOVLW 0x0
14FCC  220C     ADDWFC 0xC, F, ACCESS
14FCE  0EFB     MOVLW 0xFB
14FD2  F02F     NOP
14FD4  FFE3     NOP
14FD6  0EFC     MOVLW 0xFC
14FDA  F033     NOP
14FDC  FFE3     NOP
90:            
91:            	/* Divide loop */
92:            	rem = B_FRACTION.i;
14FDE  0EEF     MOVLW 0xEF
14FE2  FF8C     NOP
14FE4  F009     NOP
14FE6  0EF0     MOVLW 0xF0
14FEA  FF8C     NOP
14FEC  F00A     NOP
14FEE  0EF1     MOVLW 0xF1
14FF2  FF8C     NOP
14FF4  F00B     NOP
14FF6  0EF2     MOVLW 0xF2
14FFA  FF8C     NOP
14FFC  F00C     NOP
14FFE  0EF7     MOVLW 0xF7
15002  F027     NOP
15004  FFE3     NOP
15006  0EF8     MOVLW 0xF8
1500A  F02B     NOP
1500C  FFE3     NOP
1500E  0EF9     MOVLW 0xF9
15012  F02F     NOP
15014  FFE3     NOP
15016  0EFA     MOVLW 0xFA
1501A  F033     NOP
1501C  FFE3     NOP
93:            	B_FRACTION.i = 0;
1501E  0EEF     MOVLW 0xEF
15020  6AE3     CLRF 0xFE3, ACCESS
15022  0EF0     MOVLW 0xF0
15024  6AE3     CLRF 0xFE3, ACCESS
15026  0EF1     MOVLW 0xF1
15028  6AE3     CLRF 0xFE3, ACCESS
1502A  0EF2     MOVLW 0xF2
1502C  6AE3     CLRF 0xFE3, ACCESS
94:            	grs = 0;
1502E  0EF3     MOVLW 0xF3
15030  6AE3     CLRF 0xFE3, ACCESS
15032  0EF4     MOVLW 0xF4
15034  6AE3     CLRF 0xFE3, ACCESS
15036  0EF5     MOVLW 0xF5
15038  6AE3     CLRF 0xFE3, ACCESS
1503A  0EF6     MOVLW 0xF6
1503C  6AE3     CLRF 0xFE3, ACCESS
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
1503E  0EFD     MOVLW 0xFD
15040  6AE3     CLRF 0xFE3, ACCESS
97:            	while (aexp < 26) {
15042  D050     BRA 0x50E4
150E4  0EFD     MOVLW 0xFD
150E8  FF8C     NOP
150EA  F001     NOP
150EC  0E19     MOVLW 0x19
150EE  6401     CPFSGT ltemp0, ACCESS
150F0  D7A9     BRA 0x5044
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
15044  0EFD     MOVLW 0xFD
15046  50E3     MOVF 0xFE3, W, ACCESS
15048  B4D8     BTFSC 0xFD8, 2, ACCESS
1504A  D020     BRA 0x508C
101:           			rem <<= 1;
1504C  90D8     BCF 0xFD8, 0, ACCESS
1504E  0EF7     MOVLW 0xF7
15050  36E3     RLCF 0xFE3, F, ACCESS
15052  0EF8     MOVLW 0xF8
15054  36E3     RLCF 0xFE3, F, ACCESS
15056  0EF9     MOVLW 0xF9
15058  36E3     RLCF 0xFE3, F, ACCESS
1505A  0EFA     MOVLW 0xFA
1505C  36E3     RLCF 0xFE3, F, ACCESS
102:           			B_FRACTION.i <<= 1;
1505E  90D8     BCF 0xFD8, 0, ACCESS
15060  0EEF     MOVLW 0xEF
15062  36E3     RLCF 0xFE3, F, ACCESS
15064  0EF0     MOVLW 0xF0
15066  36E3     RLCF 0xFE3, F, ACCESS
15068  0EF1     MOVLW 0xF1
1506A  36E3     RLCF 0xFE3, F, ACCESS
1506C  0EF2     MOVLW 0xF2
1506E  36E3     RLCF 0xFE3, F, ACCESS
103:           			if (grs & 0x80000000) {
15070  0EF6     MOVLW 0xF6
15072  AEE3     BTFSS 0xFE3, 7, ACCESS
15074  D002     BRA 0x507A
104:           				B_FRACTION.i |= 0x1;
15076  0EEF     MOVLW 0xEF
15078  80E3     BSF 0xFE3, 0, ACCESS
105:           			}
106:           			grs <<= 1;
1507A  90D8     BCF 0xFD8, 0, ACCESS
1507C  0EF3     MOVLW 0xF3
1507E  36E3     RLCF 0xFE3, F, ACCESS
15080  0EF4     MOVLW 0xF4
15082  36E3     RLCF 0xFE3, F, ACCESS
15084  0EF5     MOVLW 0xF5
15086  36E3     RLCF 0xFE3, F, ACCESS
15088  0EF6     MOVLW 0xF6
1508A  36E3     RLCF 0xFE3, F, ACCESS
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
1508C  50E1     MOVF 0xFE1, W, ACCESS
1508E  0FF7     ADDLW 0xF7
15090  6ED9     MOVWF 0xFD9, ACCESS
15092  50E2     MOVF 0xFE2, W, ACCESS
15094  6EDA     MOVWF 0xFDA, ACCESS
15096  0EFF     MOVLW 0xFF
15098  22DA     ADDWFC 0xFDA, F, ACCESS
1509A  0EEB     MOVLW 0xEB
1509C  50E3     MOVF 0xFE3, W, ACCESS
1509E  5CDE     SUBWF 0xFDE, W, ACCESS
150A0  0EEC     MOVLW 0xEC
150A2  50E3     MOVF 0xFE3, W, ACCESS
150A4  58DE     SUBWFB 0xFDE, W, ACCESS
150A6  0EED     MOVLW 0xED
150A8  50E3     MOVF 0xFE3, W, ACCESS
150AA  58DE     SUBWFB 0xFDE, W, ACCESS
150AC  0EEE     MOVLW 0xEE
150AE  50E3     MOVF 0xFE3, W, ACCESS
150B0  58DE     SUBWFB 0xFDE, W, ACCESS
150B2  A0D8     BTFSS 0xFD8, 0, ACCESS
150B4  D015     BRA 0x50E0
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
150B6  0EF6     MOVLW 0xF6
150B8  8CE3     BSF 0xFE3, 6, ACCESS
116:           			rem -= A_FRACTION.i;
150BA  50E1     MOVF 0xFE1, W, ACCESS
150BC  0FF7     ADDLW 0xF7
150BE  6ED9     MOVWF 0xFD9, ACCESS
150C0  50E2     MOVF 0xFE2, W, ACCESS
150C2  6EDA     MOVWF 0xFDA, ACCESS
150C4  0EFF     MOVLW 0xFF
150C6  22DA     ADDWFC 0xFDA, F, ACCESS
150C8  0EEB     MOVLW 0xEB
150CA  50E3     MOVF 0xFE3, W, ACCESS
150CC  5EDE     SUBWF 0xFDE, F, ACCESS
150CE  0EEC     MOVLW 0xEC
150D0  50E3     MOVF 0xFE3, W, ACCESS
150D2  5ADE     SUBWFB 0xFDE, F, ACCESS
150D4  0EED     MOVLW 0xED
150D6  50E3     MOVF 0xFE3, W, ACCESS
150D8  5ADE     SUBWFB 0xFDE, F, ACCESS
150DA  0EEE     MOVLW 0xEE
150DC  50E3     MOVF 0xFE3, W, ACCESS
150DE  5ADE     SUBWFB 0xFDE, F, ACCESS
117:           		}
118:           		++aexp;
150E0  0EFD     MOVLW 0xFD
150E2  2AE3     INCF 0xFE3, F, ACCESS
119:           	}
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
150F2  0EF7     MOVLW 0xF7
150F4  50E3     MOVF 0xFE3, W, ACCESS
150F6  E10A     BNZ 0x510C
150F8  0EF8     MOVLW 0xF8
150FA  50E3     MOVF 0xFE3, W, ACCESS
150FC  E107     BNZ 0x510C
150FE  0EF9     MOVLW 0xF9
15100  50E3     MOVF 0xFE3, W, ACCESS
15102  E104     BNZ 0x510C
15104  0EFA     MOVLW 0xFA
15106  50E3     MOVF 0xFE3, W, ACCESS
15108  B4D8     BTFSC 0xFD8, 2, ACCESS
1510A  D024     BRA 0x5154
123:           		grs |= 1;
1510C  0EF3     MOVLW 0xF3
1510E  80E3     BSF 0xFE3, 0, ACCESS
15110  D021     BRA 0x5154
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
15154  0EF1     MOVLW 0xF1
15156  AEE3     BTFSS 0xFE3, 7, ACCESS
15158  D7DC     BRA 0x5112
128:           		B_FRACTION.i <<= 1;
15112  90D8     BCF 0xFD8, 0, ACCESS
15114  0EEF     MOVLW 0xEF
15116  36E3     RLCF 0xFE3, F, ACCESS
15118  0EF0     MOVLW 0xF0
1511A  36E3     RLCF 0xFE3, F, ACCESS
1511C  0EF1     MOVLW 0xF1
1511E  36E3     RLCF 0xFE3, F, ACCESS
15120  0EF2     MOVLW 0xF2
15122  36E3     RLCF 0xFE3, F, ACCESS
129:           		if (grs & 0x80000000) {
15124  0EF6     MOVLW 0xF6
15126  AEE3     BTFSS 0xFE3, 7, ACCESS
15128  D002     BRA 0x512E
130:           			B_FRACTION.i |= 0x1;
1512A  0EEF     MOVLW 0xEF
1512C  80E3     BSF 0xFE3, 0, ACCESS
131:           		}
132:           		grs <<= 1;
1512E  90D8     BCF 0xFD8, 0, ACCESS
15130  0EF3     MOVLW 0xF3
15132  36E3     RLCF 0xFE3, F, ACCESS
15134  0EF4     MOVLW 0xF4
15136  36E3     RLCF 0xFE3, F, ACCESS
15138  0EF5     MOVLW 0xF5
1513A  36E3     RLCF 0xFE3, F, ACCESS
1513C  0EF6     MOVLW 0xF6
1513E  36E3     RLCF 0xFE3, F, ACCESS
133:           		--new_exp;
15140  50E1     MOVF 0xFE1, W, ACCESS
15142  0FFB     ADDLW 0xFB
15144  6ED9     MOVWF 0xFD9, ACCESS
15146  50E2     MOVF 0xFE2, W, ACCESS
15148  6EDA     MOVWF 0xFDA, ACCESS
1514A  0EFF     MOVLW 0xFF
1514C  22DA     ADDWFC 0xFDA, F, ACCESS
1514E  06DE     DECF 0xFDE, F, ACCESS
15150  0E00     MOVLW 0x0
15152  5ADD     SUBWFB 0xFDD, F, ACCESS
134:           	}
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
1515A  0EFD     MOVLW 0xFD
1515C  6AE3     CLRF 0xFE3, ACCESS
140:           	if (grs & ((uint32_t) 1 << 31)) {
1515E  0EF6     MOVLW 0xF6
15160  AEE3     BTFSS 0xFE3, 7, ACCESS
15162  D020     BRA 0x51A4
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
15164  50E1     MOVF 0xFE1, W, ACCESS
15166  0FF3     ADDLW 0xF3
15168  6ED9     MOVWF 0xFD9, ACCESS
1516A  50E2     MOVF 0xFE2, W, ACCESS
1516C  6EDA     MOVWF 0xFDA, ACCESS
1516E  0EFF     MOVLW 0xFF
15170  22DA     ADDWFC 0xFDA, F, ACCESS
15172  0EFF     MOVLW 0xFF
15174  14DE     ANDWF 0xFDE, W, ACCESS
15176  6E09     MOVWF ltemp2, ACCESS
15178  0EFF     MOVLW 0xFF
1517A  14DE     ANDWF 0xFDE, W, ACCESS
1517C  6E0A     MOVWF ttemp3, ACCESS
1517E  0EFF     MOVLW 0xFF
15180  14DE     ANDWF 0xFDE, W, ACCESS
15182  6E0B     MOVWF wtemp5, ACCESS
15184  0E7F     MOVLW 0x7F
15186  14DE     ANDWF 0xFDE, W, ACCESS
15188  6E0C     MOVWF 0xC, ACCESS
1518A  5009     MOVF ltemp2, W, ACCESS
1518C  100A     IORWF ttemp3, W, ACCESS
1518E  100B     IORWF wtemp5, W, ACCESS
15190  100C     IORWF 0xC, W, ACCESS
15192  B4D8     BTFSC 0xFD8, 2, ACCESS
15194  D004     BRA 0x519E
142:           			aexp = 1;
15196  0EFD     MOVLW 0xFD
15198  6AE3     CLRF 0xFE3, ACCESS
1519A  2AE3     INCF 0xFE3, F, ACCESS
143:           		}
1519C  D003     BRA 0x51A4
144:           		else {
145:           			if (B_FRACTION.i & 1) {
1519E  0EEF     MOVLW 0xEF
151A0  B0E3     BTFSC 0xFE3, 0, ACCESS
151A2  D7F9     BRA 0x5196
146:           				aexp = 1;
147:           			}
148:           		}
149:           	}
150:           	if (aexp) {
151A4  0EFD     MOVLW 0xFD
151A6  50E3     MOVF 0xFE3, W, ACCESS
151A8  B4D8     BTFSC 0xFD8, 2, ACCESS
151AA  D036     BRA 0x5218
151:           		++B_FRACTION.i;
151AC  50E1     MOVF 0xFE1, W, ACCESS
151AE  0FEF     ADDLW 0xEF
151B0  6ED9     MOVWF 0xFD9, ACCESS
151B2  50E2     MOVF 0xFE2, W, ACCESS
151B4  6EDA     MOVWF 0xFDA, ACCESS
151B6  0EFF     MOVLW 0xFF
151B8  22DA     ADDWFC 0xFDA, F, ACCESS
151BA  2ADE     INCF 0xFDE, F, ACCESS
151BC  0E00     MOVLW 0x0
151BE  22DE     ADDWFC 0xFDE, F, ACCESS
151C0  22DE     ADDWFC 0xFDE, F, ACCESS
151C2  22DE     ADDWFC 0xFDE, F, ACCESS
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
151C4  0EF2     MOVLW 0xF2
151C6  A0E3     BTFSS 0xFE3, 0, ACCESS
151C8  D027     BRA 0x5218
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
151CA  0E01     MOVLW 0x1
151CC  6E0C     MOVWF 0xC, ACCESS
151CE  50E1     MOVF 0xFE1, W, ACCESS
151D0  0FEF     ADDLW 0xEF
151D2  6ED9     MOVWF 0xFD9, ACCESS
151D4  50E2     MOVF 0xFE2, W, ACCESS
151D6  6EDA     MOVWF 0xFDA, ACCESS
151D8  0EFF     MOVLW 0xFF
151DA  22DA     ADDWFC 0xFDA, F, ACCESS
151DC  280C     INCF 0xC, W, ACCESS
151DE  52DE     MOVF 0xFDE, F, ACCESS
151E0  D008     BRA 0x51F2
151E2  52DE     MOVF 0xFDE, F, ACCESS
151E4  90D8     BCF 0xFD8, 0, ACCESS
151E6  BEDC     BTFSC 0xFDC, 7, ACCESS
151E8  80D8     BSF 0xFD8, 0, ACCESS
151EA  32DD     RRCF 0xFDD, F, ACCESS
151EC  32DD     RRCF 0xFDD, F, ACCESS
151EE  32DD     RRCF 0xFDD, F, ACCESS
151F0  32DE     RRCF 0xFDE, F, ACCESS
151F2  2EE8     DECFSZ 0xFE8, F, ACCESS
151F4  D7F6     BRA 0x51E2
154:           			++new_exp;
151F6  0EFB     MOVLW 0xFB
151F8  50E3     MOVF 0xFE3, W, ACCESS
151FA  0F01     ADDLW 0x1
151FC  6E01     MOVWF ltemp0, ACCESS
151FE  0EFB     MOVLW 0xFB
15202  F007     NOP
15204  FFE3     NOP
15206  6A01     CLRF ltemp0, ACCESS
15208  0EFC     MOVLW 0xFC
1520A  50E3     MOVF 0xFE3, W, ACCESS
1520C  2001     ADDWFC ltemp0, W, ACCESS
1520E  6E01     MOVWF ltemp0, ACCESS
15210  0EFC     MOVLW 0xFC
15214  F007     NOP
15216  FFE3     NOP
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
15218  0EFC     MOVLW 0xFC
1521A  BEE3     BTFSC 0xFE3, 7, ACCESS
1521C  D01B     BRA 0x5254
1521E  0EFC     MOVLW 0xFC
15220  50E3     MOVF 0xFE3, W, ACCESS
15222  E104     BNZ 0x522C
15224  0EFB     MOVLW 0xFB
15226  28E3     INCF 0xFE3, W, ACCESS
15228  A0D8     BTFSS 0xFD8, 0, ACCESS
1522A  D014     BRA 0x5254
160:           		new_exp = SPEXPM;
1522C  0EFF     MOVLW 0xFF
1522E  6E0B     MOVWF wtemp5, ACCESS
15230  0E00     MOVLW 0x0
15232  6E0C     MOVWF 0xC, ACCESS
15234  0EFB     MOVLW 0xFB
15238  F02F     NOP
1523A  FFE3     NOP
1523C  0EFC     MOVLW 0xFC
15240  F033     NOP
15242  FFE3     NOP
161:           		B_FRACTION.i = 0;
15244  0EEF     MOVLW 0xEF
15246  6AE3     CLRF 0xFE3, ACCESS
15248  0EF0     MOVLW 0xF0
1524A  6AE3     CLRF 0xFE3, ACCESS
1524C  0EF1     MOVLW 0xF1
1524E  6AE3     CLRF 0xFE3, ACCESS
15250  0EF2     MOVLW 0xF2
15252  6AE3     CLRF 0xFE3, ACCESS
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
15254  0EFC     MOVLW 0xFC
15256  BEE3     BTFSC 0xFE3, 7, ACCESS
15258  D007     BRA 0x5268
1525A  0EFC     MOVLW 0xFC
1525C  50E3     MOVF 0xFE3, W, ACCESS
1525E  E112     BNZ 0x5284
15260  0EFB     MOVLW 0xFB
15262  04E3     DECF 0xFE3, W, ACCESS
15264  B0D8     BTFSC 0xFD8, 0, ACCESS
15266  D00E     BRA 0x5284
166:           		new_exp = 0;
15268  0EFB     MOVLW 0xFB
1526A  6AE3     CLRF 0xFE3, ACCESS
1526C  0EFC     MOVLW 0xFC
1526E  6AE3     CLRF 0xFE3, ACCESS
167:           		B_FRACTION.i = 0;
15270  0EEF     MOVLW 0xEF
15272  6AE3     CLRF 0xFE3, ACCESS
15274  0EF0     MOVLW 0xF0
15276  6AE3     CLRF 0xFE3, ACCESS
15278  0EF1     MOVLW 0xF1
1527A  6AE3     CLRF 0xFE3, ACCESS
1527C  0EF2     MOVLW 0xF2
1527E  6AE3     CLRF 0xFE3, ACCESS
168:                           // no negative fp 0 for now
169:                           sign = 0;
15280  0EFF     MOVLW 0xFF
15282  6AE3     CLRF 0xFE3, ACCESS
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = new_exp;
15284  0EFB     MOVLW 0xFB
15288  FF8C     NOP
1528A  F001     NOP
1528C  0EFE     MOVLW 0xFE
15290  F007     NOP
15292  FFE3     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
15294  0EFE     MOVLW 0xFE
15296  A0E3     BTFSS 0xFE3, 0, ACCESS
15298  D009     BRA 0x52AC
176:           		B_FRACTION.fAsBytes.c |= 0x80;
1529A  0EF1     MOVLW 0xF1
1529C  24E1     ADDWF 0xFE1, W, ACCESS
1529E  6ED9     MOVWF 0xFD9, ACCESS
152A0  0EFF     MOVLW 0xFF
152A2  20E2     ADDWFC 0xFE2, W, ACCESS
152A4  6EDA     MOVWF 0xFDA, ACCESS
152A6  0E00     MOVLW 0x0
152A8  8EDB     BSF 0xFDB, 7, ACCESS
177:           	}
152AA  D008     BRA 0x52BC
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
152AC  0EF1     MOVLW 0xF1
152AE  24E1     ADDWF 0xFE1, W, ACCESS
152B0  6ED9     MOVWF 0xFD9, ACCESS
152B2  0EFF     MOVLW 0xFF
152B4  20E2     ADDWFC 0xFE2, W, ACCESS
152B6  6EDA     MOVWF 0xFDA, ACCESS
152B8  0E7F     MOVLW 0x7F
152BA  16DF     ANDWF 0xFDF, F, ACCESS
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
152BC  0EF2     MOVLW 0xF2
152BE  24E1     ADDWF 0xFE1, W, ACCESS
152C0  6ED9     MOVWF 0xFD9, ACCESS
152C2  0EFF     MOVLW 0xFF
152C4  20E2     ADDWFC 0xFE2, W, ACCESS
152C6  6EDA     MOVWF 0xFDA, ACCESS
152C8  0EFE     MOVLW 0xFE
152CC  FF8C     NOP
152CE  F00C     NOP
152D0  90D8     BCF 0xFD8, 0, ACCESS
152D2  300C     RRCF 0xC, W, ACCESS
152D4  6EDF     MOVWF 0xFDF, ACCESS
152D6  D644     BRA 0x4F60
183:           	B_FRACTION.fAsBytes.d |= sign;
184:           	return b;
185:           }
152D8  0EEB     MOVLW 0xEB
152DA  26E1     ADDWF 0xFE1, F, ACCESS
152DC  0EFF     MOVLW 0xFF
152DE  22E2     ADDWFC 0xFE2, F, ACCESS
152E0  0012     RETURN 0
186:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/sprcadd.c  -----------------------------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
145AC  52E6     MOVF 0xFE6, F, ACCESS
145AE  52E6     MOVF 0xFE6, F, ACCESS
145B0  52E6     MOVF 0xFE6, F, ACCESS
145B2  52E6     MOVF 0xFE6, F, ACCESS
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
145B4  0EFB     MOVLW 0xFB
145B6  24E1     ADDWF 0xFE1, W, ACCESS
145B8  6ED9     MOVWF 0xFD9, ACCESS
145BA  0EFF     MOVLW 0xFF
145BC  20E2     ADDWFC 0xFE2, W, ACCESS
145BE  6EDA     MOVWF 0xFDA, ACCESS
145C0  50DF     MOVF 0xFDF, W, ACCESS
145C2  6E0C     MOVWF 0xC, ACCESS
145C4  0E80     MOVLW 0x80
145C6  160C     ANDWF 0xC, F, ACCESS
145C8  0EFF     MOVLW 0xFF
145CC  F033     NOP
145CE  FFE3     NOP
22:            	bexp = B_FRACTION.fAsBytes.d << 1;
145D0  0EFB     MOVLW 0xFB
145D2  24E1     ADDWF 0xFE1, W, ACCESS
145D4  6ED9     MOVWF 0xFD9, ACCESS
145D6  0EFF     MOVLW 0xFF
145D8  20E2     ADDWFC 0xFE2, W, ACCESS
145DA  6EDA     MOVWF 0xFDA, ACCESS
145DC  50DF     MOVF 0xFDF, W, ACCESS
145DE  6E0C     MOVWF 0xC, ACCESS
145E0  90D8     BCF 0xFD8, 0, ACCESS
145E2  340C     RLCF 0xC, W, ACCESS
145E4  6E0B     MOVWF wtemp5, ACCESS
145E6  0EFD     MOVLW 0xFD
145EA  F02F     NOP
145EC  FFE3     NOP
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
145EE  0EFA     MOVLW 0xFA
145F0  24E1     ADDWF 0xFE1, W, ACCESS
145F2  6ED9     MOVWF 0xFD9, ACCESS
145F4  0EFF     MOVLW 0xFF
145F6  20E2     ADDWFC 0xFE2, W, ACCESS
145F8  6EDA     MOVWF 0xFDA, ACCESS
145FA  AEDF     BTFSS 0xFDF, 7, ACCESS
145FC  D002     BRA 0x4602
24:            		bexp |= 0x1;
145FE  0EFD     MOVLW 0xFD
14600  80E3     BSF 0xFE3, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
14602  0EFD     MOVLW 0xFD
14604  50E3     MOVF 0xFE3, W, ACCESS
14606  B4D8     BTFSC 0xFD8, 2, ACCESS
14608  D027     BRA 0x4658
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
1460A  0EFD     MOVLW 0xFD
1460C  28E3     INCF 0xFE3, W, ACCESS
1460E  A4D8     BTFSS 0xFD8, 2, ACCESS
14610  D018     BRA 0x4642
31:            			/* Make it inf */
32:            			b = 0;
14612  0E00     MOVLW 0x0
14614  6E09     MOVWF ltemp2, ACCESS
14616  0E00     MOVLW 0x0
14618  6E0A     MOVWF ttemp3, ACCESS
1461A  0E00     MOVLW 0x0
1461C  6E0B     MOVWF wtemp5, ACCESS
1461E  0E00     MOVLW 0x0
14620  6E0C     MOVWF 0xC, ACCESS
14622  0EF8     MOVLW 0xF8
14626  F027     NOP
14628  FFE3     NOP
1462A  0EF9     MOVLW 0xF9
1462E  F02B     NOP
14630  FFE3     NOP
14632  0EFA     MOVLW 0xFA
14636  F02F     NOP
14638  FFE3     NOP
1463A  0EFB     MOVLW 0xFB
1463E  F033     NOP
14640  FFE3     NOP
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
14642  0EFA     MOVLW 0xFA
14644  8EE3     BSF 0xFE3, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
14646  0EFB     MOVLW 0xFB
14648  24E1     ADDWF 0xFE1, W, ACCESS
1464A  6ED9     MOVWF 0xFD9, ACCESS
1464C  0EFF     MOVLW 0xFF
1464E  20E2     ADDWFC 0xFE2, W, ACCESS
14650  6EDA     MOVWF 0xFDA, ACCESS
14652  0E00     MOVLW 0x0
14654  6EDF     MOVWF 0xFDF, ACCESS
38:            	}
14656  D018     BRA 0x4688
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
14658  0E00     MOVLW 0x0
1465A  6E09     MOVWF ltemp2, ACCESS
1465C  0E00     MOVLW 0x0
1465E  6E0A     MOVWF ttemp3, ACCESS
14660  0E00     MOVLW 0x0
14662  6E0B     MOVWF wtemp5, ACCESS
14664  0E00     MOVLW 0x0
14666  6E0C     MOVWF 0xC, ACCESS
14668  0EF8     MOVLW 0xF8
1466C  F027     NOP
1466E  FFE3     NOP
14670  0EF9     MOVLW 0xF9
14674  F02B     NOP
14676  FFE3     NOP
14678  0EFA     MOVLW 0xFA
1467C  F02F     NOP
1467E  FFE3     NOP
14680  0EFB     MOVLW 0xFB
14684  F033     NOP
14686  FFE3     NOP
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
14688  0EF7     MOVLW 0xF7
1468A  24E1     ADDWF 0xFE1, W, ACCESS
1468C  6ED9     MOVWF 0xFD9, ACCESS
1468E  0EFF     MOVLW 0xFF
14690  20E2     ADDWFC 0xFE2, W, ACCESS
14692  6EDA     MOVWF 0xFDA, ACCESS
14694  50DF     MOVF 0xFDF, W, ACCESS
14696  6E0C     MOVWF 0xC, ACCESS
14698  0E80     MOVLW 0x80
1469A  160C     ANDWF 0xC, F, ACCESS
1469C  0EFE     MOVLW 0xFE
146A0  F033     NOP
146A2  FFE3     NOP
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
146A4  50E1     MOVF 0xFE1, W, ACCESS
146A6  0FFE     ADDLW 0xFE
146A8  6ED9     MOVWF 0xFD9, ACCESS
146AA  50E2     MOVF 0xFE2, W, ACCESS
146AC  6EDA     MOVWF 0xFDA, ACCESS
146AE  0EFF     MOVLW 0xFF
146B0  22DA     ADDWFC 0xFDA, F, ACCESS
146B2  0EFF     MOVLW 0xFF
146B4  50E3     MOVF 0xFE3, W, ACCESS
146B6  18DE     XORWF 0xFDE, W, ACCESS
146B8  B4D8     BTFSC 0xFD8, 2, ACCESS
146BA  D002     BRA 0x46C0
47:            		signs |= 0x40;
146BC  0EFF     MOVLW 0xFF
146BE  8CE3     BSF 0xFE3, 6, ACCESS
48:            	}
49:            	aexp = A_FRACTION.fAsBytes.d << 1;
146C0  0EF7     MOVLW 0xF7
146C2  24E1     ADDWF 0xFE1, W, ACCESS
146C4  6ED9     MOVWF 0xFD9, ACCESS
146C6  0EFF     MOVLW 0xFF
146C8  20E2     ADDWFC 0xFE2, W, ACCESS
146CA  6EDA     MOVWF 0xFDA, ACCESS
146CC  50DF     MOVF 0xFDF, W, ACCESS
146CE  6E0C     MOVWF 0xC, ACCESS
146D0  90D8     BCF 0xFD8, 0, ACCESS
146D2  340C     RLCF 0xC, W, ACCESS
146D4  6E0B     MOVWF wtemp5, ACCESS
146D6  0EFE     MOVLW 0xFE
146DA  F02F     NOP
146DC  FFE3     NOP
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
146DE  0EF6     MOVLW 0xF6
146E0  24E1     ADDWF 0xFE1, W, ACCESS
146E2  6ED9     MOVWF 0xFD9, ACCESS
146E4  0EFF     MOVLW 0xFF
146E6  20E2     ADDWFC 0xFE2, W, ACCESS
146E8  6EDA     MOVWF 0xFDA, ACCESS
146EA  AEDF     BTFSS 0xFDF, 7, ACCESS
146EC  D002     BRA 0x46F2
51:            		aexp |= 0x1;
146EE  0EFE     MOVLW 0xFE
146F0  80E3     BSF 0xFE3, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
146F2  0EFE     MOVLW 0xFE
146F4  50E3     MOVF 0xFE3, W, ACCESS
146F6  B4D8     BTFSC 0xFD8, 2, ACCESS
146F8  D027     BRA 0x4748
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
146FA  0EFE     MOVLW 0xFE
146FC  28E3     INCF 0xFE3, W, ACCESS
146FE  A4D8     BTFSS 0xFD8, 2, ACCESS
14700  D018     BRA 0x4732
58:            			/* Make it inf */
59:            			a = 0;
14702  0E00     MOVLW 0x0
14704  6E09     MOVWF ltemp2, ACCESS
14706  0E00     MOVLW 0x0
14708  6E0A     MOVWF ttemp3, ACCESS
1470A  0E00     MOVLW 0x0
1470C  6E0B     MOVWF wtemp5, ACCESS
1470E  0E00     MOVLW 0x0
14710  6E0C     MOVWF 0xC, ACCESS
14712  0EF4     MOVLW 0xF4
14716  F027     NOP
14718  FFE3     NOP
1471A  0EF5     MOVLW 0xF5
1471E  F02B     NOP
14720  FFE3     NOP
14722  0EF6     MOVLW 0xF6
14726  F02F     NOP
14728  FFE3     NOP
1472A  0EF7     MOVLW 0xF7
1472E  F033     NOP
14730  FFE3     NOP
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
14732  0EF6     MOVLW 0xF6
14734  8EE3     BSF 0xFE3, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
14736  0EF7     MOVLW 0xF7
14738  24E1     ADDWF 0xFE1, W, ACCESS
1473A  6ED9     MOVWF 0xFD9, ACCESS
1473C  0EFF     MOVLW 0xFF
1473E  20E2     ADDWFC 0xFE2, W, ACCESS
14740  6EDA     MOVWF 0xFDA, ACCESS
14742  0E00     MOVLW 0x0
14744  6EDF     MOVWF 0xFDF, ACCESS
65:            	}
14746  D018     BRA 0x4778
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
14748  0E00     MOVLW 0x0
1474A  6E09     MOVWF ltemp2, ACCESS
1474C  0E00     MOVLW 0x0
1474E  6E0A     MOVWF ttemp3, ACCESS
14750  0E00     MOVLW 0x0
14752  6E0B     MOVWF wtemp5, ACCESS
14754  0E00     MOVLW 0x0
14756  6E0C     MOVWF 0xC, ACCESS
14758  0EF4     MOVLW 0xF4
1475C  F027     NOP
1475E  FFE3     NOP
14760  0EF5     MOVLW 0xF5
14764  F02B     NOP
14766  FFE3     NOP
14768  0EF6     MOVLW 0xF6
1476C  F02F     NOP
1476E  FFE3     NOP
14770  0EF7     MOVLW 0xF7
14774  F033     NOP
14776  FFE3     NOP
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
14778  50E1     MOVF 0xFE1, W, ACCESS
1477A  0FFE     ADDLW 0xFE
1477C  6ED9     MOVWF 0xFD9, ACCESS
1477E  50E2     MOVF 0xFE2, W, ACCESS
14780  6EDA     MOVWF 0xFDA, ACCESS
14782  0EFF     MOVLW 0xFF
14784  22DA     ADDWFC 0xFDA, F, ACCESS
14786  0EFD     MOVLW 0xFD
14788  50E3     MOVF 0xFE3, W, ACCESS
1478A  5CDE     SUBWF 0xFDE, W, ACCESS
1478C  B0D8     BTFSC 0xFD8, 0, ACCESS
1478E  D0A4     BRA 0x48D8
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
14790  0EFF     MOVLW 0xFF
14792  ACE3     BTFSS 0xFE3, 6, ACCESS
14794  D002     BRA 0x479A
78:            			signs ^= 0x80;
14796  0EFF     MOVLW 0xFF
14798  7EE3     BTG 0xFE3, 7, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
1479A  0EFD     MOVLW 0xFD
1479E  FF8C     NOP
147A0  F001     NOP
147A2  0EFC     MOVLW 0xFC
147A6  F007     NOP
147A8  FFE3     NOP
82:            		bexp = aexp;
147AA  0EFE     MOVLW 0xFE
147AE  FF8C     NOP
147B0  F001     NOP
147B2  0EFD     MOVLW 0xFD
147B6  F007     NOP
147B8  FFE3     NOP
83:            		aexp = grs;
147BA  0EFC     MOVLW 0xFC
147BE  FF8C     NOP
147C0  F001     NOP
147C2  0EFE     MOVLW 0xFE
147C6  F007     NOP
147C8  FFE3     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
147CA  0EF8     MOVLW 0xF8
147CE  FF8C     NOP
147D0  F001     NOP
147D2  0EFC     MOVLW 0xFC
147D6  F007     NOP
147D8  FFE3     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
147DA  0EF4     MOVLW 0xF4
147DE  FF8C     NOP
147E0  F001     NOP
147E2  0EF8     MOVLW 0xF8
147E6  F007     NOP
147E8  FFE3     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
147EA  0EFC     MOVLW 0xFC
147EE  FF8C     NOP
147F0  F001     NOP
147F2  0EF4     MOVLW 0xF4
147F6  F007     NOP
147F8  FFE3     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
147FA  0EF9     MOVLW 0xF9
147FC  24E1     ADDWF 0xFE1, W, ACCESS
147FE  6ED9     MOVWF 0xFD9, ACCESS
14800  0EFF     MOVLW 0xFF
14802  20E2     ADDWFC 0xFE2, W, ACCESS
14804  6EDA     MOVWF 0xFDA, ACCESS
14806  50DF     MOVF 0xFDF, W, ACCESS
14808  6E0C     MOVWF 0xC, ACCESS
1480A  0EFC     MOVLW 0xFC
1480E  F033     NOP
14810  FFE3     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
14812  0EF5     MOVLW 0xF5
14814  24E1     ADDWF 0xFE1, W, ACCESS
14816  6ED9     MOVWF 0xFD9, ACCESS
14818  0EFF     MOVLW 0xFF
1481A  20E2     ADDWFC 0xFE2, W, ACCESS
1481C  6EDA     MOVWF 0xFDA, ACCESS
1481E  0EF9     MOVLW 0xF9
14820  24E1     ADDWF 0xFE1, W, ACCESS
14822  6EE9     MOVWF 0xFE9, ACCESS
14824  0EFF     MOVLW 0xFF
14826  20E2     ADDWFC 0xFE2, W, ACCESS
14828  6EEA     MOVWF 0xFEA, ACCESS
1482C  FF7F     NOP
1482E  FFEF     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
14830  0EF5     MOVLW 0xF5
14832  24E1     ADDWF 0xFE1, W, ACCESS
14834  6ED9     MOVWF 0xFD9, ACCESS
14836  0EFF     MOVLW 0xFF
14838  20E2     ADDWFC 0xFE2, W, ACCESS
1483A  6EDA     MOVWF 0xFDA, ACCESS
1483C  0EFC     MOVLW 0xFC
14840  FF8F     NOP
14842  FFDF     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
14844  0EFA     MOVLW 0xFA
14846  24E1     ADDWF 0xFE1, W, ACCESS
14848  6ED9     MOVWF 0xFD9, ACCESS
1484A  0EFF     MOVLW 0xFF
1484C  20E2     ADDWFC 0xFE2, W, ACCESS
1484E  6EDA     MOVWF 0xFDA, ACCESS
14850  50DF     MOVF 0xFDF, W, ACCESS
14852  6E0C     MOVWF 0xC, ACCESS
14854  0EFC     MOVLW 0xFC
14858  F033     NOP
1485A  FFE3     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
1485C  0EF6     MOVLW 0xF6
1485E  24E1     ADDWF 0xFE1, W, ACCESS
14860  6ED9     MOVWF 0xFD9, ACCESS
14862  0EFF     MOVLW 0xFF
14864  20E2     ADDWFC 0xFE2, W, ACCESS
14866  6EDA     MOVWF 0xFDA, ACCESS
14868  0EFA     MOVLW 0xFA
1486A  24E1     ADDWF 0xFE1, W, ACCESS
1486C  6EE9     MOVWF 0xFE9, ACCESS
1486E  0EFF     MOVLW 0xFF
14870  20E2     ADDWFC 0xFE2, W, ACCESS
14872  6EEA     MOVWF 0xFEA, ACCESS
14876  FF7F     NOP
14878  FFEF     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
1487A  0EF6     MOVLW 0xF6
1487C  24E1     ADDWF 0xFE1, W, ACCESS
1487E  6ED9     MOVWF 0xFD9, ACCESS
14880  0EFF     MOVLW 0xFF
14882  20E2     ADDWFC 0xFE2, W, ACCESS
14884  6EDA     MOVWF 0xFDA, ACCESS
14886  0EFC     MOVLW 0xFC
1488A  FF8F     NOP
1488C  FFDF     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
1488E  0EFB     MOVLW 0xFB
14890  24E1     ADDWF 0xFE1, W, ACCESS
14892  6ED9     MOVWF 0xFD9, ACCESS
14894  0EFF     MOVLW 0xFF
14896  20E2     ADDWFC 0xFE2, W, ACCESS
14898  6EDA     MOVWF 0xFDA, ACCESS
1489A  50DF     MOVF 0xFDF, W, ACCESS
1489C  6E0C     MOVWF 0xC, ACCESS
1489E  0EFC     MOVLW 0xFC
148A2  F033     NOP
148A4  FFE3     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
148A6  0EF7     MOVLW 0xF7
148A8  24E1     ADDWF 0xFE1, W, ACCESS
148AA  6ED9     MOVWF 0xFD9, ACCESS
148AC  0EFF     MOVLW 0xFF
148AE  20E2     ADDWFC 0xFE2, W, ACCESS
148B0  6EDA     MOVWF 0xFDA, ACCESS
148B2  0EFB     MOVLW 0xFB
148B4  24E1     ADDWF 0xFE1, W, ACCESS
148B6  6EE9     MOVWF 0xFE9, ACCESS
148B8  0EFF     MOVLW 0xFF
148BA  20E2     ADDWFC 0xFE2, W, ACCESS
148BC  6EEA     MOVWF 0xFEA, ACCESS
148C0  FF7F     NOP
148C2  FFEF     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
148C4  0EF7     MOVLW 0xF7
148C6  24E1     ADDWF 0xFE1, W, ACCESS
148C8  6ED9     MOVWF 0xFD9, ACCESS
148CA  0EFF     MOVLW 0xFF
148CC  20E2     ADDWFC 0xFE2, W, ACCESS
148CE  6EDA     MOVWF 0xFDA, ACCESS
148D0  0EFC     MOVLW 0xFC
148D4  FF8F     NOP
148D6  FFDF     NOP
96:            	}
97:            
98:            	grs = 0;
148D8  0EFC     MOVLW 0xFC
148DA  6AE3     CLRF 0xFE3, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
148DC  0EFE     MOVLW 0xFE
148DE  50E3     MOVF 0xFE3, W, ACCESS
148E0  6E0B     MOVWF wtemp5, ACCESS
148E2  6A0C     CLRF 0xC, ACCESS
148E4  0EFD     MOVLW 0xFD
148E6  50E3     MOVF 0xFE3, W, ACCESS
148E8  5E0B     SUBWF wtemp5, F, ACCESS
148EA  0E00     MOVLW 0x0
148EC  5A0C     SUBWFB 0xC, F, ACCESS
148EE  BE0C     BTFSC 0xC, 7, ACCESS
148F0  D062     BRA 0x49B6
148F2  500C     MOVF 0xC, W, ACCESS
148F4  E104     BNZ 0x48FE
148F6  0E1A     MOVLW 0x1A
148F8  5C0B     SUBWF wtemp5, W, ACCESS
148FA  A0D8     BTFSS 0xFD8, 0, ACCESS
148FC  D05C     BRA 0x49B6
101:           		grs = B_FRACTION.i ? 1 : 0;
148FE  0EF8     MOVLW 0xF8
14900  50E3     MOVF 0xFE3, W, ACCESS
14902  E10A     BNZ 0x4918
14904  0EF9     MOVLW 0xF9
14906  50E3     MOVF 0xFE3, W, ACCESS
14908  E107     BNZ 0x4918
1490A  0EFA     MOVLW 0xFA
1490C  50E3     MOVF 0xFE3, W, ACCESS
1490E  E104     BNZ 0x4918
14910  0EFB     MOVLW 0xFB
14912  50E3     MOVF 0xFE3, W, ACCESS
14914  B4D8     BTFSC 0xFD8, 2, ACCESS
14916  D003     BRA 0x491E
14918  6A0C     CLRF 0xC, ACCESS
1491A  2A0C     INCF 0xC, F, ACCESS
1491C  D001     BRA 0x4920
1491E  6A0C     CLRF 0xC, ACCESS
14920  0EFC     MOVLW 0xFC
14924  F033     NOP
14926  FFE3     NOP
102:           		B_FRACTION.i = 0;
14928  0EF8     MOVLW 0xF8
1492A  6AE3     CLRF 0xFE3, ACCESS
1492C  0EF9     MOVLW 0xF9
1492E  6AE3     CLRF 0xFE3, ACCESS
14930  0EFA     MOVLW 0xFA
14932  6AE3     CLRF 0xFE3, ACCESS
14934  0EFB     MOVLW 0xFB
14936  6AE3     CLRF 0xFE3, ACCESS
103:           		bexp = aexp;
14938  0EFE     MOVLW 0xFE
1493C  FF8C     NOP
1493E  F001     NOP
14940  0EFD     MOVLW 0xFD
14944  F007     NOP
14946  FFE3     NOP
104:           	}
14948  D042     BRA 0x49CE
105:           	else {
106:           		while (bexp < aexp) {
149B6  50E1     MOVF 0xFE1, W, ACCESS
149B8  0FFD     ADDLW 0xFD
149BA  6ED9     MOVWF 0xFD9, ACCESS
149BC  50E2     MOVF 0xFE2, W, ACCESS
149BE  6EDA     MOVWF 0xFDA, ACCESS
149C0  0EFF     MOVLW 0xFF
149C2  22DA     ADDWFC 0xFDA, F, ACCESS
149C4  0EFE     MOVLW 0xFE
149C6  50E3     MOVF 0xFE3, W, ACCESS
149C8  5CDE     SUBWF 0xFDE, W, ACCESS
149CA  A0D8     BTFSS 0xFD8, 0, ACCESS
149CC  D7BE     BRA 0x494A
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
1494A  0EFC     MOVLW 0xFC
1494C  A0E3     BTFSS 0xFE3, 0, ACCESS
1494E  D00D     BRA 0x496A
110:           				grs = (grs >> 1) | 0x1;
14950  0EFC     MOVLW 0xFC
14954  FF8C     NOP
14956  F00C     NOP
14958  90D8     BCF 0xFD8, 0, ACCESS
1495A  320C     RRCF 0xC, F, ACCESS
1495C  0E01     MOVLW 0x1
1495E  120C     IORWF 0xC, F, ACCESS
14960  0EFC     MOVLW 0xFC
14964  F033     NOP
14966  FFE3     NOP
111:           			}
14968  D009     BRA 0x497C
112:           			else {
113:           				grs >>= 1;
1496A  50E1     MOVF 0xFE1, W, ACCESS
1496C  0FFC     ADDLW 0xFC
1496E  6ED9     MOVWF 0xFD9, ACCESS
14970  50E2     MOVF 0xFE2, W, ACCESS
14972  6EDA     MOVWF 0xFDA, ACCESS
14974  0EFF     MOVLW 0xFF
14976  22DA     ADDWFC 0xFDA, F, ACCESS
14978  90D8     BCF 0xFD8, 0, ACCESS
1497A  32DF     RRCF 0xFDF, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
1497C  0EF8     MOVLW 0xF8
1497E  A0E3     BTFSS 0xFE3, 0, ACCESS
14980  D002     BRA 0x4986
116:           				grs |= 0x80;
14982  0EFC     MOVLW 0xFC
14984  8EE3     BSF 0xFE3, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
14986  0E01     MOVLW 0x1
14988  6E0C     MOVWF 0xC, ACCESS
1498A  50E1     MOVF 0xFE1, W, ACCESS
1498C  0FF8     ADDLW 0xF8
1498E  6ED9     MOVWF 0xFD9, ACCESS
14990  50E2     MOVF 0xFE2, W, ACCESS
14992  6EDA     MOVWF 0xFDA, ACCESS
14994  0EFF     MOVLW 0xFF
14996  22DA     ADDWFC 0xFDA, F, ACCESS
14998  280C     INCF 0xC, W, ACCESS
1499A  52DE     MOVF 0xFDE, F, ACCESS
1499C  D008     BRA 0x49AE
1499E  52DE     MOVF 0xFDE, F, ACCESS
149A0  90D8     BCF 0xFD8, 0, ACCESS
149A2  BEDC     BTFSC 0xFDC, 7, ACCESS
149A4  80D8     BSF 0xFD8, 0, ACCESS
149A6  32DD     RRCF 0xFDD, F, ACCESS
149A8  32DD     RRCF 0xFDD, F, ACCESS
149AA  32DD     RRCF 0xFDD, F, ACCESS
149AC  32DE     RRCF 0xFDE, F, ACCESS
149AE  2EE8     DECFSZ 0xFE8, F, ACCESS
149B0  D7F6     BRA 0x499E
119:           			bexp++;
149B2  0EFD     MOVLW 0xFD
149B4  2AE3     INCF 0xFE3, F, ACCESS
120:           		}
121:           	}
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
149CE  0EFF     MOVLW 0xFF
149D0  BCE3     BTFSC 0xFE3, 6, ACCESS
149D2  D066     BRA 0x4AA0
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
149D4  0EFD     MOVLW 0xFD
149D6  50E3     MOVF 0xFE3, W, ACCESS
149D8  B4D8     BTFSC 0xFD8, 2, ACCESS
128:           			return 0.0;
149DA  D0F2     BRA 0x4BC0
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
149DC  0EF8     MOVLW 0xF8
149DE  50E3     MOVF 0xFE3, W, ACCESS
149E0  6E01     MOVWF ltemp0, ACCESS
149E2  0EF4     MOVLW 0xF4
149E4  50E3     MOVF 0xFE3, W, ACCESS
149E6  2601     ADDWF ltemp0, F, ACCESS
149E8  0EF8     MOVLW 0xF8
149EC  F007     NOP
149EE  FFE3     NOP
149F0  0EF9     MOVLW 0xF9
149F2  50E3     MOVF 0xFE3, W, ACCESS
149F4  6E01     MOVWF ltemp0, ACCESS
149F6  0EF5     MOVLW 0xF5
149F8  50E3     MOVF 0xFE3, W, ACCESS
149FA  2201     ADDWFC ltemp0, F, ACCESS
149FC  0EF9     MOVLW 0xF9
14A00  F007     NOP
14A02  FFE3     NOP
14A04  0EFA     MOVLW 0xFA
14A06  50E3     MOVF 0xFE3, W, ACCESS
14A08  6E01     MOVWF ltemp0, ACCESS
14A0A  0EF6     MOVLW 0xF6
14A0C  50E3     MOVF 0xFE3, W, ACCESS
14A0E  2201     ADDWFC ltemp0, F, ACCESS
14A10  0EFA     MOVLW 0xFA
14A14  F007     NOP
14A16  FFE3     NOP
14A18  0EFB     MOVLW 0xFB
14A1A  50E3     MOVF 0xFE3, W, ACCESS
14A1C  6E01     MOVWF ltemp0, ACCESS
14A1E  0EF7     MOVLW 0xF7
14A20  50E3     MOVF 0xFE3, W, ACCESS
14A22  2201     ADDWFC ltemp0, F, ACCESS
14A24  0EFB     MOVLW 0xFB
14A28  F007     NOP
14A2A  FFE3     NOP
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
14A2C  0EFB     MOVLW 0xFB
14A2E  A0E3     BTFSS 0xFE3, 0, ACCESS
14A30  D101     BRA 0x4C34
135:           			if (grs & 1) {
14A32  0EFC     MOVLW 0xFC
14A34  A0E3     BTFSS 0xFE3, 0, ACCESS
14A36  D00D     BRA 0x4A52
136:           				grs = (grs >> 1) | 0x1;
14A38  0EFC     MOVLW 0xFC
14A3C  FF8C     NOP
14A3E  F00C     NOP
14A40  90D8     BCF 0xFD8, 0, ACCESS
14A42  320C     RRCF 0xC, F, ACCESS
14A44  0E01     MOVLW 0x1
14A46  120C     IORWF 0xC, F, ACCESS
14A48  0EFC     MOVLW 0xFC
14A4C  F033     NOP
14A4E  FFE3     NOP
137:           			}
14A50  D009     BRA 0x4A64
138:           			else {
139:           				grs >>= 1;
14A52  50E1     MOVF 0xFE1, W, ACCESS
14A54  0FFC     ADDLW 0xFC
14A56  6ED9     MOVWF 0xFD9, ACCESS
14A58  50E2     MOVF 0xFE2, W, ACCESS
14A5A  6EDA     MOVWF 0xFDA, ACCESS
14A5C  0EFF     MOVLW 0xFF
14A5E  22DA     ADDWFC 0xFDA, F, ACCESS
14A60  90D8     BCF 0xFD8, 0, ACCESS
14A62  32DF     RRCF 0xFDF, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
14A64  0EF8     MOVLW 0xF8
14A66  A0E3     BTFSS 0xFE3, 0, ACCESS
14A68  D002     BRA 0x4A6E
142:           				grs |= 0x80;
14A6A  0EFC     MOVLW 0xFC
14A6C  8EE3     BSF 0xFE3, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
14A6E  0E01     MOVLW 0x1
14A70  6E0C     MOVWF 0xC, ACCESS
14A72  50E1     MOVF 0xFE1, W, ACCESS
14A74  0FF8     ADDLW 0xF8
14A76  6ED9     MOVWF 0xFD9, ACCESS
14A78  50E2     MOVF 0xFE2, W, ACCESS
14A7A  6EDA     MOVWF 0xFDA, ACCESS
14A7C  0EFF     MOVLW 0xFF
14A7E  22DA     ADDWFC 0xFDA, F, ACCESS
14A80  280C     INCF 0xC, W, ACCESS
14A82  52DE     MOVF 0xFDE, F, ACCESS
14A84  D008     BRA 0x4A96
14A86  52DE     MOVF 0xFDE, F, ACCESS
14A88  90D8     BCF 0xFD8, 0, ACCESS
14A8A  BEDC     BTFSC 0xFDC, 7, ACCESS
14A8C  80D8     BSF 0xFD8, 0, ACCESS
14A8E  32DD     RRCF 0xFDD, F, ACCESS
14A90  32DD     RRCF 0xFDD, F, ACCESS
14A92  32DD     RRCF 0xFDD, F, ACCESS
14A94  32DE     RRCF 0xFDE, F, ACCESS
14A96  2EE8     DECFSZ 0xFE8, F, ACCESS
14A98  D7F6     BRA 0x4A86
145:           			++bexp;
14A9A  0EFD     MOVLW 0xFD
14A9C  2AE3     INCF 0xFE3, F, ACCESS
14A9E  D0CA     BRA 0x4C34
146:           		}
147:           
148:           	}
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
14AA0  50E1     MOVF 0xFE1, W, ACCESS
14AA2  0FF8     ADDLW 0xF8
14AA4  6ED9     MOVWF 0xFD9, ACCESS
14AA6  50E2     MOVF 0xFE2, W, ACCESS
14AA8  6EDA     MOVWF 0xFDA, ACCESS
14AAA  0EFF     MOVLW 0xFF
14AAC  22DA     ADDWFC 0xFDA, F, ACCESS
14AAE  0EF4     MOVLW 0xF4
14AB0  50E3     MOVF 0xFE3, W, ACCESS
14AB2  5CDE     SUBWF 0xFDE, W, ACCESS
14AB4  0EF5     MOVLW 0xF5
14AB6  50E3     MOVF 0xFE3, W, ACCESS
14AB8  58DE     SUBWFB 0xFDE, W, ACCESS
14ABA  0EF6     MOVLW 0xF6
14ABC  50E3     MOVF 0xFE3, W, ACCESS
14ABE  58DE     SUBWFB 0xFDE, W, ACCESS
14AC0  50DE     MOVF 0xFDE, W, ACCESS
14AC2  0A80     XORLW 0x80
14AC4  6E01     MOVWF ltemp0, ACCESS
14AC6  0EF7     MOVLW 0xF7
14AC8  50E3     MOVF 0xFE3, W, ACCESS
14ACA  0A80     XORLW 0x80
14ACC  5801     SUBWFB ltemp0, W, ACCESS
14ACE  B0D8     BTFSC 0xFD8, 0, ACCESS
14AD0  D053     BRA 0x4B78
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
14AD2  0EF4     MOVLW 0xF4
14AD6  FF8C     NOP
14AD8  F009     NOP
14ADA  0EF5     MOVLW 0xF5
14ADE  FF8C     NOP
14AE0  F00A     NOP
14AE2  0EF6     MOVLW 0xF6
14AE6  FF8C     NOP
14AE8  F00B     NOP
14AEA  0EF7     MOVLW 0xF7
14AEE  FF8C     NOP
14AF0  F00C     NOP
14AF2  0EF8     MOVLW 0xF8
14AF4  50E3     MOVF 0xFE3, W, ACCESS
14AF6  5E09     SUBWF ltemp2, F, ACCESS
14AF8  0EF9     MOVLW 0xF9
14AFA  50E3     MOVF 0xFE3, W, ACCESS
14AFC  5A0A     SUBWFB ttemp3, F, ACCESS
14AFE  0EFA     MOVLW 0xFA
14B00  50E3     MOVF 0xFE3, W, ACCESS
14B02  5A0B     SUBWFB wtemp5, F, ACCESS
14B04  0EFB     MOVLW 0xFB
14B06  50E3     MOVF 0xFE3, W, ACCESS
14B08  5A0C     SUBWFB 0xC, F, ACCESS
14B0A  0EFF     MOVLW 0xFF
14B0C  2409     ADDWF ltemp2, W, ACCESS
14B0E  6E05     MOVWF ltemp1, ACCESS
14B10  0EFF     MOVLW 0xFF
14B12  200A     ADDWFC ttemp3, W, ACCESS
14B14  6E06     MOVWF 0x6, ACCESS
14B16  0EFF     MOVLW 0xFF
14B18  200B     ADDWFC wtemp5, W, ACCESS
14B1A  6E07     MOVWF ttemp2, ACCESS
14B1C  0EFF     MOVLW 0xFF
14B1E  200C     ADDWFC 0xC, W, ACCESS
14B20  6E08     MOVWF 0x8, ACCESS
14B22  0EF8     MOVLW 0xF8
14B26  F017     NOP
14B28  FFE3     NOP
14B2A  0EF9     MOVLW 0xF9
14B2E  F01B     NOP
14B30  FFE3     NOP
14B32  0EFA     MOVLW 0xFA
14B36  F01F     NOP
14B38  FFE3     NOP
14B3A  0EFB     MOVLW 0xFB
14B3E  F023     NOP
14B40  FFE3     NOP
155:           			signs ^= 0x80;
14B42  0EFF     MOVLW 0xFF
14B44  7EE3     BTG 0xFE3, 7, ACCESS
156:           			grs = ~grs + 1;
14B46  0EFC     MOVLW 0xFC
14B48  50E3     MOVF 0xFE3, W, ACCESS
14B4A  0800     SUBLW 0x0
14B4C  6E0C     MOVWF 0xC, ACCESS
14B4E  0EFC     MOVLW 0xFC
14B52  F033     NOP
14B54  FFE3     NOP
157:           			if (!grs) {
14B56  0EFC     MOVLW 0xFC
14B58  50E3     MOVF 0xFE3, W, ACCESS
14B5A  A4D8     BTFSS 0xFD8, 2, ACCESS
14B5C  D020     BRA 0x4B9E
158:           				++B_FRACTION.i;
14B5E  50E1     MOVF 0xFE1, W, ACCESS
14B60  0FF8     ADDLW 0xF8
14B62  6ED9     MOVWF 0xFD9, ACCESS
14B64  50E2     MOVF 0xFE2, W, ACCESS
14B66  6EDA     MOVWF 0xFDA, ACCESS
14B68  0EFF     MOVLW 0xFF
14B6A  22DA     ADDWFC 0xFDA, F, ACCESS
14B6C  2ADE     INCF 0xFDE, F, ACCESS
14B6E  0E00     MOVLW 0x0
14B70  22DE     ADDWFC 0xFDE, F, ACCESS
14B72  22DE     ADDWFC 0xFDE, F, ACCESS
14B74  22DE     ADDWFC 0xFDE, F, ACCESS
14B76  D013     BRA 0x4B9E
159:           			}
160:           		}
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
14B78  50E1     MOVF 0xFE1, W, ACCESS
14B7A  0FF8     ADDLW 0xF8
14B7C  6ED9     MOVWF 0xFD9, ACCESS
14B7E  50E2     MOVF 0xFE2, W, ACCESS
14B80  6EDA     MOVWF 0xFDA, ACCESS
14B82  0EFF     MOVLW 0xFF
14B84  22DA     ADDWFC 0xFDA, F, ACCESS
14B86  0EF4     MOVLW 0xF4
14B88  50E3     MOVF 0xFE3, W, ACCESS
14B8A  5EDE     SUBWF 0xFDE, F, ACCESS
14B8C  0EF5     MOVLW 0xF5
14B8E  50E3     MOVF 0xFE3, W, ACCESS
14B90  5ADE     SUBWFB 0xFDE, F, ACCESS
14B92  0EF6     MOVLW 0xF6
14B94  50E3     MOVF 0xFE3, W, ACCESS
14B96  5ADE     SUBWFB 0xFDE, F, ACCESS
14B98  0EF7     MOVLW 0xF7
14B9A  50E3     MOVF 0xFE3, W, ACCESS
14B9C  5ADE     SUBWFB 0xFDE, F, ACCESS
163:           		}
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
14B9E  0EF8     MOVLW 0xF8
14BA0  50E3     MOVF 0xFE3, W, ACCESS
14BA2  E145     BNZ 0x4C2E
14BA4  0EF9     MOVLW 0xF9
14BA6  50E3     MOVF 0xFE3, W, ACCESS
14BA8  E142     BNZ 0x4C2E
14BAA  0EFA     MOVLW 0xFA
14BAC  50E3     MOVF 0xFE3, W, ACCESS
14BAE  E13F     BNZ 0x4C2E
14BB0  0EFB     MOVLW 0xFB
14BB2  50E3     MOVF 0xFE3, W, ACCESS
14BB4  A4D8     BTFSS 0xFD8, 2, ACCESS
14BB6  D03B     BRA 0x4C2E
14BB8  0EFC     MOVLW 0xFC
14BBA  50E3     MOVF 0xFE3, W, ACCESS
14BBC  A4D8     BTFSS 0xFD8, 2, ACCESS
14BBE  D037     BRA 0x4C2E
167:           			return 0.0;
14BC0  0E00     MOVLW 0x0
14BC2  6E01     MOVWF ltemp0, ACCESS
14BC4  0E00     MOVLW 0x0
14BC6  6E02     MOVWF ttemp5, ACCESS
14BC8  0E00     MOVLW 0x0
14BCA  6E03     MOVWF wtemp1, ACCESS
14BCC  0E00     MOVLW 0x0
14BCE  6E04     MOVWF ttemp1, ACCESS
14BD0  D0C6     BRA 0x4D5E
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
14C2E  0EFA     MOVLW 0xFA
14C30  AEE3     BTFSS 0xFE3, 7, ACCESS
14C32  D7CF     BRA 0x4BD2
172:           			B_FRACTION.i <<= 1;
14BD2  90D8     BCF 0xFD8, 0, ACCESS
14BD4  0EF8     MOVLW 0xF8
14BD6  36E3     RLCF 0xFE3, F, ACCESS
14BD8  0EF9     MOVLW 0xF9
14BDA  36E3     RLCF 0xFE3, F, ACCESS
14BDC  0EFA     MOVLW 0xFA
14BDE  36E3     RLCF 0xFE3, F, ACCESS
14BE0  0EFB     MOVLW 0xFB
14BE2  36E3     RLCF 0xFE3, F, ACCESS
173:           			if (grs & 0x80) {
14BE4  0EFC     MOVLW 0xFC
14BE6  AEE3     BTFSS 0xFE3, 7, ACCESS
14BE8  D002     BRA 0x4BEE
174:           				B_FRACTION.i |= 0x1;
14BEA  0EF8     MOVLW 0xF8
14BEC  80E3     BSF 0xFE3, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
14BEE  0EFC     MOVLW 0xFC
14BF0  A0E3     BTFSS 0xFE3, 0, ACCESS
14BF2  D00E     BRA 0x4C10
177:           				grs = (grs << 1) | 0x1;
14BF4  0EFC     MOVLW 0xFC
14BF8  FF8C     NOP
14BFA  F00C     NOP
14BFC  90D8     BCF 0xFD8, 0, ACCESS
14BFE  340C     RLCF 0xC, W, ACCESS
14C00  6E0B     MOVWF wtemp5, ACCESS
14C02  0E01     MOVLW 0x1
14C04  120B     IORWF wtemp5, F, ACCESS
14C06  0EFC     MOVLW 0xFC
14C0A  F02F     NOP
14C0C  FFE3     NOP
178:           			}
14C0E  D009     BRA 0x4C22
179:           			else {
180:           				grs <<= 1;
14C10  50E1     MOVF 0xFE1, W, ACCESS
14C12  0FFC     ADDLW 0xFC
14C14  6ED9     MOVWF 0xFD9, ACCESS
14C16  50E2     MOVF 0xFE2, W, ACCESS
14C18  6EDA     MOVWF 0xFDA, ACCESS
14C1A  0EFF     MOVLW 0xFF
14C1C  22DA     ADDWFC 0xFDA, F, ACCESS
14C1E  90D8     BCF 0xFD8, 0, ACCESS
14C20  36DF     RLCF 0xFDF, F, ACCESS
181:           			}
182:           			if (bexp) {
14C22  0EFD     MOVLW 0xFD
14C24  50E3     MOVF 0xFE3, W, ACCESS
14C26  B4D8     BTFSC 0xFD8, 2, ACCESS
14C28  D002     BRA 0x4C2E
183:           				--bexp;
14C2A  0EFD     MOVLW 0xFD
14C2C  06E3     DECF 0xFE3, F, ACCESS
184:           			}
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
14C34  0EFE     MOVLW 0xFE
14C36  6AE3     CLRF 0xFE3, ACCESS
193:           	if (grs & 0x80) {
14C38  0EFC     MOVLW 0xFC
14C3A  AEE3     BTFSS 0xFE3, 7, ACCESS
14C3C  D00F     BRA 0x4C5C
194:           		if (grs & 0x7f) {
14C3E  0EFC     MOVLW 0xFC
14C42  FF8C     NOP
14C44  F00C     NOP
14C46  0E7F     MOVLW 0x7F
14C48  160C     ANDWF 0xC, F, ACCESS
14C4A  B4D8     BTFSC 0xFD8, 2, ACCESS
14C4C  D004     BRA 0x4C56
195:           			aexp = 1;
14C4E  0EFE     MOVLW 0xFE
14C50  6AE3     CLRF 0xFE3, ACCESS
14C52  2AE3     INCF 0xFE3, F, ACCESS
196:           		}
14C54  D003     BRA 0x4C5C
197:           		else {
198:           			if (B_FRACTION.i & 1) {
14C56  0EF8     MOVLW 0xF8
14C58  B0E3     BTFSC 0xFE3, 0, ACCESS
14C5A  D7F9     BRA 0x4C4E
199:           				aexp = 1;
200:           			}
201:           		}
202:           	}
203:           	if (aexp) {
14C5C  0EFE     MOVLW 0xFE
14C5E  50E3     MOVF 0xFE3, W, ACCESS
14C60  B4D8     BTFSC 0xFD8, 2, ACCESS
14C62  D02B     BRA 0x4CBA
204:           		++B_FRACTION.i;
14C64  50E1     MOVF 0xFE1, W, ACCESS
14C66  0FF8     ADDLW 0xF8
14C68  6ED9     MOVWF 0xFD9, ACCESS
14C6A  50E2     MOVF 0xFE2, W, ACCESS
14C6C  6EDA     MOVWF 0xFDA, ACCESS
14C6E  0EFF     MOVLW 0xFF
14C70  22DA     ADDWFC 0xFDA, F, ACCESS
14C72  2ADE     INCF 0xFDE, F, ACCESS
14C74  0E00     MOVLW 0x0
14C76  22DE     ADDWFC 0xFDE, F, ACCESS
14C78  22DE     ADDWFC 0xFDE, F, ACCESS
14C7A  22DE     ADDWFC 0xFDE, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
14C7C  0EFB     MOVLW 0xFB
14C7E  A0E3     BTFSS 0xFE3, 0, ACCESS
14C80  D01C     BRA 0x4CBA
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
14C82  0E01     MOVLW 0x1
14C84  6E0C     MOVWF 0xC, ACCESS
14C86  50E1     MOVF 0xFE1, W, ACCESS
14C88  0FF8     ADDLW 0xF8
14C8A  6ED9     MOVWF 0xFD9, ACCESS
14C8C  50E2     MOVF 0xFE2, W, ACCESS
14C8E  6EDA     MOVWF 0xFDA, ACCESS
14C90  0EFF     MOVLW 0xFF
14C92  22DA     ADDWFC 0xFDA, F, ACCESS
14C94  280C     INCF 0xC, W, ACCESS
14C96  52DE     MOVF 0xFDE, F, ACCESS
14C98  D008     BRA 0x4CAA
14C9A  52DE     MOVF 0xFDE, F, ACCESS
14C9C  90D8     BCF 0xFD8, 0, ACCESS
14C9E  BEDC     BTFSC 0xFDC, 7, ACCESS
14CA0  80D8     BSF 0xFD8, 0, ACCESS
14CA2  32DD     RRCF 0xFDD, F, ACCESS
14CA4  32DD     RRCF 0xFDD, F, ACCESS
14CA6  32DD     RRCF 0xFDD, F, ACCESS
14CA8  32DE     RRCF 0xFDE, F, ACCESS
14CAA  2EE8     DECFSZ 0xFE8, F, ACCESS
14CAC  D7F6     BRA 0x4C9A
207:           			if (!(bexp == 0xFF)) {
14CAE  0EFD     MOVLW 0xFD
14CB0  28E3     INCF 0xFE3, W, ACCESS
14CB2  B4D8     BTFSC 0xFD8, 2, ACCESS
14CB4  D002     BRA 0x4CBA
208:           				++bexp;
14CB6  0EFD     MOVLW 0xFD
14CB8  2AE3     INCF 0xFE3, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
14CBA  0EFD     MOVLW 0xFD
14CBC  28E3     INCF 0xFE3, W, ACCESS
14CBE  B4D8     BTFSC 0xFD8, 2, ACCESS
14CC0  D004     BRA 0x4CCA
14CC2  0EFD     MOVLW 0xFD
14CC4  50E3     MOVF 0xFE3, W, ACCESS
14CC6  A4D8     BTFSS 0xFD8, 2, ACCESS
14CC8  D00E     BRA 0x4CE6
216:           		B_FRACTION.i = 0;
14CCA  0EF8     MOVLW 0xF8
14CCC  6AE3     CLRF 0xFE3, ACCESS
14CCE  0EF9     MOVLW 0xF9
14CD0  6AE3     CLRF 0xFE3, ACCESS
14CD2  0EFA     MOVLW 0xFA
14CD4  6AE3     CLRF 0xFE3, ACCESS
14CD6  0EFB     MOVLW 0xFB
14CD8  6AE3     CLRF 0xFE3, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
14CDA  0EFD     MOVLW 0xFD
14CDC  50E3     MOVF 0xFE3, W, ACCESS
14CDE  A4D8     BTFSS 0xFD8, 2, ACCESS
14CE0  D002     BRA 0x4CE6
219:           		        signs=0;
14CE2  0EFF     MOVLW 0xFF
14CE4  6AE3     CLRF 0xFE3, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
14CE6  0EFD     MOVLW 0xFD
14CE8  A0E3     BTFSS 0xFE3, 0, ACCESS
14CEA  D009     BRA 0x4CFE
226:           		B_FRACTION.fAsBytes.c |= 0x80;
14CEC  0EFA     MOVLW 0xFA
14CEE  24E1     ADDWF 0xFE1, W, ACCESS
14CF0  6ED9     MOVWF 0xFD9, ACCESS
14CF2  0EFF     MOVLW 0xFF
14CF4  20E2     ADDWFC 0xFE2, W, ACCESS
14CF6  6EDA     MOVWF 0xFDA, ACCESS
14CF8  0E00     MOVLW 0x0
14CFA  8EDB     BSF 0xFDB, 7, ACCESS
227:           	}
14CFC  D008     BRA 0x4D0E
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
14CFE  0EFA     MOVLW 0xFA
14D00  24E1     ADDWF 0xFE1, W, ACCESS
14D02  6ED9     MOVWF 0xFD9, ACCESS
14D04  0EFF     MOVLW 0xFF
14D06  20E2     ADDWFC 0xFE2, W, ACCESS
14D08  6EDA     MOVWF 0xFDA, ACCESS
14D0A  0E7F     MOVLW 0x7F
14D0C  16DF     ANDWF 0xFDF, F, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
14D0E  0EFB     MOVLW 0xFB
14D10  24E1     ADDWF 0xFE1, W, ACCESS
14D12  6ED9     MOVWF 0xFD9, ACCESS
14D14  0EFF     MOVLW 0xFF
14D16  20E2     ADDWFC 0xFE2, W, ACCESS
14D18  6EDA     MOVWF 0xFDA, ACCESS
14D1A  0EFD     MOVLW 0xFD
14D1E  FF8C     NOP
14D20  F00C     NOP
14D22  90D8     BCF 0xFD8, 0, ACCESS
14D24  300C     RRCF 0xC, W, ACCESS
14D26  6EDF     MOVWF 0xFDF, ACCESS
233:           	if (signs & 0x80) {
14D28  0EFF     MOVLW 0xFF
14D2A  AEE3     BTFSS 0xFE3, 7, ACCESS
14D2C  D008     BRA 0x4D3E
234:           		B_FRACTION.fAsBytes.d |= 0x80;
14D2E  0EFB     MOVLW 0xFB
14D30  24E1     ADDWF 0xFE1, W, ACCESS
14D32  6ED9     MOVWF 0xFD9, ACCESS
14D34  0EFF     MOVLW 0xFF
14D36  20E2     ADDWFC 0xFE2, W, ACCESS
14D38  6EDA     MOVWF 0xFDA, ACCESS
14D3A  0E00     MOVLW 0x0
14D3C  8EDB     BSF 0xFDB, 7, ACCESS
235:           	}
236:           	return b;
14D3E  0EF8     MOVLW 0xF8
14D42  FF8C     NOP
14D44  F001     NOP
14D46  0EF9     MOVLW 0xF9
14D4A  FF8C     NOP
14D4C  F002     NOP
14D4E  0EFA     MOVLW 0xFA
14D52  FF8C     NOP
14D54  F003     NOP
14D56  0EFB     MOVLW 0xFB
14D5A  FF8C     NOP
14D5C  F004     NOP
237:           }
14D5E  0EF4     MOVLW 0xF4
14D60  26E1     ADDWF 0xFE1, F, ACCESS
14D62  0EFF     MOVLW 0xFF
14D64  22E2     ADDWFC 0xFE2, F, ACCESS
14D66  0012     RETURN 0
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
1B57E  0EFB     MOVLW 0xFB
1B580  7EE3     BTG 0xFE3, 7, ACCESS
249:           	return __fladd(b, a);
1B582  0EF8     MOVLW 0xF8
1B586  FF8F     NOP
1B588  FFE6     NOP
1B58C  FF8F     NOP
1B58E  FFE6     NOP
1B592  FF8F     NOP
1B594  FFE6     NOP
1B598  FF8F     NOP
1B59A  FFE6     NOP
1B59C  0EF8     MOVLW 0xF8
1B5A0  FF8F     NOP
1B5A2  FFE6     NOP
1B5A6  FF8F     NOP
1B5A8  FFE6     NOP
1B5AC  FF8F     NOP
1B5AE  FFE6     NOP
1B5B2  FF8F     NOP
1B5B4  FFE6     NOP
1B5B6  ECD6     CALL 0x145AC, 0
1B5B8  F0A2     NOP
250:           }
1B5BA  0EF8     MOVLW 0xF8
1B5BC  26E1     ADDWF 0xFE1, F, ACCESS
1B5BE  0EFF     MOVLW 0xFF
1B5C0  22E2     ADDWFC 0xFE2, F, ACCESS
1B5C2  0012     RETURN 0
251:           
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/rand.c  --------------------------------------------
1:             #include <stdlib.h>
2:             #include <stdint.h>
3:             
4:             #if __SIZEOF_LONG_LONG__ == 4
5:             static uint32_t seed;
6:             #else
7:             static uint64_t seed;
8:             #endif
9:             
10:            void srand(unsigned s)
11:            {
12:            	seed = s-1;
1B8EA  0EFE     MOVLW 0xFE
1B8EC  50E3     MOVF 0xFE3, W, ACCESS
1B8EE  0FFF     ADDLW 0xFF
1B8F0  6E0B     MOVWF wtemp5, ACCESS
1B8F2  0EFF     MOVLW 0xFF
1B8F6  FF8C     NOP
1B8F8  F00C     NOP
1B8FA  0EFF     MOVLW 0xFF
1B8FC  220C     ADDWFC 0xC, F, ACCESS
1B900  F02C     NOP
1B902  F0CF     NOP
1B906  F030     NOP
1B908  F0D0     NOP
1B90A  0100     MOVLB 0x0
1B90C  6BD1     CLRF 0xD1, BANKED
1B90E  6BD2     CLRF 0xD2, BANKED
1B910  6BD3     CLRF 0xD3, BANKED
1B912  6BD4     CLRF 0xD4, BANKED
1B914  6BD5     CLRF 0xD5, BANKED
1B916  6BD6     CLRF 0xD6, BANKED
13:            }
1B918  52E5     MOVF 0xFE5, F, ACCESS
1B91A  52E5     MOVF 0xFE5, F, ACCESS
1B91C  0012     RETURN 0
14:            
15:            int rand(void)
16:            {
17:            #if __SIZEOF_LONG_LONG__ == 4
18:            	seed = 1284865837UL*seed + 1;
19:            #else
20:            	seed = 6364136223846793005ULL*seed + 1;
21:            #endif
22:            	return seed >> (((sizeof seed) * 8)- (sizeof(int)*8) + 1);
23:            }
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/printf.c  ------------------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
1B060  52E6     MOVF 0xFE6, F, ACCESS
1B062  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
1B064  0EFB     MOVLW 0xFB
1B066  24E1     ADDWF 0xFE1, W, ACCESS
1B068  6E0B     MOVWF wtemp5, ACCESS
1B06A  0EFF     MOVLW 0xFF
1B06C  20E2     ADDWFC 0xFE2, W, ACCESS
1B06E  6E0C     MOVWF 0xC, ACCESS
1B070  0EFF     MOVLW 0xFF
1B074  F033     NOP
1B076  FFE3     NOP
1B078  0EFE     MOVLW 0xFE
1B07C  F02F     NOP
1B07E  FFE3     NOP
10:            	ret = vfprintf(stdout, fmt, ap);
1B080  0EFE     MOVLW 0xFE
1B082  24E1     ADDWF 0xFE1, W, ACCESS
1B084  6E01     MOVWF ltemp0, ACCESS
1B086  0EFF     MOVLW 0xFF
1B088  20E2     ADDWFC 0xFE2, W, ACCESS
1B08A  6E02     MOVWF ttemp5, ACCESS
1B08E  F007     NOP
1B090  FFE6     NOP
1B094  F00B     NOP
1B096  FFE6     NOP
1B098  0EF9     MOVLW 0xF9
1B09C  FF8F     NOP
1B09E  FFE6     NOP
1B0A2  FF8F     NOP
1B0A4  FFE6     NOP
1B0A6  0E00     MOVLW 0x0
1B0A8  6EE6     MOVWF 0xFE6, ACCESS
1B0AA  0E00     MOVLW 0x0
1B0AC  6EE6     MOVWF 0xFE6, ACCESS
1B0AE  EC1D     CALL 0x1A63A, 0
1B0B0  F0D3     NOP
11:            	va_end(ap);
12:            	return ret;
13:            }
1B0B2  52E5     MOVF 0xFE5, F, ACCESS
1B0B4  52E5     MOVF 0xFE5, F, ACCESS
1B0B6  52E5     MOVF 0xFE5, F, ACCESS
1B0B8  50E7     MOVF 0xFE7, W, ACCESS
1B0BA  5EE1     SUBWF 0xFE1, F, ACCESS
1B0BC  0E00     MOVLW 0x0
1B0BE  5AE2     SUBWFB 0xFE2, F, ACCESS
1B0C0  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
19C00  0E08     MOVLW 0x8
19C02  26E1     ADDWF 0xFE1, F, ACCESS
19C04  0E00     MOVLW 0x0
19C06  22E2     ADDWFC 0xFE2, F, ACCESS
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
19C08  0EFE     MOVLW 0xFE
19C0A  6E0B     MOVWF wtemp5, ACCESS
19C0C  0EFF     MOVLW 0xFF
19C0E  6E0C     MOVWF 0xC, ACCESS
19C10  0EF5     MOVLW 0xF5
19C12  24E1     ADDWF 0xFE1, W, ACCESS
19C14  6E09     MOVWF ltemp2, ACCESS
19C16  0EFF     MOVLW 0xFF
19C18  20E2     ADDWFC 0xFE2, W, ACCESS
19C1A  6E0A     MOVWF ttemp3, ACCESS
19C1C  500B     MOVF wtemp5, W, ACCESS
19C1E  2609     ADDWF ltemp2, F, ACCESS
19C20  500C     MOVF 0xC, W, ACCESS
19C22  220A     ADDWFC ttemp3, F, ACCESS
19C24  0EFF     MOVLW 0xFF
19C28  F02B     NOP
19C2A  FFE3     NOP
19C2C  0EFE     MOVLW 0xFE
19C30  F027     NOP
19C32  FFE3     NOP
16:            	f.buffer = s;
19C34  0EF5     MOVLW 0xF5
19C38  FF8C     NOP
19C3A  F00B     NOP
19C3C  0EF6     MOVLW 0xF6
19C40  FF8C     NOP
19C42  F00C     NOP
19C44  0EF9     MOVLW 0xF9
19C48  F033     NOP
19C4A  FFE3     NOP
19C4C  0EF8     MOVLW 0xF8
19C50  F02F     NOP
19C52  FFE3     NOP
17:            	f.count = 0;
19C54  0EFA     MOVLW 0xFA
19C56  24E1     ADDWF 0xFE1, W, ACCESS
19C58  6ED9     MOVWF 0xFD9, ACCESS
19C5A  0EFF     MOVLW 0xFF
19C5C  20E2     ADDWFC 0xFE2, W, ACCESS
19C5E  6EDA     MOVWF 0xFDA, ACCESS
19C60  0E00     MOVLW 0x0
19C62  6EDE     MOVWF 0xFDE, ACCESS
19C64  0E00     MOVLW 0x0
19C66  6EDD     MOVWF 0xFDD, ACCESS
18:            	f.limit = 0;
19C68  0EFC     MOVLW 0xFC
19C6A  24E1     ADDWF 0xFE1, W, ACCESS
19C6C  6ED9     MOVWF 0xFD9, ACCESS
19C6E  0EFF     MOVLW 0xFF
19C70  20E2     ADDWFC 0xFE2, W, ACCESS
19C72  6EDA     MOVWF 0xFDA, ACCESS
19C74  0E00     MOVLW 0x0
19C76  6EDE     MOVWF 0xFDE, ACCESS
19C78  0E00     MOVLW 0x0
19C7A  6EDD     MOVWF 0xFDD, ACCESS
19:            	ret = vfprintf(&f, fmt, ap);
19C7C  0EFE     MOVLW 0xFE
19C7E  24E1     ADDWF 0xFE1, W, ACCESS
19C80  6E01     MOVWF ltemp0, ACCESS
19C82  0EFF     MOVLW 0xFF
19C84  20E2     ADDWFC 0xFE2, W, ACCESS
19C86  6E02     MOVWF ttemp5, ACCESS
19C8A  F007     NOP
19C8C  FFE6     NOP
19C90  F00B     NOP
19C92  FFE6     NOP
19C94  0EF1     MOVLW 0xF1
19C98  FF8F     NOP
19C9A  FFE6     NOP
19C9E  FF8F     NOP
19CA0  FFE6     NOP
19CA2  0EF4     MOVLW 0xF4
19CA4  24E1     ADDWF 0xFE1, W, ACCESS
19CA6  6E01     MOVWF ltemp0, ACCESS
19CA8  0EFF     MOVLW 0xFF
19CAA  20E2     ADDWFC 0xFE2, W, ACCESS
19CAC  6E02     MOVWF ttemp5, ACCESS
19CB0  F007     NOP
19CB2  FFE6     NOP
19CB6  F00B     NOP
19CB8  FFE6     NOP
19CBA  EC1D     CALL 0x1A63A, 0
19CBC  F0D3     NOP
20:            	s[f.count] = '\0';
19CBE  0EFA     MOVLW 0xFA
19CC0  24E1     ADDWF 0xFE1, W, ACCESS
19CC2  6ED9     MOVWF 0xFD9, ACCESS
19CC4  0EFF     MOVLW 0xFF
19CC6  20E2     ADDWFC 0xFE2, W, ACCESS
19CC8  6EDA     MOVWF 0xFDA, ACCESS
19CCC  FF78     NOP
19CCE  F00B     NOP
19CD2  FF74     NOP
19CD4  F00C     NOP
19CD6  0EF5     MOVLW 0xF5
19CDA  FF8C     NOP
19CDC  F009     NOP
19CDE  0EF6     MOVLW 0xF6
19CE2  FF8C     NOP
19CE4  F00A     NOP
19CE6  500B     MOVF wtemp5, W, ACCESS
19CE8  2409     ADDWF ltemp2, W, ACCESS
19CEA  6ED9     MOVWF 0xFD9, ACCESS
19CEC  500C     MOVF 0xC, W, ACCESS
19CEE  200A     ADDWFC ttemp3, W, ACCESS
19CF0  6EDA     MOVWF 0xFDA, ACCESS
19CF2  0E00     MOVLW 0x0
19CF4  6EDF     MOVWF 0xFDF, ACCESS
21:            	va_end(ap);
22:            	return ret;
23:            }
19CF6  0EF8     MOVLW 0xF8
19CF8  26E1     ADDWF 0xFE1, F, ACCESS
19CFA  0EFF     MOVLW 0xFF
19CFC  22E2     ADDWFC 0xFE2, F, ACCESS
19CFE  52E5     MOVF 0xFE5, F, ACCESS
19D00  50E7     MOVF 0xFE7, W, ACCESS
19D02  5EE1     SUBWF 0xFE1, F, ACCESS
19D04  0E00     MOVLW 0x0
19D06  5AE2     SUBWFB 0xFE2, F, ACCESS
19D08  0012     RETURN 0
24:            
25:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_fputs.c  ----------------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
1A980  52E6     MOVF 0xFE6, F, ACCESS
1A982  52E6     MOVF 0xFE6, F, ACCESS
1A984  52E6     MOVF 0xFE6, F, ACCESS
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
1A986  0EFD     MOVLW 0xFD
1A988  6AE3     CLRF 0xFE3, ACCESS
1A98A  0EFE     MOVLW 0xFE
1A98C  6AE3     CLRF 0xFE3, ACCESS
14:                while ((c = *(s + i))) {
1A98E  D01F     BRA 0xA9CE
1A9CE  0EFD     MOVLW 0xFD
1A9D2  FF8C     NOP
1A9D4  F00B     NOP
1A9D6  0EFE     MOVLW 0xFE
1A9DA  FF8C     NOP
1A9DC  F00C     NOP
1A9DE  0EFB     MOVLW 0xFB
1A9E2  FF8C     NOP
1A9E4  F009     NOP
1A9E6  0EFC     MOVLW 0xFC
1A9EA  FF8C     NOP
1A9EC  F00A     NOP
1A9EE  500B     MOVF wtemp5, W, ACCESS
1A9F0  2409     ADDWF ltemp2, W, ACCESS
1A9F2  6ED9     MOVWF 0xFD9, ACCESS
1A9F4  500C     MOVF 0xC, W, ACCESS
1A9F6  200A     ADDWFC ttemp3, W, ACCESS
1A9F8  6EDA     MOVWF 0xFDA, ACCESS
1A9FA  50DF     MOVF 0xFDF, W, ACCESS
1A9FC  6E0C     MOVWF 0xC, ACCESS
1A9FE  0EFF     MOVLW 0xFF
1AA02  F033     NOP
1AA04  FFE3     NOP
1AA06  0EFF     MOVLW 0xFF
1AA08  50E3     MOVF 0xFE3, W, ACCESS
1AA0A  A4D8     BTFSS 0xFD8, 2, ACCESS
1AA0C  D7C1     BRA 0xA990
15:            	fputc(c,fp);
1A990  0EF9     MOVLW 0xF9
1A994  FF8F     NOP
1A996  FFE6     NOP
1A99A  FF8F     NOP
1A99C  FFE6     NOP
1A99E  0EFD     MOVLW 0xFD
1A9A0  50E3     MOVF 0xFE3, W, ACCESS
1A9A2  6EE6     MOVWF 0xFE6, ACCESS
1A9A4  0E00     MOVLW 0x0
1A9A6  6EE6     MOVWF 0xFE6, ACCESS
1A9A8  ECD0     CALL 0x197A0, 0
1A9AA  F0CB     NOP
16:                    ++i;
1A9AC  0EFD     MOVLW 0xFD
1A9AE  50E3     MOVF 0xFE3, W, ACCESS
1A9B0  0F01     ADDLW 0x1
1A9B2  6E01     MOVWF ltemp0, ACCESS
1A9B4  0EFD     MOVLW 0xFD
1A9B8  F007     NOP
1A9BA  FFE3     NOP
1A9BC  6A01     CLRF ltemp0, ACCESS
1A9BE  0EFE     MOVLW 0xFE
1A9C0  50E3     MOVF 0xFE3, W, ACCESS
1A9C2  2001     ADDWFC ltemp0, W, ACCESS
1A9C4  6E01     MOVWF ltemp0, ACCESS
1A9C6  0EFE     MOVLW 0xFE
1A9CA  F007     NOP
1A9CC  FFE3     NOP
17:                }
18:                return i;
19:            }
1AA0E  0EF9     MOVLW 0xF9
1AA10  26E1     ADDWF 0xFE1, F, ACCESS
1AA12  0EFF     MOVLW 0xFF
1AA14  22E2     ADDWFC 0xFE2, F, ACCESS
1AA16  0012     RETURN 0
20:            
21:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
197A0  0EFC     MOVLW 0xFC
197A4  FF8C     NOP
197A6  F001     NOP
197A8  0EFD     MOVLW 0xFD
197AA  50E3     MOVF 0xFE3, W, ACCESS
197AC  1001     IORWF ltemp0, W, ACCESS
197AE  B4D8     BTFSC 0xFD8, 2, ACCESS
197B0  D009     BRA 0x97C4
197B2  0EFC     MOVLW 0xFC
197B6  FF8C     NOP
197B8  F001     NOP
197BA  0EFD     MOVLW 0xFD
197BC  50E3     MOVF 0xFE3, W, ACCESS
197BE  1001     IORWF ltemp0, W, ACCESS
197C0  A4D8     BTFSS 0xFD8, 2, ACCESS
197C2  D006     BRA 0x97D0
13:                    putch(c);
197C4  0EFE     MOVLW 0xFE
197C6  50E3     MOVF 0xFE3, W, ACCESS
197C8  6EE6     MOVWF 0xFE6, ACCESS
197CA  ECBD     CALL 0x1BF7A, 0
197CC  F0DF     NOP
14:                } else {
197CE  D075     BRA 0x98BA
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
197D0  0EFC     MOVLW 0xFC
197D4  FF8C     NOP
197D6  F00B     NOP
197D8  0EFD     MOVLW 0xFD
197DC  FF8C     NOP
197DE  F00C     NOP
197E0  0E04     MOVLW 0x4
197E2  240B     ADDWF wtemp5, W, ACCESS
197E4  6ED9     MOVWF 0xFD9, ACCESS
197E6  0E00     MOVLW 0x0
197E8  200C     ADDWFC 0xC, W, ACCESS
197EA  6EDA     MOVWF 0xFDA, ACCESS
197EC  50DE     MOVF 0xFDE, W, ACCESS
197EE  10DE     IORWF 0xFDE, W, ACCESS
197F0  B4D8     BTFSC 0xFD8, 2, ACCESS
197F2  D026     BRA 0x9840
197F4  0EFC     MOVLW 0xFC
197F8  FF8C     NOP
197FA  F00B     NOP
197FC  0EFD     MOVLW 0xFD
19800  FF8C     NOP
19802  F00C     NOP
19804  0E04     MOVLW 0x4
19806  240B     ADDWF wtemp5, W, ACCESS
19808  6ED9     MOVWF 0xFD9, ACCESS
1980A  0E00     MOVLW 0x0
1980C  200C     ADDWFC 0xC, W, ACCESS
1980E  6EDA     MOVWF 0xFDA, ACCESS
19810  0EFC     MOVLW 0xFC
19814  FF8C     NOP
19816  F00B     NOP
19818  0EFD     MOVLW 0xFD
1981C  FF8C     NOP
1981E  F00C     NOP
19820  0E02     MOVLW 0x2
19822  240B     ADDWF wtemp5, W, ACCESS
19824  6EE9     MOVWF 0xFE9, ACCESS
19826  0E00     MOVLW 0x0
19828  200C     ADDWFC 0xC, W, ACCESS
1982A  6EEA     MOVWF 0xFEA, ACCESS
1982C  50DE     MOVF 0xFDE, W, ACCESS
1982E  5CEE     SUBWF 0xFEE, W, ACCESS
19830  50EE     MOVF 0xFEE, W, ACCESS
19832  0A80     XORLW 0x80
19834  6E01     MOVWF ltemp0, ACCESS
19836  50DE     MOVF 0xFDE, W, ACCESS
19838  0A80     XORLW 0x80
1983A  5801     SUBWFB ltemp0, W, ACCESS
1983C  B0D8     BTFSC 0xFD8, 0, ACCESS
1983E  D03D     BRA 0x98BA
16:            	        fp->buffer[fp->count] = (char)c;
19840  0EFC     MOVLW 0xFC
19844  FF8C     NOP
19846  F00B     NOP
19848  0EFD     MOVLW 0xFD
1984C  FF8C     NOP
1984E  F00C     NOP
19850  0E02     MOVLW 0x2
19852  240B     ADDWF wtemp5, W, ACCESS
19854  6ED9     MOVWF 0xFD9, ACCESS
19856  0E00     MOVLW 0x0
19858  200C     ADDWFC 0xC, W, ACCESS
1985A  6EDA     MOVWF 0xFDA, ACCESS
1985E  FF78     NOP
19860  F00B     NOP
19864  FF74     NOP
19866  F00C     NOP
19868  0EFC     MOVLW 0xFC
1986C  FF8F     NOP
1986E  FFD9     NOP
19870  0EFD     MOVLW 0xFD
19874  FF8F     NOP
19876  FFDA     NOP
1987A  FF78     NOP
1987C  F009     NOP
19880  FF74     NOP
19882  F00A     NOP
19884  500B     MOVF wtemp5, W, ACCESS
19886  2409     ADDWF ltemp2, W, ACCESS
19888  6ED9     MOVWF 0xFD9, ACCESS
1988A  500C     MOVF 0xC, W, ACCESS
1988C  200A     ADDWFC ttemp3, W, ACCESS
1988E  6EDA     MOVWF 0xFDA, ACCESS
19890  0EFE     MOVLW 0xFE
19894  FF8F     NOP
19896  FFDF     NOP
17:            		++fp->count;
19898  0EFC     MOVLW 0xFC
1989C  FF8C     NOP
1989E  F00B     NOP
198A0  0EFD     MOVLW 0xFD
198A4  FF8C     NOP
198A6  F00C     NOP
198A8  0E02     MOVLW 0x2
198AA  240B     ADDWF wtemp5, W, ACCESS
198AC  6ED9     MOVWF 0xFD9, ACCESS
198AE  0E00     MOVLW 0x0
198B0  200C     ADDWFC 0xC, W, ACCESS
198B2  6EDA     MOVWF 0xFDA, ACCESS
198B4  2ADE     INCF 0xFDE, F, ACCESS
198B6  0E00     MOVLW 0x0
198B8  22DD     ADDWFC 0xFDD, F, ACCESS
18:            	}
19:                }
20:                return (unsigned char)c;
21:            }
198BA  52E5     MOVF 0xFE5, F, ACCESS
198BC  52E5     MOVF 0xFE5, F, ACCESS
198BE  52E5     MOVF 0xFE5, F, ACCESS
198C0  52E5     MOVF 0xFE5, F, ACCESS
198C2  0012     RETURN 0
22:            
23:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/nanf.c  --------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float nanf(const char *s)
1B0C2  52E6     MOVF 0xFE6, F, ACCESS
1B0C4  52E6     MOVF 0xFE6, F, ACCESS
1B0C6  52E6     MOVF 0xFE6, F, ACCESS
1B0C8  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u;
7:             	u.i = 0x7FFFFFFF;
1B0CA  0EFF     MOVLW 0xFF
1B0CC  6E09     MOVWF ltemp2, ACCESS
1B0CE  0EFF     MOVLW 0xFF
1B0D0  6E0A     MOVWF ttemp3, ACCESS
1B0D2  0EFF     MOVLW 0xFF
1B0D4  6E0B     MOVWF wtemp5, ACCESS
1B0D6  0E7F     MOVLW 0x7F
1B0D8  6E0C     MOVWF 0xC, ACCESS
1B0DA  0EFC     MOVLW 0xFC
1B0DE  F027     NOP
1B0E0  FFE3     NOP
1B0E2  0EFD     MOVLW 0xFD
1B0E6  F02B     NOP
1B0E8  FFE3     NOP
1B0EA  0EFE     MOVLW 0xFE
1B0EE  F02F     NOP
1B0F0  FFE3     NOP
1B0F2  0EFF     MOVLW 0xFF
1B0F6  F033     NOP
1B0F8  FFE3     NOP
8:             	return u.f;
1B0FA  0EFC     MOVLW 0xFC
1B0FE  FF8C     NOP
1B100  F001     NOP
1B102  0EFD     MOVLW 0xFD
1B106  FF8C     NOP
1B108  F002     NOP
1B10A  0EFE     MOVLW 0xFE
1B10E  FF8C     NOP
1B110  F003     NOP
1B112  0EFF     MOVLW 0xFF
1B116  FF8C     NOP
1B118  F004     NOP
9:             }
1B11A  0EFA     MOVLW 0xFA
1B11C  26E1     ADDWF 0xFE1, F, ACCESS
1B11E  0EFF     MOVLW 0xFF
1B120  22E2     ADDWFC 0xFE2, F, ACCESS
1B122  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/memset.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             void *memset(void *dest, int c, size_t n)
16E54  52E6     MOVF 0xFE6, F, ACCESS
16E56  52E6     MOVF 0xFE6, F, ACCESS
16E58  52E6     MOVF 0xFE6, F, ACCESS
16E5A  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	unsigned char *s = dest;
16E5C  0EFA     MOVLW 0xFA
16E60  FF8C     NOP
16E62  F00B     NOP
16E64  0EFB     MOVLW 0xFB
16E68  FF8C     NOP
16E6A  F00C     NOP
16E6C  0EFD     MOVLW 0xFD
16E70  F033     NOP
16E72  FFE3     NOP
16E74  0EFC     MOVLW 0xFC
16E78  F02F     NOP
16E7A  FFE3     NOP
7:             	size_t k;
8:             
9:             	/* Fill head and tail with minimal branching. Each
10:            	 * conditional ensures that all the subsequently used
11:            	 * offsets are well-defined and in the dest region. */
12:            
13:            	if (!n) return dest;
16E7C  0EF6     MOVLW 0xF6
16E80  FF8C     NOP
16E82  F001     NOP
16E84  0EF7     MOVLW 0xF7
16E86  50E3     MOVF 0xFE3, W, ACCESS
16E88  1001     IORWF ltemp0, W, ACCESS
16E8A  B4D8     BTFSC 0xFD8, 2, ACCESS
16E8C  D154     BRA 0x7136
14:            	s[0] = c;
16E8E  0EFC     MOVLW 0xFC
16E92  FF8F     NOP
16E94  FFD9     NOP
16E96  0EFD     MOVLW 0xFD
16E9A  FF8F     NOP
16E9C  FFDA     NOP
16E9E  0EF8     MOVLW 0xF8
16EA2  FF8F     NOP
16EA4  FFDF     NOP
15:            	s[n-1] = c;
16EA6  0EFC     MOVLW 0xFC
16EAA  FF8C     NOP
16EAC  F00B     NOP
16EAE  0EFD     MOVLW 0xFD
16EB2  FF8C     NOP
16EB4  F00C     NOP
16EB6  0EF6     MOVLW 0xF6
16EB8  50E3     MOVF 0xFE3, W, ACCESS
16EBA  260B     ADDWF wtemp5, F, ACCESS
16EBC  0EF7     MOVLW 0xF7
16EBE  50E3     MOVF 0xFE3, W, ACCESS
16EC0  220C     ADDWFC 0xC, F, ACCESS
16EC2  0EFF     MOVLW 0xFF
16EC4  240B     ADDWF wtemp5, W, ACCESS
16EC6  6ED9     MOVWF 0xFD9, ACCESS
16EC8  0EFF     MOVLW 0xFF
16ECA  200C     ADDWFC 0xC, W, ACCESS
16ECC  6EDA     MOVWF 0xFDA, ACCESS
16ECE  0EF8     MOVLW 0xF8
16ED2  FF8F     NOP
16ED4  FFDF     NOP
16:            	if (n <= 2) return dest;
16ED6  0EF7     MOVLW 0xF7
16ED8  50E3     MOVF 0xFE3, W, ACCESS
16EDA  E108     BNZ 0x6EEC
16EDC  0EF6     MOVLW 0xF6
16EE0  FF8C     NOP
16EE2  F001     NOP
16EE4  0E03     MOVLW 0x3
16EE6  5E01     SUBWF ltemp0, F, ACCESS
16EE8  A0D8     BTFSS 0xFD8, 0, ACCESS
16EEA  D125     BRA 0x7136
17:            	s[1] = c;
16EEC  0EFC     MOVLW 0xFC
16EF0  FF8C     NOP
16EF2  F00B     NOP
16EF4  0EFD     MOVLW 0xFD
16EF8  FF8C     NOP
16EFA  F00C     NOP
16EFC  0E01     MOVLW 0x1
16EFE  240B     ADDWF wtemp5, W, ACCESS
16F00  6ED9     MOVWF 0xFD9, ACCESS
16F02  0E00     MOVLW 0x0
16F04  200C     ADDWFC 0xC, W, ACCESS
16F06  6EDA     MOVWF 0xFDA, ACCESS
16F08  0EF8     MOVLW 0xF8
16F0C  FF8F     NOP
16F0E  FFDF     NOP
18:            	s[2] = c;
16F10  0EFC     MOVLW 0xFC
16F14  FF8C     NOP
16F16  F00B     NOP
16F18  0EFD     MOVLW 0xFD
16F1C  FF8C     NOP
16F1E  F00C     NOP
16F20  0E02     MOVLW 0x2
16F22  240B     ADDWF wtemp5, W, ACCESS
16F24  6ED9     MOVWF 0xFD9, ACCESS
16F26  0E00     MOVLW 0x0
16F28  200C     ADDWFC 0xC, W, ACCESS
16F2A  6EDA     MOVWF 0xFDA, ACCESS
16F2C  0EF8     MOVLW 0xF8
16F30  FF8F     NOP
16F32  FFDF     NOP
19:            	s[n-2] = c;
16F34  0EFC     MOVLW 0xFC
16F38  FF8C     NOP
16F3A  F00B     NOP
16F3C  0EFD     MOVLW 0xFD
16F40  FF8C     NOP
16F42  F00C     NOP
16F44  0EF6     MOVLW 0xF6
16F46  50E3     MOVF 0xFE3, W, ACCESS
16F48  260B     ADDWF wtemp5, F, ACCESS
16F4A  0EF7     MOVLW 0xF7
16F4C  50E3     MOVF 0xFE3, W, ACCESS
16F4E  220C     ADDWFC 0xC, F, ACCESS
16F50  0EFE     MOVLW 0xFE
16F52  240B     ADDWF wtemp5, W, ACCESS
16F54  6ED9     MOVWF 0xFD9, ACCESS
16F56  0EFF     MOVLW 0xFF
16F58  200C     ADDWFC 0xC, W, ACCESS
16F5A  6EDA     MOVWF 0xFDA, ACCESS
16F5C  0EF8     MOVLW 0xF8
16F60  FF8F     NOP
16F62  FFDF     NOP
20:            	s[n-3] = c;
16F64  0EFC     MOVLW 0xFC
16F68  FF8C     NOP
16F6A  F00B     NOP
16F6C  0EFD     MOVLW 0xFD
16F70  FF8C     NOP
16F72  F00C     NOP
16F74  0EF6     MOVLW 0xF6
16F76  50E3     MOVF 0xFE3, W, ACCESS
16F78  260B     ADDWF wtemp5, F, ACCESS
16F7A  0EF7     MOVLW 0xF7
16F7C  50E3     MOVF 0xFE3, W, ACCESS
16F7E  220C     ADDWFC 0xC, F, ACCESS
16F80  0EFD     MOVLW 0xFD
16F82  240B     ADDWF wtemp5, W, ACCESS
16F84  6ED9     MOVWF 0xFD9, ACCESS
16F86  0EFF     MOVLW 0xFF
16F88  200C     ADDWFC 0xC, W, ACCESS
16F8A  6EDA     MOVWF 0xFDA, ACCESS
16F8C  0EF8     MOVLW 0xF8
16F90  FF8F     NOP
16F92  FFDF     NOP
21:            	if (n <= 6) return dest;
16F94  0EF7     MOVLW 0xF7
16F96  50E3     MOVF 0xFE3, W, ACCESS
16F98  E108     BNZ 0x6FAA
16F9A  0EF6     MOVLW 0xF6
16F9E  FF8C     NOP
16FA0  F001     NOP
16FA2  0E07     MOVLW 0x7
16FA4  5E01     SUBWF ltemp0, F, ACCESS
16FA6  A0D8     BTFSS 0xFD8, 0, ACCESS
16FA8  D0C6     BRA 0x7136
22:            	s[3] = c;
16FAA  0EFC     MOVLW 0xFC
16FAE  FF8C     NOP
16FB0  F00B     NOP
16FB2  0EFD     MOVLW 0xFD
16FB6  FF8C     NOP
16FB8  F00C     NOP
16FBA  0E03     MOVLW 0x3
16FBC  240B     ADDWF wtemp5, W, ACCESS
16FBE  6ED9     MOVWF 0xFD9, ACCESS
16FC0  0E00     MOVLW 0x0
16FC2  200C     ADDWFC 0xC, W, ACCESS
16FC4  6EDA     MOVWF 0xFDA, ACCESS
16FC6  0EF8     MOVLW 0xF8
16FCA  FF8F     NOP
16FCC  FFDF     NOP
23:            	s[n-4] = c;
16FCE  0EFC     MOVLW 0xFC
16FD2  FF8C     NOP
16FD4  F00B     NOP
16FD6  0EFD     MOVLW 0xFD
16FDA  FF8C     NOP
16FDC  F00C     NOP
16FDE  0EF6     MOVLW 0xF6
16FE0  50E3     MOVF 0xFE3, W, ACCESS
16FE2  260B     ADDWF wtemp5, F, ACCESS
16FE4  0EF7     MOVLW 0xF7
16FE6  50E3     MOVF 0xFE3, W, ACCESS
16FE8  220C     ADDWFC 0xC, F, ACCESS
16FEA  0EFC     MOVLW 0xFC
16FEC  240B     ADDWF wtemp5, W, ACCESS
16FEE  6ED9     MOVWF 0xFD9, ACCESS
16FF0  0EFF     MOVLW 0xFF
16FF2  200C     ADDWFC 0xC, W, ACCESS
16FF4  6EDA     MOVWF 0xFDA, ACCESS
16FF6  0EF8     MOVLW 0xF8
16FFA  FF8F     NOP
16FFC  FFDF     NOP
24:            	if (n <= 8) return dest;
16FFE  0EF7     MOVLW 0xF7
17000  50E3     MOVF 0xFE3, W, ACCESS
17002  E108     BNZ 0x7014
17004  0EF6     MOVLW 0xF6
17008  FF8C     NOP
1700A  F001     NOP
1700C  0E09     MOVLW 0x9
1700E  5E01     SUBWF ltemp0, F, ACCESS
17010  A0D8     BTFSS 0xFD8, 0, ACCESS
17012  D091     BRA 0x7136
25:            
26:            	/* Advance pointer to align it at a 4-byte boundary,
27:            	 * and truncate n to a multiple of 4. The previous code
28:            	 * already took care of any head/tail that get cut off
29:            	 * by the alignment. */
30:            
31:            	k = -(uintptr_t)s & 3;
17014  0EFC     MOVLW 0xFC
17018  FF8C     NOP
1701A  F00B     NOP
1701C  1E0B     COMF wtemp5, F, ACCESS
1701E  0EFD     MOVLW 0xFD
17022  FF8C     NOP
17024  F00C     NOP
17026  1E0C     COMF 0xC, F, ACCESS
17028  2A0B     INCF wtemp5, F, ACCESS
1702A  B4D8     BTFSC 0xFD8, 2, ACCESS
1702C  2A0C     INCF 0xC, F, ACCESS
1702E  0E03     MOVLW 0x3
17030  160B     ANDWF wtemp5, F, ACCESS
17032  0E00     MOVLW 0x0
17034  160C     ANDWF 0xC, F, ACCESS
17036  0EFE     MOVLW 0xFE
1703A  F02F     NOP
1703C  FFE3     NOP
1703E  0EFF     MOVLW 0xFF
17042  F033     NOP
17044  FFE3     NOP
32:            	s += k;
17046  0EFC     MOVLW 0xFC
17048  50E3     MOVF 0xFE3, W, ACCESS
1704A  6E01     MOVWF ltemp0, ACCESS
1704C  0EFE     MOVLW 0xFE
1704E  50E3     MOVF 0xFE3, W, ACCESS
17050  2601     ADDWF ltemp0, F, ACCESS
17052  0EFC     MOVLW 0xFC
17056  F007     NOP
17058  FFE3     NOP
1705A  0EFD     MOVLW 0xFD
1705C  50E3     MOVF 0xFE3, W, ACCESS
1705E  6E01     MOVWF ltemp0, ACCESS
17060  0EFF     MOVLW 0xFF
17062  50E3     MOVF 0xFE3, W, ACCESS
17064  2201     ADDWFC ltemp0, F, ACCESS
17066  0EFD     MOVLW 0xFD
1706A  F007     NOP
1706C  FFE3     NOP
33:            	n -= k;
1706E  0EF6     MOVLW 0xF6
17070  50E3     MOVF 0xFE3, W, ACCESS
17072  6E01     MOVWF ltemp0, ACCESS
17074  0EFE     MOVLW 0xFE
17076  50E3     MOVF 0xFE3, W, ACCESS
17078  5E01     SUBWF ltemp0, F, ACCESS
1707A  0EF6     MOVLW 0xF6
1707E  F007     NOP
17080  FFE3     NOP
17082  0EF7     MOVLW 0xF7
17084  50E3     MOVF 0xFE3, W, ACCESS
17086  6E01     MOVWF ltemp0, ACCESS
17088  0EFF     MOVLW 0xFF
1708A  50E3     MOVF 0xFE3, W, ACCESS
1708C  5A01     SUBWFB ltemp0, F, ACCESS
1708E  0EF7     MOVLW 0xF7
17092  F007     NOP
17094  FFE3     NOP
34:            	n &= -4;
17096  0EFC     MOVLW 0xFC
17098  6E0B     MOVWF wtemp5, ACCESS
1709A  0EFF     MOVLW 0xFF
1709C  6E0C     MOVWF 0xC, ACCESS
1709E  0EF6     MOVLW 0xF6
170A2  FF8C     NOP
170A4  F001     NOP
170A6  500B     MOVF wtemp5, W, ACCESS
170A8  1601     ANDWF ltemp0, F, ACCESS
170AA  0EF6     MOVLW 0xF6
170AE  F007     NOP
170B0  FFE3     NOP
170B2  0EF7     MOVLW 0xF7
170B6  FF8C     NOP
170B8  F001     NOP
170BA  500C     MOVF 0xC, W, ACCESS
170BC  1601     ANDWF ltemp0, F, ACCESS
170BE  0EF7     MOVLW 0xF7
170C0  D02E     BRA 0x711E
35:            
36:            #ifdef __GNUC__
37:            	typedef uint32_t __attribute__((__may_alias__)) u32;
38:            	typedef uint64_t __attribute__((__may_alias__)) u64;
39:            
40:            	u32 c32 = ((u32)-1)/255 * (unsigned char)c;
41:            
42:            	/* In preparation to copy 32 bytes at a time, aligned on
43:            	 * an 8-byte bounary, fill head/tail up to 28 bytes each.
44:            	 * As in the initial byte-based head/tail fill, each
45:            	 * conditional below ensures that the subsequent offsets
46:            	 * are valid (e.g. !(n<=24) implies n>=28). */
47:            
48:            	*(u32 *)(s+0) = c32;
49:            	*(u32 *)(s+n-4) = c32;
50:            	if (n <= 8) return dest;
51:            	*(u32 *)(s+4) = c32;
52:            	*(u32 *)(s+8) = c32;
53:            	*(u32 *)(s+n-12) = c32;
54:            	*(u32 *)(s+n-8) = c32;
55:            	if (n <= 24) return dest;
56:            	*(u32 *)(s+12) = c32;
57:            	*(u32 *)(s+16) = c32;
58:            	*(u32 *)(s+20) = c32;
59:            	*(u32 *)(s+24) = c32;
60:            	*(u32 *)(s+n-28) = c32;
61:            	*(u32 *)(s+n-24) = c32;
62:            	*(u32 *)(s+n-20) = c32;
63:            	*(u32 *)(s+n-16) = c32;
64:            
65:            	/* Align to a multiple of 8 so we can fill 64 bits at a time,
66:            	 * and avoid writing the same bytes twice as much as is
67:            	 * practical without introducing additional branching. */
68:            
69:            	k = 24 + ((uintptr_t)s & 4);
70:            	s += k;
71:            	n -= k;
72:            
73:            	/* If this loop is reached, 28 tail bytes have already been
74:            	 * filled, so any remainder when n drops below 32 can be
75:            	 * safely ignored. */
76:            
77:            	u64 c64 = c32 | ((u64)c32 << 32);
78:            	for (; n >= 32; n-=32, s+=32) {
79:            		*(u64 *)(s+0) = c64;
80:            		*(u64 *)(s+8) = c64;
81:            		*(u64 *)(s+16) = c64;
82:            		*(u64 *)(s+24) = c64;
83:            	}
84:            #else
85:            	/* Pure C fallback with no aliasing violations. */
86:            	for (; n; n--, s++) *s = c;
170C2  0EFC     MOVLW 0xFC
170C6  FF8F     NOP
170C8  FFD9     NOP
170CA  0EFD     MOVLW 0xFD
170CE  FF8F     NOP
170D0  FFDA     NOP
170D2  0EF8     MOVLW 0xF8
170D6  FF8F     NOP
170D8  FFDF     NOP
170DA  0EF6     MOVLW 0xF6
170DE  FF8C     NOP
170E0  F001     NOP
170E2  0E01     MOVLW 0x1
170E4  5E01     SUBWF ltemp0, F, ACCESS
170E6  0EF6     MOVLW 0xF6
170EA  F007     NOP
170EC  FFE3     NOP
170EE  0EF7     MOVLW 0xF7
170F2  FF8C     NOP
170F4  F001     NOP
170F6  0E00     MOVLW 0x0
170F8  5A01     SUBWFB ltemp0, F, ACCESS
170FA  0EF7     MOVLW 0xF7
170FE  F007     NOP
17100  FFE3     NOP
17102  0EFC     MOVLW 0xFC
17104  50E3     MOVF 0xFE3, W, ACCESS
17106  0F01     ADDLW 0x1
17108  6E01     MOVWF ltemp0, ACCESS
1710A  0EFC     MOVLW 0xFC
1710E  F007     NOP
17110  FFE3     NOP
17112  6A01     CLRF ltemp0, ACCESS
17114  0EFD     MOVLW 0xFD
17116  50E3     MOVF 0xFE3, W, ACCESS
17118  2001     ADDWFC ltemp0, W, ACCESS
1711A  6E01     MOVWF ltemp0, ACCESS
1711C  0EFD     MOVLW 0xFD
17120  F007     NOP
17122  FFE3     NOP
17124  0EF6     MOVLW 0xF6
17128  FF8C     NOP
1712A  F001     NOP
1712C  0EF7     MOVLW 0xF7
1712E  50E3     MOVF 0xFE3, W, ACCESS
17130  1001     IORWF ltemp0, W, ACCESS
17132  A4D8     BTFSS 0xFD8, 2, ACCESS
17134  D7C6     BRA 0x70C2
87:            #endif
88:            
89:            	return dest;
90:            }
17136  0EF6     MOVLW 0xF6
17138  26E1     ADDWF 0xFE1, F, ACCESS
1713A  0EFF     MOVLW 0xFF
1713C  22E2     ADDWFC 0xFE2, F, ACCESS
1713E  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/lomod.c  -------------------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
193FC  52E6     MOVF 0xFE6, F, ACCESS
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
193FE  0EEF     MOVLW 0xEF
19400  50E3     MOVF 0xFE3, W, ACCESS
19402  E116     BNZ 0x9430
19404  0EF0     MOVLW 0xF0
19406  50E3     MOVF 0xFE3, W, ACCESS
19408  E113     BNZ 0x9430
1940A  0EF1     MOVLW 0xF1
1940C  50E3     MOVF 0xFE3, W, ACCESS
1940E  E110     BNZ 0x9430
19410  0EF2     MOVLW 0xF2
19412  50E3     MOVF 0xFE3, W, ACCESS
19414  E10D     BNZ 0x9430
19416  0EF3     MOVLW 0xF3
19418  50E3     MOVF 0xFE3, W, ACCESS
1941A  E10A     BNZ 0x9430
1941C  0EF4     MOVLW 0xF4
1941E  50E3     MOVF 0xFE3, W, ACCESS
19420  E107     BNZ 0x9430
19422  0EF5     MOVLW 0xF5
19424  50E3     MOVF 0xFE3, W, ACCESS
19426  E104     BNZ 0x9430
19428  0EF6     MOVLW 0xF6
1942A  50E3     MOVF 0xFE3, W, ACCESS
1942C  B4D8     BTFSC 0xFD8, 2, ACCESS
1942E  D075     BRA 0x951A
15:            		counter = 1;
19430  0EFF     MOVLW 0xFF
19432  6AE3     CLRF 0xFE3, ACCESS
19434  D012     BRA 0x945A
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
1945C  0EF6     MOVLW 0xF6
1945E  AEE3     BTFSS 0xFE3, 7, ACCESS
19460  D7EA     BRA 0x9436
17:            			divisor <<= 1;
19436  90D8     BCF 0xFD8, 0, ACCESS
19438  0EEF     MOVLW 0xEF
1943A  36E3     RLCF 0xFE3, F, ACCESS
1943C  0EF0     MOVLW 0xF0
1943E  36E3     RLCF 0xFE3, F, ACCESS
19440  0EF1     MOVLW 0xF1
19442  36E3     RLCF 0xFE3, F, ACCESS
19444  0EF2     MOVLW 0xF2
19446  36E3     RLCF 0xFE3, F, ACCESS
19448  0EF3     MOVLW 0xF3
1944A  36E3     RLCF 0xFE3, F, ACCESS
1944C  0EF4     MOVLW 0xF4
1944E  36E3     RLCF 0xFE3, F, ACCESS
19450  0EF5     MOVLW 0xF5
19452  36E3     RLCF 0xFE3, F, ACCESS
19454  0EF6     MOVLW 0xF6
19456  36E3     RLCF 0xFE3, F, ACCESS
18:            			counter++;
19458  0EFF     MOVLW 0xFF
1945A  2AE3     INCF 0xFE3, F, ACCESS
19:            		}
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
19462  50E1     MOVF 0xFE1, W, ACCESS
19464  0FF7     ADDLW 0xF7
19466  6ED9     MOVWF 0xFD9, ACCESS
19468  50E2     MOVF 0xFE2, W, ACCESS
1946A  6EDA     MOVWF 0xFDA, ACCESS
1946C  0EFF     MOVLW 0xFF
1946E  22DA     ADDWFC 0xFDA, F, ACCESS
19470  0EEF     MOVLW 0xEF
19472  50E3     MOVF 0xFE3, W, ACCESS
19474  5CDE     SUBWF 0xFDE, W, ACCESS
19476  0EF0     MOVLW 0xF0
19478  50E3     MOVF 0xFE3, W, ACCESS
1947A  58DE     SUBWFB 0xFDE, W, ACCESS
1947C  0EF1     MOVLW 0xF1
1947E  50E3     MOVF 0xFE3, W, ACCESS
19480  58DE     SUBWFB 0xFDE, W, ACCESS
19482  0EF2     MOVLW 0xF2
19484  50E3     MOVF 0xFE3, W, ACCESS
19486  58DE     SUBWFB 0xFDE, W, ACCESS
19488  0EF3     MOVLW 0xF3
1948A  50E3     MOVF 0xFE3, W, ACCESS
1948C  58DE     SUBWFB 0xFDE, W, ACCESS
1948E  0EF4     MOVLW 0xF4
19490  50E3     MOVF 0xFE3, W, ACCESS
19492  58DE     SUBWFB 0xFDE, W, ACCESS
19494  0EF5     MOVLW 0xF5
19496  50E3     MOVF 0xFE3, W, ACCESS
19498  58DE     SUBWFB 0xFDE, W, ACCESS
1949A  0EF6     MOVLW 0xF6
1949C  50E3     MOVF 0xFE3, W, ACCESS
1949E  58DE     SUBWFB 0xFDE, W, ACCESS
194A0  A0D8     BTFSS 0xFD8, 0, ACCESS
194A2  D01F     BRA 0x94E2
22:            				dividend -= divisor;
194A4  50E1     MOVF 0xFE1, W, ACCESS
194A6  0FF7     ADDLW 0xF7
194A8  6ED9     MOVWF 0xFD9, ACCESS
194AA  50E2     MOVF 0xFE2, W, ACCESS
194AC  6EDA     MOVWF 0xFDA, ACCESS
194AE  0EFF     MOVLW 0xFF
194B0  22DA     ADDWFC 0xFDA, F, ACCESS
194B2  0EEF     MOVLW 0xEF
194B4  50E3     MOVF 0xFE3, W, ACCESS
194B6  5EDE     SUBWF 0xFDE, F, ACCESS
194B8  0EF0     MOVLW 0xF0
194BA  50E3     MOVF 0xFE3, W, ACCESS
194BC  5ADE     SUBWFB 0xFDE, F, ACCESS
194BE  0EF1     MOVLW 0xF1
194C0  50E3     MOVF 0xFE3, W, ACCESS
194C2  5ADE     SUBWFB 0xFDE, F, ACCESS
194C4  0EF2     MOVLW 0xF2
194C6  50E3     MOVF 0xFE3, W, ACCESS
194C8  5ADE     SUBWFB 0xFDE, F, ACCESS
194CA  0EF3     MOVLW 0xF3
194CC  50E3     MOVF 0xFE3, W, ACCESS
194CE  5ADE     SUBWFB 0xFDE, F, ACCESS
194D0  0EF4     MOVLW 0xF4
194D2  50E3     MOVF 0xFE3, W, ACCESS
194D4  5ADE     SUBWFB 0xFDE, F, ACCESS
194D6  0EF5     MOVLW 0xF5
194D8  50E3     MOVF 0xFE3, W, ACCESS
194DA  5ADE     SUBWFB 0xFDE, F, ACCESS
194DC  0EF6     MOVLW 0xF6
194DE  50E3     MOVF 0xFE3, W, ACCESS
194E0  5ADE     SUBWFB 0xFDE, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
194E2  90D8     BCF 0xFD8, 0, ACCESS
194E4  0EF6     MOVLW 0xF6
194E6  32E3     RRCF 0xFE3, F, ACCESS
194E8  0EF5     MOVLW 0xF5
194EA  32E3     RRCF 0xFE3, F, ACCESS
194EC  0EF4     MOVLW 0xF4
194EE  32E3     RRCF 0xFE3, F, ACCESS
194F0  0EF3     MOVLW 0xF3
194F2  32E3     RRCF 0xFE3, F, ACCESS
194F4  0EF2     MOVLW 0xF2
194F6  32E3     RRCF 0xFE3, F, ACCESS
194F8  0EF1     MOVLW 0xF1
194FA  32E3     RRCF 0xFE3, F, ACCESS
194FC  0EF0     MOVLW 0xF0
194FE  32E3     RRCF 0xFE3, F, ACCESS
19500  0EEF     MOVLW 0xEF
19502  32E3     RRCF 0xFE3, F, ACCESS
24:            		} while(--counter != 0);
19504  0EFF     MOVLW 0xFF
19506  50E3     MOVF 0xFE3, W, ACCESS
19508  6E01     MOVWF ltemp0, ACCESS
1950A  0E01     MOVLW 0x1
1950C  5E01     SUBWF ltemp0, F, ACCESS
1950E  0EFF     MOVLW 0xFF
19512  F007     NOP
19514  FFE3     NOP
19516  A4D8     BTFSS 0xFD8, 2, ACCESS
19518  D7A4     BRA 0x9462
25:            	}
26:            	return dividend;
1951A  0EF7     MOVLW 0xF7
1951C  24E1     ADDWF 0xFE1, W, ACCESS
1951E  6ED9     MOVWF 0xFD9, ACCESS
19520  0EFF     MOVLW 0xFF
19522  20E2     ADDWFC 0xFE2, W, ACCESS
19524  6EDA     MOVWF 0xFDA, ACCESS
19526  0E08     MOVLW 0x8
19528  6E01     MOVWF ltemp0, ACCESS
1952A  0EF7     MOVLW 0xF7
1952E  FF7B     NOP
19530  FFE3     NOP
19532  28E8     INCF 0xFE8, W, ACCESS
19534  2E01     DECFSZ ltemp0, F, ACCESS
19536  D7FA     BRA 0x952C
27:            }
19538  52E5     MOVF 0xFE5, F, ACCESS
1953A  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/lodiv.c  -------------------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
18CF6  0E09     MOVLW 0x9
18CF8  26E1     ADDWF 0xFE1, F, ACCESS
18CFA  0E00     MOVLW 0x0
18CFC  22E2     ADDWFC 0xFE2, F, ACCESS
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
18CFE  0E07     MOVLW 0x7
18D00  6E01     MOVWF ltemp0, ACCESS
18D02  0EF7     MOVLW 0xF7
18D04  6AE3     CLRF 0xFE3, ACCESS
18D06  2AE8     INCF 0xFE8, F, ACCESS
18D08  0601     DECF ltemp0, F, ACCESS
18D0A  E2FC     BC 0x8D04
16:            	if(divisor != 0) {
18D0C  0EE7     MOVLW 0xE7
18D0E  50E3     MOVF 0xFE3, W, ACCESS
18D10  E116     BNZ 0x8D3E
18D12  0EE8     MOVLW 0xE8
18D14  50E3     MOVF 0xFE3, W, ACCESS
18D16  E113     BNZ 0x8D3E
18D18  0EE9     MOVLW 0xE9
18D1A  50E3     MOVF 0xFE3, W, ACCESS
18D1C  E110     BNZ 0x8D3E
18D1E  0EEA     MOVLW 0xEA
18D20  50E3     MOVF 0xFE3, W, ACCESS
18D22  E10D     BNZ 0x8D3E
18D24  0EEB     MOVLW 0xEB
18D26  50E3     MOVF 0xFE3, W, ACCESS
18D28  E10A     BNZ 0x8D3E
18D2A  0EEC     MOVLW 0xEC
18D2C  50E3     MOVF 0xFE3, W, ACCESS
18D2E  E107     BNZ 0x8D3E
18D30  0EED     MOVLW 0xED
18D32  50E3     MOVF 0xFE3, W, ACCESS
18D34  E104     BNZ 0x8D3E
18D36  0EEE     MOVLW 0xEE
18D38  50E3     MOVF 0xFE3, W, ACCESS
18D3A  B4D8     BTFSC 0xFD8, 2, ACCESS
18D3C  D088     BRA 0x8E4E
17:            		counter = 1;
18D3E  0EFF     MOVLW 0xFF
18D40  6AE3     CLRF 0xFE3, ACCESS
18D42  D012     BRA 0x8D68
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
18D6A  0EEE     MOVLW 0xEE
18D6C  AEE3     BTFSS 0xFE3, 7, ACCESS
18D6E  D7EA     BRA 0x8D44
19:            			divisor <<= 1;
18D44  90D8     BCF 0xFD8, 0, ACCESS
18D46  0EE7     MOVLW 0xE7
18D48  36E3     RLCF 0xFE3, F, ACCESS
18D4A  0EE8     MOVLW 0xE8
18D4C  36E3     RLCF 0xFE3, F, ACCESS
18D4E  0EE9     MOVLW 0xE9
18D50  36E3     RLCF 0xFE3, F, ACCESS
18D52  0EEA     MOVLW 0xEA
18D54  36E3     RLCF 0xFE3, F, ACCESS
18D56  0EEB     MOVLW 0xEB
18D58  36E3     RLCF 0xFE3, F, ACCESS
18D5A  0EEC     MOVLW 0xEC
18D5C  36E3     RLCF 0xFE3, F, ACCESS
18D5E  0EED     MOVLW 0xED
18D60  36E3     RLCF 0xFE3, F, ACCESS
18D62  0EEE     MOVLW 0xEE
18D64  36E3     RLCF 0xFE3, F, ACCESS
20:            			counter++;
18D66  0EFF     MOVLW 0xFF
18D68  2AE3     INCF 0xFE3, F, ACCESS
21:            		}
22:            		do {
23:            			quotient <<= 1;
18D70  90D8     BCF 0xFD8, 0, ACCESS
18D72  0EF7     MOVLW 0xF7
18D74  36E3     RLCF 0xFE3, F, ACCESS
18D76  0EF8     MOVLW 0xF8
18D78  36E3     RLCF 0xFE3, F, ACCESS
18D7A  0EF9     MOVLW 0xF9
18D7C  36E3     RLCF 0xFE3, F, ACCESS
18D7E  0EFA     MOVLW 0xFA
18D80  36E3     RLCF 0xFE3, F, ACCESS
18D82  0EFB     MOVLW 0xFB
18D84  36E3     RLCF 0xFE3, F, ACCESS
18D86  0EFC     MOVLW 0xFC
18D88  36E3     RLCF 0xFE3, F, ACCESS
18D8A  0EFD     MOVLW 0xFD
18D8C  36E3     RLCF 0xFE3, F, ACCESS
18D8E  0EFE     MOVLW 0xFE
18D90  36E3     RLCF 0xFE3, F, ACCESS
24:            			if(divisor <= dividend) {
18D92  50E1     MOVF 0xFE1, W, ACCESS
18D94  0FEF     ADDLW 0xEF
18D96  6ED9     MOVWF 0xFD9, ACCESS
18D98  50E2     MOVF 0xFE2, W, ACCESS
18D9A  6EDA     MOVWF 0xFDA, ACCESS
18D9C  0EFF     MOVLW 0xFF
18D9E  22DA     ADDWFC 0xFDA, F, ACCESS
18DA0  0EE7     MOVLW 0xE7
18DA2  50E3     MOVF 0xFE3, W, ACCESS
18DA4  5CDE     SUBWF 0xFDE, W, ACCESS
18DA6  0EE8     MOVLW 0xE8
18DA8  50E3     MOVF 0xFE3, W, ACCESS
18DAA  58DE     SUBWFB 0xFDE, W, ACCESS
18DAC  0EE9     MOVLW 0xE9
18DAE  50E3     MOVF 0xFE3, W, ACCESS
18DB0  58DE     SUBWFB 0xFDE, W, ACCESS
18DB2  0EEA     MOVLW 0xEA
18DB4  50E3     MOVF 0xFE3, W, ACCESS
18DB6  58DE     SUBWFB 0xFDE, W, ACCESS
18DB8  0EEB     MOVLW 0xEB
18DBA  50E3     MOVF 0xFE3, W, ACCESS
18DBC  58DE     SUBWFB 0xFDE, W, ACCESS
18DBE  0EEC     MOVLW 0xEC
18DC0  50E3     MOVF 0xFE3, W, ACCESS
18DC2  58DE     SUBWFB 0xFDE, W, ACCESS
18DC4  0EED     MOVLW 0xED
18DC6  50E3     MOVF 0xFE3, W, ACCESS
18DC8  58DE     SUBWFB 0xFDE, W, ACCESS
18DCA  0EEE     MOVLW 0xEE
18DCC  50E3     MOVF 0xFE3, W, ACCESS
18DCE  58DE     SUBWFB 0xFDE, W, ACCESS
18DD0  A0D8     BTFSS 0xFD8, 0, ACCESS
18DD2  D021     BRA 0x8E16
25:            				dividend -= divisor;
18DD4  50E1     MOVF 0xFE1, W, ACCESS
18DD6  0FEF     ADDLW 0xEF
18DD8  6ED9     MOVWF 0xFD9, ACCESS
18DDA  50E2     MOVF 0xFE2, W, ACCESS
18DDC  6EDA     MOVWF 0xFDA, ACCESS
18DDE  0EFF     MOVLW 0xFF
18DE0  22DA     ADDWFC 0xFDA, F, ACCESS
18DE2  0EE7     MOVLW 0xE7
18DE4  50E3     MOVF 0xFE3, W, ACCESS
18DE6  5EDE     SUBWF 0xFDE, F, ACCESS
18DE8  0EE8     MOVLW 0xE8
18DEA  50E3     MOVF 0xFE3, W, ACCESS
18DEC  5ADE     SUBWFB 0xFDE, F, ACCESS
18DEE  0EE9     MOVLW 0xE9
18DF0  50E3     MOVF 0xFE3, W, ACCESS
18DF2  5ADE     SUBWFB 0xFDE, F, ACCESS
18DF4  0EEA     MOVLW 0xEA
18DF6  50E3     MOVF 0xFE3, W, ACCESS
18DF8  5ADE     SUBWFB 0xFDE, F, ACCESS
18DFA  0EEB     MOVLW 0xEB
18DFC  50E3     MOVF 0xFE3, W, ACCESS
18DFE  5ADE     SUBWFB 0xFDE, F, ACCESS
18E00  0EEC     MOVLW 0xEC
18E02  50E3     MOVF 0xFE3, W, ACCESS
18E04  5ADE     SUBWFB 0xFDE, F, ACCESS
18E06  0EED     MOVLW 0xED
18E08  50E3     MOVF 0xFE3, W, ACCESS
18E0A  5ADE     SUBWFB 0xFDE, F, ACCESS
18E0C  0EEE     MOVLW 0xEE
18E0E  50E3     MOVF 0xFE3, W, ACCESS
18E10  5ADE     SUBWFB 0xFDE, F, ACCESS
26:            				quotient |= 1;
18E12  0EF7     MOVLW 0xF7
18E14  80E3     BSF 0xFE3, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
18E16  90D8     BCF 0xFD8, 0, ACCESS
18E18  0EEE     MOVLW 0xEE
18E1A  32E3     RRCF 0xFE3, F, ACCESS
18E1C  0EED     MOVLW 0xED
18E1E  32E3     RRCF 0xFE3, F, ACCESS
18E20  0EEC     MOVLW 0xEC
18E22  32E3     RRCF 0xFE3, F, ACCESS
18E24  0EEB     MOVLW 0xEB
18E26  32E3     RRCF 0xFE3, F, ACCESS
18E28  0EEA     MOVLW 0xEA
18E2A  32E3     RRCF 0xFE3, F, ACCESS
18E2C  0EE9     MOVLW 0xE9
18E2E  32E3     RRCF 0xFE3, F, ACCESS
18E30  0EE8     MOVLW 0xE8
18E32  32E3     RRCF 0xFE3, F, ACCESS
18E34  0EE7     MOVLW 0xE7
18E36  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
18E38  0EFF     MOVLW 0xFF
18E3A  50E3     MOVF 0xFE3, W, ACCESS
18E3C  6E01     MOVWF ltemp0, ACCESS
18E3E  0E01     MOVLW 0x1
18E40  5E01     SUBWF ltemp0, F, ACCESS
18E42  0EFF     MOVLW 0xFF
18E46  F007     NOP
18E48  FFE3     NOP
18E4A  A4D8     BTFSS 0xFD8, 2, ACCESS
18E4C  D791     BRA 0x8D70
30:            	}
31:            	return quotient;
18E4E  0EF7     MOVLW 0xF7
18E50  24E1     ADDWF 0xFE1, W, ACCESS
18E52  6ED9     MOVWF 0xFD9, ACCESS
18E54  0EFF     MOVLW 0xFF
18E56  20E2     ADDWFC 0xFE2, W, ACCESS
18E58  6EDA     MOVWF 0xFDA, ACCESS
18E5A  0E08     MOVLW 0x8
18E5C  6E01     MOVWF ltemp0, ACCESS
18E5E  0EEF     MOVLW 0xEF
18E62  FF7B     NOP
18E64  FFE3     NOP
18E66  28E8     INCF 0xFE8, W, ACCESS
18E68  2E01     DECFSZ ltemp0, F, ACCESS
18E6A  D7FA     BRA 0x8E60
32:            }
18E6C  0EF7     MOVLW 0xF7
18E6E  26E1     ADDWF 0xFE1, F, ACCESS
18E70  0EFF     MOVLW 0xFF
18E72  22E2     ADDWFC 0xFE2, F, ACCESS
18E74  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
1B9B2  0EFE     MOVLW 0xFE
1B9B4  50E3     MOVF 0xFE3, W, ACCESS
1B9B6  0FBF     ADDLW 0xBF
1B9B8  6E0B     MOVWF wtemp5, ACCESS
1B9BA  0EFF     MOVLW 0xFF
1B9BE  FF8C     NOP
1B9C0  F00C     NOP
1B9C2  0EFF     MOVLW 0xFF
1B9C4  220C     ADDWFC 0xC, F, ACCESS
1B9C6  500C     MOVF 0xC, W, ACCESS
1B9C8  E106     BNZ 0xB9D6
1B9CA  0E1A     MOVLW 0x1A
1B9CC  5C0B     SUBWF wtemp5, W, ACCESS
1B9CE  B0D8     BTFSC 0xFD8, 0, ACCESS
1B9D0  D002     BRA 0xB9D6
1B9D2  0E01     MOVLW 0x1
1B9D4  D001     BRA 0xB9D8
1B9D6  0E00     MOVLW 0x0
1B9D8  6E01     MOVWF ltemp0, ACCESS
1B9DA  6A02     CLRF ttemp5, ACCESS
8:             }
1B9DC  52E5     MOVF 0xFE5, F, ACCESS
1B9DE  52E5     MOVF 0xFE5, F, ACCESS
1B9E0  0012     RETURN 0
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isspace.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
1B292  52E6     MOVF 0xFE6, F, ACCESS
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
1B294  0EFF     MOVLW 0xFF
1B296  6AE3     CLRF 0xFE3, ACCESS
1B298  2AE3     INCF 0xFE3, F, ACCESS
1B29A  0EFD     MOVLW 0xFD
1B29E  FF8C     NOP
1B2A0  F001     NOP
1B2A2  0E20     MOVLW 0x20
1B2A4  1801     XORWF ltemp0, W, ACCESS
1B2A6  E104     BNZ 0xB2B0
1B2A8  0EFE     MOVLW 0xFE
1B2AA  50E3     MOVF 0xFE3, W, ACCESS
1B2AC  B4D8     BTFSC 0xFD8, 2, ACCESS
1B2AE  D012     BRA 0xB2D4
1B2B0  0EFD     MOVLW 0xFD
1B2B2  50E3     MOVF 0xFE3, W, ACCESS
1B2B4  0FF7     ADDLW 0xF7
1B2B6  6E0B     MOVWF wtemp5, ACCESS
1B2B8  0EFE     MOVLW 0xFE
1B2BC  FF8C     NOP
1B2BE  F00C     NOP
1B2C0  0EFF     MOVLW 0xFF
1B2C2  220C     ADDWFC 0xC, F, ACCESS
1B2C4  500C     MOVF 0xC, W, ACCESS
1B2C6  E104     BNZ 0xB2D0
1B2C8  0E05     MOVLW 0x5
1B2CA  5C0B     SUBWF wtemp5, W, ACCESS
1B2CC  A0D8     BTFSS 0xFD8, 0, ACCESS
1B2CE  D002     BRA 0xB2D4
1B2D0  0EFF     MOVLW 0xFF
1B2D2  6AE3     CLRF 0xFE3, ACCESS
1B2D4  0EFF     MOVLW 0xFF
1B2D6  50E3     MOVF 0xFE3, W, ACCESS
1B2D8  6E01     MOVWF ltemp0, ACCESS
1B2DA  6A02     CLRF ttemp5, ACCESS
8:             }
1B2DC  52E5     MOVF 0xFE5, F, ACCESS
1B2DE  52E5     MOVF 0xFE5, F, ACCESS
1B2E0  52E5     MOVF 0xFE5, F, ACCESS
1B2E2  0012     RETURN 0
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/islower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
1B982  0EFE     MOVLW 0xFE
1B984  50E3     MOVF 0xFE3, W, ACCESS
1B986  0F9F     ADDLW 0x9F
1B988  6E0B     MOVWF wtemp5, ACCESS
1B98A  0EFF     MOVLW 0xFF
1B98E  FF8C     NOP
1B990  F00C     NOP
1B992  0EFF     MOVLW 0xFF
1B994  220C     ADDWFC 0xC, F, ACCESS
1B996  500C     MOVF 0xC, W, ACCESS
1B998  E106     BNZ 0xB9A6
1B99A  0E1A     MOVLW 0x1A
1B99C  5C0B     SUBWF wtemp5, W, ACCESS
1B99E  B0D8     BTFSC 0xFD8, 0, ACCESS
1B9A0  D002     BRA 0xB9A6
1B9A2  0E01     MOVLW 0x1
1B9A4  D001     BRA 0xB9A8
1B9A6  0E00     MOVLW 0x0
1B9A8  6E01     MOVWF ltemp0, ACCESS
1B9AA  6A02     CLRF ttemp5, ACCESS
8:             }
1B9AC  52E5     MOVF 0xFE5, F, ACCESS
1B9AE  52E5     MOVF 0xFE5, F, ACCESS
1B9B0  0012     RETURN 0
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isdigit.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
1B9E2  0EFE     MOVLW 0xFE
1B9E4  50E3     MOVF 0xFE3, W, ACCESS
1B9E6  0FD0     ADDLW 0xD0
1B9E8  6E0B     MOVWF wtemp5, ACCESS
1B9EA  0EFF     MOVLW 0xFF
1B9EE  FF8C     NOP
1B9F0  F00C     NOP
1B9F2  0EFF     MOVLW 0xFF
1B9F4  220C     ADDWFC 0xC, F, ACCESS
1B9F6  500C     MOVF 0xC, W, ACCESS
1B9F8  E106     BNZ 0xBA06
1B9FA  0E0A     MOVLW 0xA
1B9FC  5C0B     SUBWF wtemp5, W, ACCESS
1B9FE  B0D8     BTFSC 0xFD8, 0, ACCESS
1BA00  D002     BRA 0xBA06
1BA02  0E01     MOVLW 0x1
1BA04  D001     BRA 0xBA08
1BA06  0E00     MOVLW 0x0
1BA08  6E01     MOVWF ltemp0, ACCESS
1BA0A  6A02     CLRF ttemp5, ACCESS
8:             }
1BA0C  52E5     MOVF 0xFE5, F, ACCESS
1BA0E  52E5     MOVF 0xFE5, F, ACCESS
1BA10  0012     RETURN 0
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/isalpha.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
1B5C4  0E9F     MOVLW 0x9F
1B5C6  6E0B     MOVWF wtemp5, ACCESS
1B5C8  0EFF     MOVLW 0xFF
1B5CA  6E0C     MOVWF 0xC, ACCESS
1B5CC  0EFE     MOVLW 0xFE
1B5D0  FF8C     NOP
1B5D2  F009     NOP
1B5D4  0EFF     MOVLW 0xFF
1B5D8  FF8C     NOP
1B5DA  F00A     NOP
1B5DC  0E20     MOVLW 0x20
1B5DE  1209     IORWF ltemp2, F, ACCESS
1B5E0  0E00     MOVLW 0x0
1B5E2  120A     IORWF ttemp3, F, ACCESS
1B5E4  500B     MOVF wtemp5, W, ACCESS
1B5E6  2609     ADDWF ltemp2, F, ACCESS
1B5E8  500C     MOVF 0xC, W, ACCESS
1B5EA  220A     ADDWFC ttemp3, F, ACCESS
1B5EC  500A     MOVF ttemp3, W, ACCESS
1B5EE  E106     BNZ 0xB5FC
1B5F0  0E1A     MOVLW 0x1A
1B5F2  5C09     SUBWF ltemp2, W, ACCESS
1B5F4  B0D8     BTFSC 0xFD8, 0, ACCESS
1B5F6  D002     BRA 0xB5FC
1B5F8  0E01     MOVLW 0x1
1B5FA  D001     BRA 0xB5FE
1B5FC  0E00     MOVLW 0x0
1B5FE  6E01     MOVWF ltemp0, ACCESS
1B600  6A02     CLRF ttemp5, ACCESS
8:             }
1B602  52E5     MOVF 0xFE5, F, ACCESS
1B604  52E5     MOVF 0xFE5, F, ACCESS
1B606  0012     RETURN 0
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fltol.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
18E76  52E6     MOVF 0xFE6, F, ACCESS
18E78  52E6     MOVF 0xFE6, F, ACCESS
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
18E7A  0EFA     MOVLW 0xFA
18E7E  FF8C     NOP
18E80  F009     NOP
18E82  0EFB     MOVLW 0xFB
18E86  FF8C     NOP
18E88  F00A     NOP
18E8A  0EFC     MOVLW 0xFC
18E8E  FF8C     NOP
18E90  F00B     NOP
18E92  0EFD     MOVLW 0xFD
18E96  FF8C     NOP
18E98  F00C     NOP
18E9A  0E18     MOVLW 0x18
18E9C  D005     BRA 0x8EA8
18E9E  90D8     BCF 0xFD8, 0, ACCESS
18EA0  320C     RRCF 0xC, F, ACCESS
18EA2  320B     RRCF wtemp5, F, ACCESS
18EA4  320A     RRCF ttemp3, F, ACCESS
18EA6  3209     RRCF ltemp2, F, ACCESS
18EA8  2EE8     DECFSZ 0xFE8, F, ACCESS
18EAA  D7F9     BRA 0x8E9E
18EAC  0EFE     MOVLW 0xFE
18EB0  F027     NOP
18EB2  FFE3     NOP
18EB4  0EFE     MOVLW 0xFE
18EB6  50E3     MOVF 0xFE3, W, ACCESS
18EB8  A4D8     BTFSS 0xFD8, 2, ACCESS
18EBA  D006     BRA 0x8EC8
48:            		return 0;
18EBC  0E00     MOVLW 0x0
18EBE  6E01     MOVWF ltemp0, ACCESS
18EC0  6A02     CLRF ttemp5, ACCESS
18EC2  6A03     CLRF wtemp1, ACCESS
18EC4  6A04     CLRF ttemp1, ACCESS
18EC6  D08B     BRA 0x8FDE
49:            	sign1 = f1_as_mant1 >> 31;
18EC8  0EFA     MOVLW 0xFA
18ECC  FF8C     NOP
18ECE  F009     NOP
18ED0  0EFB     MOVLW 0xFB
18ED4  FF8C     NOP
18ED6  F00A     NOP
18ED8  0EFC     MOVLW 0xFC
18EDC  FF8C     NOP
18EDE  F00B     NOP
18EE0  0EFD     MOVLW 0xFD
18EE4  FF8C     NOP
18EE6  F00C     NOP
18EE8  0E20     MOVLW 0x20
18EEA  D005     BRA 0x8EF6
18EEC  90D8     BCF 0xFD8, 0, ACCESS
18EEE  320C     RRCF 0xC, F, ACCESS
18EF0  320B     RRCF wtemp5, F, ACCESS
18EF2  320A     RRCF ttemp3, F, ACCESS
18EF4  3209     RRCF ltemp2, F, ACCESS
18EF6  2EE8     DECFSZ 0xFE8, F, ACCESS
18EF8  D7F9     BRA 0x8EEC
18EFA  0EFF     MOVLW 0xFF
18EFE  F027     NOP
18F00  FFE3     NOP
50:            	f1_as_mant1 |= 0x800000UL;
18F02  0EFC     MOVLW 0xFC
18F04  8EE3     BSF 0xFE3, 7, ACCESS
51:            	f1_as_mant1 &= 0xFFFFFFUL;
18F06  50E1     MOVF 0xFE1, W, ACCESS
18F08  0FFA     ADDLW 0xFA
18F0A  6ED9     MOVWF 0xFD9, ACCESS
18F0C  50E2     MOVF 0xFE2, W, ACCESS
18F0E  6EDA     MOVWF 0xFDA, ACCESS
18F10  0EFF     MOVLW 0xFF
18F12  22DA     ADDWFC 0xFDA, F, ACCESS
18F14  0EFF     MOVLW 0xFF
18F16  16DE     ANDWF 0xFDE, F, ACCESS
18F18  0EFF     MOVLW 0xFF
18F1A  16DE     ANDWF 0xFDE, F, ACCESS
18F1C  0EFF     MOVLW 0xFF
18F1E  16DE     ANDWF 0xFDE, F, ACCESS
18F20  0E00     MOVLW 0x0
18F22  16DE     ANDWF 0xFDE, F, ACCESS
52:            	exp1 -= 127+23;
18F24  0EFE     MOVLW 0xFE
18F28  FF8C     NOP
18F2A  F001     NOP
18F2C  0E96     MOVLW 0x96
18F2E  5E01     SUBWF ltemp0, F, ACCESS
18F30  0EFE     MOVLW 0xFE
18F34  F007     NOP
18F36  FFE3     NOP
53:            	if((signed char)exp1 < 0) {
18F38  0EFE     MOVLW 0xFE
18F3A  AEE3     BTFSS 0xFE3, 7, ACCESS
18F3C  D014     BRA 0x8F66
54:            		if((signed char)exp1 < -23)
18F3E  0EFE     MOVLW 0xFE
18F40  50E3     MOVF 0xFE3, W, ACCESS
18F42  0A80     XORLW 0x80
18F44  0F97     ADDLW 0x97
18F46  A0D8     BTFSS 0xFD8, 0, ACCESS
18F48  D7B9     BRA 0x8EBC
55:            			return 0;
56:            		do
57:            			f1_as_mant1 >>= 1;
18F4A  90D8     BCF 0xFD8, 0, ACCESS
18F4C  0EFD     MOVLW 0xFD
18F4E  32E3     RRCF 0xFE3, F, ACCESS
18F50  0EFC     MOVLW 0xFC
18F52  32E3     RRCF 0xFE3, F, ACCESS
18F54  0EFB     MOVLW 0xFB
18F56  32E3     RRCF 0xFE3, F, ACCESS
18F58  0EFA     MOVLW 0xFA
18F5A  32E3     RRCF 0xFE3, F, ACCESS
18F5C  0EFE     MOVLW 0xFE
18F5E  2AE3     INCF 0xFE3, F, ACCESS
18F60  B4D8     BTFSC 0xFD8, 2, ACCESS
18F62  D018     BRA 0x8F94
18F64  D7F2     BRA 0x8F4A
58:            		while(++exp1 != 0);
59:            	} else {
60:            		if(exp1 >= 32)
18F66  0EFE     MOVLW 0xFE
18F6A  FF8C     NOP
18F6C  F001     NOP
18F6E  0E1F     MOVLW 0x1F
18F70  6401     CPFSGT ltemp0, ACCESS
18F72  D00C     BRA 0x8F8C
18F74  D7A3     BRA 0x8EBC
61:            			return 00;
62:            		while(exp1 != 0) {
18F8C  0EFE     MOVLW 0xFE
18F8E  50E3     MOVF 0xFE3, W, ACCESS
18F90  A4D8     BTFSS 0xFD8, 2, ACCESS
18F92  D7F1     BRA 0x8F76
63:            			f1_as_mant1 <<= 1;
18F76  90D8     BCF 0xFD8, 0, ACCESS
18F78  0EFA     MOVLW 0xFA
18F7A  36E3     RLCF 0xFE3, F, ACCESS
18F7C  0EFB     MOVLW 0xFB
18F7E  36E3     RLCF 0xFE3, F, ACCESS
18F80  0EFC     MOVLW 0xFC
18F82  36E3     RLCF 0xFE3, F, ACCESS
18F84  0EFD     MOVLW 0xFD
18F86  36E3     RLCF 0xFE3, F, ACCESS
64:            			exp1--;
18F88  0EFE     MOVLW 0xFE
18F8A  06E3     DECF 0xFE3, F, ACCESS
65:            		}
66:            	}
67:            	if(sign1)
18F94  0EFF     MOVLW 0xFF
18F96  50E3     MOVF 0xFE3, W, ACCESS
18F98  B4D8     BTFSC 0xFD8, 2, ACCESS
18F9A  D011     BRA 0x8FBE
68:            		f1_as_mant1 = -f1_as_mant1;
18F9C  0EFA     MOVLW 0xFA
18F9E  6CE3     NEGF 0xFE3, ACCESS
18FA0  0EFB     MOVLW 0xFB
18FA2  1EE3     COMF 0xFE3, F, ACCESS
18FA4  0EFC     MOVLW 0xFC
18FA6  1EE3     COMF 0xFE3, F, ACCESS
18FA8  0EFD     MOVLW 0xFD
18FAA  1EE3     COMF 0xFE3, F, ACCESS
18FAC  E308     BNC 0x8FBE
18FAE  0EFB     MOVLW 0xFB
18FB0  2AE3     INCF 0xFE3, F, ACCESS
18FB2  E305     BNC 0x8FBE
18FB4  0EFC     MOVLW 0xFC
18FB6  2AE3     INCF 0xFE3, F, ACCESS
18FB8  E302     BNC 0x8FBE
18FBA  0EFD     MOVLW 0xFD
18FBC  2AE3     INCF 0xFE3, F, ACCESS
69:            	return f1_as_mant1;
18FBE  0EFA     MOVLW 0xFA
18FC2  FF8C     NOP
18FC4  F001     NOP
18FC6  0EFB     MOVLW 0xFB
18FCA  FF8C     NOP
18FCC  F002     NOP
18FCE  0EFC     MOVLW 0xFC
18FD2  FF8C     NOP
18FD4  F003     NOP
18FD6  0EFD     MOVLW 0xFD
18FDA  FF8C     NOP
18FDC  F004     NOP
70:            }
18FDE  0EFA     MOVLW 0xFA
18FE0  26E1     ADDWF 0xFE1, F, ACCESS
18FE2  0EFF     MOVLW 0xFF
18FE4  22E2     ADDWFC 0xFE2, F, ACCESS
18FE6  0012     RETURN 0
71:            #endif
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/floorf.c  ------------------------------------------
1:             #include "libm.h"
2:             
3:             float floorf(float x)
1647C  0E0A     MOVLW 0xA
1647E  26E1     ADDWF 0xFE1, F, ACCESS
16480  0E00     MOVLW 0x0
16482  22E2     ADDWFC 0xFE2, F, ACCESS
4:             {
5:             	union {float f; uint32_t i;} u = {x};
16486  F1E8     NOP
16488  F009     NOP
1648C  F1EC     NOP
1648E  F00A     NOP
16492  F1F0     NOP
16494  F00B     NOP
16498  F1F4     NOP
1649A  F00C     NOP
1649C  0EF6     MOVLW 0xF6
164A0  F027     NOP
164A2  FFE3     NOP
164A4  0EF7     MOVLW 0xF7
164A8  F02B     NOP
164AA  FFE3     NOP
164AC  0EF8     MOVLW 0xF8
164B0  F02F     NOP
164B2  FFE3     NOP
164B4  0EF9     MOVLW 0xF9
164B8  F033     NOP
164BA  FFE3     NOP
164BC  0EF2     MOVLW 0xF2
164C0  FF8C     NOP
164C2  F009     NOP
164C4  0EF3     MOVLW 0xF3
164C8  FF8C     NOP
164CA  F00A     NOP
164CC  0EF4     MOVLW 0xF4
164D0  FF8C     NOP
164D2  F00B     NOP
164D4  0EF5     MOVLW 0xF5
164D8  FF8C     NOP
164DA  F00C     NOP
164DC  0EF6     MOVLW 0xF6
164E0  F027     NOP
164E2  FFE3     NOP
164E4  0EF7     MOVLW 0xF7
164E8  F02B     NOP
164EA  FFE3     NOP
164EC  0EF8     MOVLW 0xF8
164F0  F02F     NOP
164F2  FFE3     NOP
164F4  0EF9     MOVLW 0xF9
164F8  F033     NOP
164FA  FFE3     NOP
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f;
164FC  0E81     MOVLW 0x81
164FE  6E0B     MOVWF wtemp5, ACCESS
16500  0EFF     MOVLW 0xFF
16502  6E0C     MOVWF 0xC, ACCESS
16504  0EF6     MOVLW 0xF6
16508  FF8C     NOP
1650A  F005     NOP
1650C  0EF7     MOVLW 0xF7
16510  FF8C     NOP
16512  F006     NOP
16514  0EF8     MOVLW 0xF8
16518  FF8C     NOP
1651A  F007     NOP
1651C  0EF9     MOVLW 0xF9
16520  FF8C     NOP
16522  F008     NOP
16524  0E18     MOVLW 0x18
16526  D005     BRA 0x6532
16528  90D8     BCF 0xFD8, 0, ACCESS
1652A  3208     RRCF 0x8, F, ACCESS
1652C  3207     RRCF ttemp2, F, ACCESS
1652E  3206     RRCF 0x6, F, ACCESS
16530  3205     RRCF ltemp1, F, ACCESS
16532  2EE8     DECFSZ 0xFE8, F, ACCESS
16534  D7F9     BRA 0x6528
16538  F014     NOP
1653A  F009     NOP
1653E  F018     NOP
16540  F00A     NOP
16542  0EFF     MOVLW 0xFF
16544  1609     ANDWF ltemp2, F, ACCESS
16546  0E00     MOVLW 0x0
16548  160A     ANDWF ttemp3, F, ACCESS
1654A  500B     MOVF wtemp5, W, ACCESS
1654C  2609     ADDWF ltemp2, F, ACCESS
1654E  500C     MOVF 0xC, W, ACCESS
16550  220A     ADDWFC ttemp3, F, ACCESS
16552  0EFE     MOVLW 0xFE
16556  F027     NOP
16558  FFE3     NOP
1655A  0EFF     MOVLW 0xFF
1655E  F02B     NOP
16560  FFE3     NOP
7:             	uint32_t m;
8:             
9:             	if (e >= 23)
16562  0EFF     MOVLW 0xFF
16564  BEE3     BTFSC 0xFE3, 7, ACCESS
16566  D019     BRA 0x659A
16568  0EFF     MOVLW 0xFF
1656A  50E3     MOVF 0xFE3, W, ACCESS
1656C  E108     BNZ 0x657E
1656E  0EFE     MOVLW 0xFE
16572  FF8C     NOP
16574  F001     NOP
16576  0E17     MOVLW 0x17
16578  5E01     SUBWF ltemp0, F, ACCESS
1657A  A0D8     BTFSS 0xFD8, 0, ACCESS
1657C  D00E     BRA 0x659A
10:            		return x;
1657E  0EF2     MOVLW 0xF2
16582  FF8C     NOP
16584  F001     NOP
16586  0EF3     MOVLW 0xF3
1658A  FF8C     NOP
1658C  F002     NOP
1658E  0EF4     MOVLW 0xF4
16592  FF8C     NOP
16594  F003     NOP
16596  0EF5     MOVLW 0xF5
16598  D11F     BRA 0x67D8
11:            	if (e >= 0) {
1659A  0EFF     MOVLW 0xFF
1659C  BEE3     BTFSC 0xFE3, 7, ACCESS
1659E  D0B4     BRA 0x6708
12:            		m = 0x007fffff >> e;
165A0  0EFE     MOVLW 0xFE
165A4  FF8C     NOP
165A6  F00C     NOP
165A8  0EFF     MOVLW 0xFF
165AA  6E05     MOVWF ltemp1, ACCESS
165AC  0EFF     MOVLW 0xFF
165AE  6E06     MOVWF 0x6, ACCESS
165B0  0E7F     MOVLW 0x7F
165B2  6E07     MOVWF ttemp2, ACCESS
165B4  0E00     MOVLW 0x0
165B6  6E08     MOVWF 0x8, ACCESS
165B8  660C     TSTFSZ 0xC, ACCESS
165BA  D001     BRA 0x65BE
165BC  D007     BRA 0x65CC
165BE  3408     RLCF 0x8, W, ACCESS
165C0  3208     RRCF 0x8, F, ACCESS
165C2  3207     RRCF ttemp2, F, ACCESS
165C4  3206     RRCF 0x6, F, ACCESS
165C6  3205     RRCF ltemp1, F, ACCESS
165C8  2E0C     DECFSZ 0xC, F, ACCESS
165CA  D7F6     BRA 0x65B8
165CC  0EFA     MOVLW 0xFA
165D0  F017     NOP
165D2  FFE3     NOP
165D4  0EFB     MOVLW 0xFB
165D8  F01B     NOP
165DA  FFE3     NOP
165DC  0EFC     MOVLW 0xFC
165E0  F01F     NOP
165E2  FFE3     NOP
165E4  0EFD     MOVLW 0xFD
165E8  F023     NOP
165EA  FFE3     NOP
13:            		if ((u.i & m) == 0)
165EC  0EF6     MOVLW 0xF6
165F0  FF8C     NOP
165F2  F009     NOP
165F4  0EF7     MOVLW 0xF7
165F8  FF8C     NOP
165FA  F00A     NOP
165FC  0EF8     MOVLW 0xF8
16600  FF8C     NOP
16602  F00B     NOP
16604  0EF9     MOVLW 0xF9
16608  FF8C     NOP
1660A  F00C     NOP
1660C  0EFA     MOVLW 0xFA
1660E  50E3     MOVF 0xFE3, W, ACCESS
16610  1609     ANDWF ltemp2, F, ACCESS
16612  0EFB     MOVLW 0xFB
16614  50E3     MOVF 0xFE3, W, ACCESS
16616  160A     ANDWF ttemp3, F, ACCESS
16618  0EFC     MOVLW 0xFC
1661A  50E3     MOVF 0xFE3, W, ACCESS
1661C  160B     ANDWF wtemp5, F, ACCESS
1661E  0EFD     MOVLW 0xFD
16620  50E3     MOVF 0xFE3, W, ACCESS
16622  160C     ANDWF 0xC, F, ACCESS
16624  5009     MOVF ltemp2, W, ACCESS
16626  100A     IORWF ttemp3, W, ACCESS
16628  100B     IORWF wtemp5, W, ACCESS
1662A  100C     IORWF 0xC, W, ACCESS
1662C  B4D8     BTFSC 0xFD8, 2, ACCESS
1662E  D7A7     BRA 0x657E
14:            			return x;
15:            		FORCE_EVAL(x + 0x1p120f);
16:            		if (u.i >> 31)
16630  0EF6     MOVLW 0xF6
16634  FF8C     NOP
16636  F009     NOP
16638  0EF7     MOVLW 0xF7
1663C  FF8C     NOP
1663E  F00A     NOP
16640  0EF8     MOVLW 0xF8
16644  FF8C     NOP
16646  F00B     NOP
16648  0EF9     MOVLW 0xF9
1664C  FF8C     NOP
1664E  F00C     NOP
16650  0E20     MOVLW 0x20
16652  D005     BRA 0x665E
16654  90D8     BCF 0xFD8, 0, ACCESS
16656  320C     RRCF 0xC, F, ACCESS
16658  320B     RRCF wtemp5, F, ACCESS
1665A  320A     RRCF ttemp3, F, ACCESS
1665C  3209     RRCF ltemp2, F, ACCESS
1665E  2EE8     DECFSZ 0xFE8, F, ACCESS
16660  D7F9     BRA 0x6654
16662  5009     MOVF ltemp2, W, ACCESS
16664  B4D8     BTFSC 0xFD8, 2, ACCESS
16666  D028     BRA 0x66B8
17:            			u.i += m;
16668  0EF6     MOVLW 0xF6
1666A  50E3     MOVF 0xFE3, W, ACCESS
1666C  6E01     MOVWF ltemp0, ACCESS
1666E  0EFA     MOVLW 0xFA
16670  50E3     MOVF 0xFE3, W, ACCESS
16672  2601     ADDWF ltemp0, F, ACCESS
16674  0EF6     MOVLW 0xF6
16678  F007     NOP
1667A  FFE3     NOP
1667C  0EF7     MOVLW 0xF7
1667E  50E3     MOVF 0xFE3, W, ACCESS
16680  6E01     MOVWF ltemp0, ACCESS
16682  0EFB     MOVLW 0xFB
16684  50E3     MOVF 0xFE3, W, ACCESS
16686  2201     ADDWFC ltemp0, F, ACCESS
16688  0EF7     MOVLW 0xF7
1668C  F007     NOP
1668E  FFE3     NOP
16690  0EF8     MOVLW 0xF8
16692  50E3     MOVF 0xFE3, W, ACCESS
16694  6E01     MOVWF ltemp0, ACCESS
16696  0EFC     MOVLW 0xFC
16698  50E3     MOVF 0xFE3, W, ACCESS
1669A  2201     ADDWFC ltemp0, F, ACCESS
1669C  0EF8     MOVLW 0xF8
166A0  F007     NOP
166A2  FFE3     NOP
166A4  0EF9     MOVLW 0xF9
166A6  50E3     MOVF 0xFE3, W, ACCESS
166A8  6E01     MOVWF ltemp0, ACCESS
166AA  0EFD     MOVLW 0xFD
166AC  50E3     MOVF 0xFE3, W, ACCESS
166AE  2201     ADDWFC ltemp0, F, ACCESS
166B0  0EF9     MOVLW 0xF9
166B4  F007     NOP
166B6  FFE3     NOP
18:            		u.i &= ~m;
166B8  0EFA     MOVLW 0xFA
166BC  FF8C     NOP
166BE  F009     NOP
166C0  0EFB     MOVLW 0xFB
166C4  FF8C     NOP
166C6  F00A     NOP
166C8  0EFC     MOVLW 0xFC
166CC  FF8C     NOP
166CE  F00B     NOP
166D0  0EFD     MOVLW 0xFD
166D4  FF8C     NOP
166D6  F00C     NOP
166D8  1C09     COMF ltemp2, W, ACCESS
166DA  6E05     MOVWF ltemp1, ACCESS
166DC  1C0A     COMF ttemp3, W, ACCESS
166DE  6E06     MOVWF 0x6, ACCESS
166E0  1C0B     COMF wtemp5, W, ACCESS
166E2  6E07     MOVWF ttemp2, ACCESS
166E4  1C0C     COMF 0xC, W, ACCESS
166E6  6E08     MOVWF 0x8, ACCESS
166E8  50E1     MOVF 0xFE1, W, ACCESS
166EA  0FF6     ADDLW 0xF6
166EC  6ED9     MOVWF 0xFD9, ACCESS
166EE  50E2     MOVF 0xFE2, W, ACCESS
166F0  6EDA     MOVWF 0xFDA, ACCESS
166F2  0EFF     MOVLW 0xFF
166F4  22DA     ADDWFC 0xFDA, F, ACCESS
166F6  5005     MOVF ltemp1, W, ACCESS
166F8  16DE     ANDWF 0xFDE, F, ACCESS
166FA  5006     MOVF 0x6, W, ACCESS
166FC  16DE     ANDWF 0xFDE, F, ACCESS
166FE  5007     MOVF ttemp2, W, ACCESS
16700  16DE     ANDWF 0xFDE, F, ACCESS
16702  5008     MOVF 0x8, W, ACCESS
16704  16DE     ANDWF 0xFDE, F, ACCESS
19:            	} else {
16706  D05B     BRA 0x67BE
20:            		FORCE_EVAL(x + 0x1p120f);
21:            		if (u.i >> 31 == 0)
16708  0EF6     MOVLW 0xF6
1670C  FF8C     NOP
1670E  F009     NOP
16710  0EF7     MOVLW 0xF7
16714  FF8C     NOP
16716  F00A     NOP
16718  0EF8     MOVLW 0xF8
1671C  FF8C     NOP
1671E  F00B     NOP
16720  0EF9     MOVLW 0xF9
16724  FF8C     NOP
16726  F00C     NOP
16728  0E20     MOVLW 0x20
1672A  D005     BRA 0x6736
1672C  90D8     BCF 0xFD8, 0, ACCESS
1672E  320C     RRCF 0xC, F, ACCESS
16730  320B     RRCF wtemp5, F, ACCESS
16732  320A     RRCF ttemp3, F, ACCESS
16734  3209     RRCF ltemp2, F, ACCESS
16736  2EE8     DECFSZ 0xFE8, F, ACCESS
16738  D7F9     BRA 0x672C
1673A  6609     TSTFSZ ltemp2, ACCESS
1673C  D009     BRA 0x6750
22:            			u.i = 0;
1673E  0EF6     MOVLW 0xF6
16740  6AE3     CLRF 0xFE3, ACCESS
16742  0EF7     MOVLW 0xF7
16744  6AE3     CLRF 0xFE3, ACCESS
16746  0EF8     MOVLW 0xF8
16748  6AE3     CLRF 0xFE3, ACCESS
1674A  0EF9     MOVLW 0xF9
1674C  6AE3     CLRF 0xFE3, ACCESS
1674E  D037     BRA 0x67BE
23:            		else if (u.i << 1)
16750  0EF6     MOVLW 0xF6
16754  FF8C     NOP
16756  F009     NOP
16758  0EF7     MOVLW 0xF7
1675C  FF8C     NOP
1675E  F00A     NOP
16760  0EF8     MOVLW 0xF8
16764  FF8C     NOP
16766  F00B     NOP
16768  0EF9     MOVLW 0xF9
1676C  FF8C     NOP
1676E  F00C     NOP
16770  90D8     BCF 0xFD8, 0, ACCESS
16772  3409     RLCF ltemp2, W, ACCESS
16774  6E05     MOVWF ltemp1, ACCESS
16776  340A     RLCF ttemp3, W, ACCESS
16778  6E06     MOVWF 0x6, ACCESS
1677A  340B     RLCF wtemp5, W, ACCESS
1677C  6E07     MOVWF ttemp2, ACCESS
1677E  340C     RLCF 0xC, W, ACCESS
16780  6E08     MOVWF 0x8, ACCESS
16782  5005     MOVF ltemp1, W, ACCESS
16784  1006     IORWF 0x6, W, ACCESS
16786  1007     IORWF ttemp2, W, ACCESS
16788  1008     IORWF 0x8, W, ACCESS
1678A  B4D8     BTFSC 0xFD8, 2, ACCESS
1678C  D018     BRA 0x67BE
24:            			u.f = -1.0;
1678E  0E00     MOVLW 0x0
16790  6E09     MOVWF ltemp2, ACCESS
16792  0E00     MOVLW 0x0
16794  6E0A     MOVWF ttemp3, ACCESS
16796  0E80     MOVLW 0x80
16798  6E0B     MOVWF wtemp5, ACCESS
1679A  0EBF     MOVLW 0xBF
1679C  6E0C     MOVWF 0xC, ACCESS
1679E  0EF6     MOVLW 0xF6
167A2  F027     NOP
167A4  FFE3     NOP
167A6  0EF7     MOVLW 0xF7
167AA  F02B     NOP
167AC  FFE3     NOP
167AE  0EF8     MOVLW 0xF8
167B2  F02F     NOP
167B4  FFE3     NOP
167B6  0EF9     MOVLW 0xF9
167BA  F033     NOP
167BC  FFE3     NOP
25:            	}
26:            	return u.f;
167BE  0EF6     MOVLW 0xF6
167C2  FF8C     NOP
167C4  F001     NOP
167C6  0EF7     MOVLW 0xF7
167CA  FF8C     NOP
167CC  F002     NOP
167CE  0EF8     MOVLW 0xF8
167D2  FF8C     NOP
167D4  F003     NOP
167D6  0EF9     MOVLW 0xF9
167DA  FF8C     NOP
167DC  F004     NOP
27:            }
167DE  0EF2     MOVLW 0xF2
167E0  26E1     ADDWF 0xFE1, F, ACCESS
167E2  0EFF     MOVLW 0xFF
167E4  22E2     ADDWFC 0xFE2, F, ACCESS
167E6  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/flneg.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
16:            {
17:            	if(mant1 != 0x0)
1B418  0EFC     MOVLW 0xFC
1B41A  50E3     MOVF 0xFE3, W, ACCESS
1B41C  E10A     BNZ 0xB432
1B41E  0EFD     MOVLW 0xFD
1B420  50E3     MOVF 0xFE3, W, ACCESS
1B422  E107     BNZ 0xB432
1B424  0EFE     MOVLW 0xFE
1B426  50E3     MOVF 0xFE3, W, ACCESS
1B428  E104     BNZ 0xB432
1B42A  0EFF     MOVLW 0xFF
1B42C  50E3     MOVF 0xFE3, W, ACCESS
1B42E  B4D8     BTFSC 0xFD8, 2, ACCESS
1B430  D002     BRA 0xB436
18:            		mant1 ^= 0x80000000UL;
1B432  0EFF     MOVLW 0xFF
1B434  7EE3     BTG 0xFE3, 7, ACCESS
19:            	return f1;
1B436  0EFC     MOVLW 0xFC
1B43A  FF8C     NOP
1B43C  F001     NOP
1B43E  0EFD     MOVLW 0xFD
1B442  FF8C     NOP
1B444  F002     NOP
1B446  0EFE     MOVLW 0xFE
1B44A  FF8C     NOP
1B44C  F003     NOP
1B44E  0EFF     MOVLW 0xFF
1B452  FF8C     NOP
1B454  F004     NOP
20:            }
1B456  52E5     MOVF 0xFE5, F, ACCESS
1B458  52E5     MOVF 0xFE5, F, ACCESS
1B45A  52E5     MOVF 0xFE5, F, ACCESS
1B45C  52E5     MOVF 0xFE5, F, ACCESS
1B45E  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/flge.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
18FE8  50E1     MOVF 0xFE1, W, ACCESS
18FEA  0FFC     ADDLW 0xFC
18FEC  6ED9     MOVWF 0xFD9, ACCESS
18FEE  50E2     MOVF 0xFE2, W, ACCESS
18FF0  6EDA     MOVWF 0xFDA, ACCESS
18FF2  0EFF     MOVLW 0xFF
18FF4  22DA     ADDWFC 0xFDA, F, ACCESS
18FF6  0E00     MOVLW 0x0
18FF8  14DE     ANDWF 0xFDE, W, ACCESS
18FFA  6E09     MOVWF ltemp2, ACCESS
18FFC  0E00     MOVLW 0x0
18FFE  14DE     ANDWF 0xFDE, W, ACCESS
19000  6E0A     MOVWF ttemp3, ACCESS
19002  0E80     MOVLW 0x80
19004  14DE     ANDWF 0xFDE, W, ACCESS
19006  6E0B     MOVWF wtemp5, ACCESS
19008  0E7F     MOVLW 0x7F
1900A  14DE     ANDWF 0xFDE, W, ACCESS
1900C  6E0C     MOVWF 0xC, ACCESS
1900E  5009     MOVF ltemp2, W, ACCESS
19010  100A     IORWF ttemp3, W, ACCESS
19012  100B     IORWF wtemp5, W, ACCESS
19014  100C     IORWF 0xC, W, ACCESS
19016  A4D8     BTFSS 0xFD8, 2, ACCESS
19018  D008     BRA 0x902A
8:             		f1 = 0x00000000UL;
1901A  0EFC     MOVLW 0xFC
1901C  6AE3     CLRF 0xFE3, ACCESS
1901E  0EFD     MOVLW 0xFD
19020  6AE3     CLRF 0xFE3, ACCESS
19022  0EFE     MOVLW 0xFE
19024  6AE3     CLRF 0xFE3, ACCESS
19026  0EFF     MOVLW 0xFF
19028  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
1902A  50E1     MOVF 0xFE1, W, ACCESS
1902C  0FF8     ADDLW 0xF8
1902E  6ED9     MOVWF 0xFD9, ACCESS
19030  50E2     MOVF 0xFE2, W, ACCESS
19032  6EDA     MOVWF 0xFDA, ACCESS
19034  0EFF     MOVLW 0xFF
19036  22DA     ADDWFC 0xFDA, F, ACCESS
19038  0E00     MOVLW 0x0
1903A  14DE     ANDWF 0xFDE, W, ACCESS
1903C  6E09     MOVWF ltemp2, ACCESS
1903E  0E00     MOVLW 0x0
19040  14DE     ANDWF 0xFDE, W, ACCESS
19042  6E0A     MOVWF ttemp3, ACCESS
19044  0E80     MOVLW 0x80
19046  14DE     ANDWF 0xFDE, W, ACCESS
19048  6E0B     MOVWF wtemp5, ACCESS
1904A  0E7F     MOVLW 0x7F
1904C  14DE     ANDWF 0xFDE, W, ACCESS
1904E  6E0C     MOVWF 0xC, ACCESS
19050  5009     MOVF ltemp2, W, ACCESS
19052  100A     IORWF ttemp3, W, ACCESS
19054  100B     IORWF wtemp5, W, ACCESS
19056  100C     IORWF 0xC, W, ACCESS
19058  A4D8     BTFSS 0xFD8, 2, ACCESS
1905A  D008     BRA 0x906C
10:            	        f2 = 0x00000000UL;
1905C  0EF8     MOVLW 0xF8
1905E  6AE3     CLRF 0xFE3, ACCESS
19060  0EF9     MOVLW 0xF9
19062  6AE3     CLRF 0xFE3, ACCESS
19064  0EFA     MOVLW 0xFA
19066  6AE3     CLRF 0xFE3, ACCESS
19068  0EFB     MOVLW 0xFB
1906A  6AE3     CLRF 0xFE3, ACCESS
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
1906C  0EFF     MOVLW 0xFF
1906E  AEE3     BTFSS 0xFE3, 7, ACCESS
19070  D024     BRA 0x90BA
13:            		f1 = 0x80000000UL - f1;
19072  0E00     MOVLW 0x0
19074  6E09     MOVWF ltemp2, ACCESS
19076  0E00     MOVLW 0x0
19078  6E0A     MOVWF ttemp3, ACCESS
1907A  0E00     MOVLW 0x0
1907C  6E0B     MOVWF wtemp5, ACCESS
1907E  0E80     MOVLW 0x80
19080  6E0C     MOVWF 0xC, ACCESS
19082  0EFC     MOVLW 0xFC
19084  50E3     MOVF 0xFE3, W, ACCESS
19086  5E09     SUBWF ltemp2, F, ACCESS
19088  0EFD     MOVLW 0xFD
1908A  50E3     MOVF 0xFE3, W, ACCESS
1908C  5A0A     SUBWFB ttemp3, F, ACCESS
1908E  0EFE     MOVLW 0xFE
19090  50E3     MOVF 0xFE3, W, ACCESS
19092  5A0B     SUBWFB wtemp5, F, ACCESS
19094  0EFF     MOVLW 0xFF
19096  50E3     MOVF 0xFE3, W, ACCESS
19098  5A0C     SUBWFB 0xC, F, ACCESS
1909A  0EFC     MOVLW 0xFC
1909E  F027     NOP
190A0  FFE3     NOP
190A2  0EFD     MOVLW 0xFD
190A6  F02B     NOP
190A8  FFE3     NOP
190AA  0EFE     MOVLW 0xFE
190AE  F02F     NOP
190B0  FFE3     NOP
190B2  0EFF     MOVLW 0xFF
190B6  F033     NOP
190B8  FFE3     NOP
14:            	if(f2 &  0x80000000UL)
190BA  0EFB     MOVLW 0xFB
190BC  AEE3     BTFSS 0xFE3, 7, ACCESS
190BE  D024     BRA 0x9108
15:            		f2 = 0x80000000UL - f2;
190C0  0E00     MOVLW 0x0
190C2  6E09     MOVWF ltemp2, ACCESS
190C4  0E00     MOVLW 0x0
190C6  6E0A     MOVWF ttemp3, ACCESS
190C8  0E00     MOVLW 0x0
190CA  6E0B     MOVWF wtemp5, ACCESS
190CC  0E80     MOVLW 0x80
190CE  6E0C     MOVWF 0xC, ACCESS
190D0  0EF8     MOVLW 0xF8
190D2  50E3     MOVF 0xFE3, W, ACCESS
190D4  5E09     SUBWF ltemp2, F, ACCESS
190D6  0EF9     MOVLW 0xF9
190D8  50E3     MOVF 0xFE3, W, ACCESS
190DA  5A0A     SUBWFB ttemp3, F, ACCESS
190DC  0EFA     MOVLW 0xFA
190DE  50E3     MOVF 0xFE3, W, ACCESS
190E0  5A0B     SUBWFB wtemp5, F, ACCESS
190E2  0EFB     MOVLW 0xFB
190E4  50E3     MOVF 0xFE3, W, ACCESS
190E6  5A0C     SUBWFB 0xC, F, ACCESS
190E8  0EF8     MOVLW 0xF8
190EC  F027     NOP
190EE  FFE3     NOP
190F0  0EF9     MOVLW 0xF9
190F4  F02B     NOP
190F6  FFE3     NOP
190F8  0EFA     MOVLW 0xFA
190FC  F02F     NOP
190FE  FFE3     NOP
19100  0EFB     MOVLW 0xFB
19104  F033     NOP
19106  FFE3     NOP
16:            	f1 ^= 0x80000000UL;
19108  0EFF     MOVLW 0xFF
1910A  7EE3     BTG 0xFE3, 7, ACCESS
17:            	f2 ^= 0x80000000UL;
1910C  0EFB     MOVLW 0xFB
1910E  7EE3     BTG 0xFE3, 7, ACCESS
18:            	return f1 >= f2;
19110  50E1     MOVF 0xFE1, W, ACCESS
19112  0FFC     ADDLW 0xFC
19114  6ED9     MOVWF 0xFD9, ACCESS
19116  50E2     MOVF 0xFE2, W, ACCESS
19118  6EDA     MOVWF 0xFDA, ACCESS
1911A  0EFF     MOVLW 0xFF
1911C  22DA     ADDWFC 0xFDA, F, ACCESS
1911E  0EF8     MOVLW 0xF8
19120  50E3     MOVF 0xFE3, W, ACCESS
19122  5CDE     SUBWF 0xFDE, W, ACCESS
19124  0EF9     MOVLW 0xF9
19126  50E3     MOVF 0xFE3, W, ACCESS
19128  58DE     SUBWFB 0xFDE, W, ACCESS
1912A  0EFA     MOVLW 0xFA
1912C  50E3     MOVF 0xFE3, W, ACCESS
1912E  58DE     SUBWFB 0xFDE, W, ACCESS
19130  0EFB     MOVLW 0xFB
19132  50E3     MOVF 0xFE3, W, ACCESS
19134  58DE     SUBWFB 0xFDE, W, ACCESS
19136  B0D8     BTFSC 0xFD8, 0, ACCESS
19138  D002     BRA 0x913E
1913A  9001     BCF ltemp0, 0, ACCESS
1913C  D001     BRA 0x9140
1913E  8001     BSF ltemp0, 0, ACCESS
19:            }
19140  0EF8     MOVLW 0xF8
19142  26E1     ADDWF 0xFE1, F, ACCESS
19144  0EFF     MOVLW 0xFF
19146  22E2     ADDWFC 0xFE2, F, ACCESS
19148  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fleq.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
1A356  50E1     MOVF 0xFE1, W, ACCESS
1A358  0FFC     ADDLW 0xFC
1A35A  6ED9     MOVWF 0xFD9, ACCESS
1A35C  50E2     MOVF 0xFE2, W, ACCESS
1A35E  6EDA     MOVWF 0xFDA, ACCESS
1A360  0EFF     MOVLW 0xFF
1A362  22DA     ADDWFC 0xFDA, F, ACCESS
1A364  0E00     MOVLW 0x0
1A366  14DE     ANDWF 0xFDE, W, ACCESS
1A368  6E09     MOVWF ltemp2, ACCESS
1A36A  0E00     MOVLW 0x0
1A36C  14DE     ANDWF 0xFDE, W, ACCESS
1A36E  6E0A     MOVWF ttemp3, ACCESS
1A370  0E80     MOVLW 0x80
1A372  14DE     ANDWF 0xFDE, W, ACCESS
1A374  6E0B     MOVWF wtemp5, ACCESS
1A376  0E7F     MOVLW 0x7F
1A378  14DE     ANDWF 0xFDE, W, ACCESS
1A37A  6E0C     MOVWF 0xC, ACCESS
1A37C  5009     MOVF ltemp2, W, ACCESS
1A37E  100A     IORWF ttemp3, W, ACCESS
1A380  100B     IORWF wtemp5, W, ACCESS
1A382  100C     IORWF 0xC, W, ACCESS
1A384  A4D8     BTFSS 0xFD8, 2, ACCESS
1A386  D008     BRA 0xA398
8:             		f1 = 0x00000000UL;
1A388  0EFC     MOVLW 0xFC
1A38A  6AE3     CLRF 0xFE3, ACCESS
1A38C  0EFD     MOVLW 0xFD
1A38E  6AE3     CLRF 0xFE3, ACCESS
1A390  0EFE     MOVLW 0xFE
1A392  6AE3     CLRF 0xFE3, ACCESS
1A394  0EFF     MOVLW 0xFF
1A396  6AE3     CLRF 0xFE3, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
1A398  50E1     MOVF 0xFE1, W, ACCESS
1A39A  0FF8     ADDLW 0xF8
1A39C  6ED9     MOVWF 0xFD9, ACCESS
1A39E  50E2     MOVF 0xFE2, W, ACCESS
1A3A0  6EDA     MOVWF 0xFDA, ACCESS
1A3A2  0EFF     MOVLW 0xFF
1A3A4  22DA     ADDWFC 0xFDA, F, ACCESS
1A3A6  0E00     MOVLW 0x0
1A3A8  14DE     ANDWF 0xFDE, W, ACCESS
1A3AA  6E09     MOVWF ltemp2, ACCESS
1A3AC  0E00     MOVLW 0x0
1A3AE  14DE     ANDWF 0xFDE, W, ACCESS
1A3B0  6E0A     MOVWF ttemp3, ACCESS
1A3B2  0E80     MOVLW 0x80
1A3B4  14DE     ANDWF 0xFDE, W, ACCESS
1A3B6  6E0B     MOVWF wtemp5, ACCESS
1A3B8  0E7F     MOVLW 0x7F
1A3BA  14DE     ANDWF 0xFDE, W, ACCESS
1A3BC  6E0C     MOVWF 0xC, ACCESS
1A3BE  5009     MOVF ltemp2, W, ACCESS
1A3C0  100A     IORWF ttemp3, W, ACCESS
1A3C2  100B     IORWF wtemp5, W, ACCESS
1A3C4  100C     IORWF 0xC, W, ACCESS
1A3C6  A4D8     BTFSS 0xFD8, 2, ACCESS
1A3C8  D008     BRA 0xA3DA
10:            	        f2 = 0x00000000UL;
1A3CA  0EF8     MOVLW 0xF8
1A3CC  6AE3     CLRF 0xFE3, ACCESS
1A3CE  0EF9     MOVLW 0xF9
1A3D0  6AE3     CLRF 0xFE3, ACCESS
1A3D2  0EFA     MOVLW 0xFA
1A3D4  6AE3     CLRF 0xFE3, ACCESS
1A3D6  0EFB     MOVLW 0xFB
1A3D8  6AE3     CLRF 0xFE3, ACCESS
11:            	return f1 == f2;
1A3DA  50E1     MOVF 0xFE1, W, ACCESS
1A3DC  0FFC     ADDLW 0xFC
1A3DE  6ED9     MOVWF 0xFD9, ACCESS
1A3E0  50E2     MOVF 0xFE2, W, ACCESS
1A3E2  6EDA     MOVWF 0xFDA, ACCESS
1A3E4  0EFF     MOVLW 0xFF
1A3E6  22DA     ADDWFC 0xFDA, F, ACCESS
1A3E8  0EF8     MOVLW 0xF8
1A3EA  50E3     MOVF 0xFE3, W, ACCESS
1A3EC  18DE     XORWF 0xFDE, W, ACCESS
1A3EE  E10D     BNZ 0xA40A
1A3F0  0EF9     MOVLW 0xF9
1A3F2  50E3     MOVF 0xFE3, W, ACCESS
1A3F4  18DE     XORWF 0xFDE, W, ACCESS
1A3F6  E109     BNZ 0xA40A
1A3F8  0EFA     MOVLW 0xFA
1A3FA  50E3     MOVF 0xFE3, W, ACCESS
1A3FC  18DE     XORWF 0xFDE, W, ACCESS
1A3FE  E105     BNZ 0xA40A
1A400  0EFB     MOVLW 0xFB
1A402  50E3     MOVF 0xFE3, W, ACCESS
1A404  18DE     XORWF 0xFDE, W, ACCESS
1A406  B4D8     BTFSC 0xFD8, 2, ACCESS
1A408  D002     BRA 0xA40E
1A40A  9001     BCF ltemp0, 0, ACCESS
1A40C  D001     BRA 0xA410
1A40E  8001     BSF ltemp0, 0, ACCESS
12:            }
1A410  0EF8     MOVLW 0xF8
1A412  26E1     ADDWF 0xFE1, F, ACCESS
1A414  0EFF     MOVLW 0xFF
1A416  22E2     ADDWFC 0xFE2, F, ACCESS
1A418  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/fabsf.c  -------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float fabsf(float x)
1A58C  52E6     MOVF 0xFE6, F, ACCESS
1A58E  52E6     MOVF 0xFE6, F, ACCESS
1A590  52E6     MOVF 0xFE6, F, ACCESS
1A592  52E6     MOVF 0xFE6, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
1A596  F1F8     NOP
1A598  F009     NOP
1A59C  F1FC     NOP
1A59E  F00A     NOP
1A5A2  F200     NOP
1A5A4  F00B     NOP
1A5A8  F204     NOP
1A5AA  F00C     NOP
1A5AC  0EFC     MOVLW 0xFC
1A5B0  F027     NOP
1A5B2  FFE3     NOP
1A5B4  0EFD     MOVLW 0xFD
1A5B8  F02B     NOP
1A5BA  FFE3     NOP
1A5BC  0EFE     MOVLW 0xFE
1A5C0  F02F     NOP
1A5C2  FFE3     NOP
1A5C4  0EFF     MOVLW 0xFF
1A5C8  F033     NOP
1A5CA  FFE3     NOP
1A5CC  0EF8     MOVLW 0xF8
1A5D0  FF8C     NOP
1A5D2  F009     NOP
1A5D4  0EF9     MOVLW 0xF9
1A5D8  FF8C     NOP
1A5DA  F00A     NOP
1A5DC  0EFA     MOVLW 0xFA
1A5E0  FF8C     NOP
1A5E2  F00B     NOP
1A5E4  0EFB     MOVLW 0xFB
1A5E8  FF8C     NOP
1A5EA  F00C     NOP
1A5EC  0EFC     MOVLW 0xFC
1A5F0  F027     NOP
1A5F2  FFE3     NOP
1A5F4  0EFD     MOVLW 0xFD
1A5F8  F02B     NOP
1A5FA  FFE3     NOP
1A5FC  0EFE     MOVLW 0xFE
1A600  F02F     NOP
1A602  FFE3     NOP
1A604  0EFF     MOVLW 0xFF
1A608  F033     NOP
1A60A  FFE3     NOP
7:             	u.i &= 0x7fffffff;
1A60C  0EFF     MOVLW 0xFF
1A60E  9EE3     BCF 0xFE3, 7, ACCESS
8:             	return u.f;
1A610  0EFC     MOVLW 0xFC
1A614  FF8C     NOP
1A616  F001     NOP
1A618  0EFD     MOVLW 0xFD
1A61C  FF8C     NOP
1A61E  F002     NOP
1A620  0EFE     MOVLW 0xFE
1A624  FF8C     NOP
1A626  F003     NOP
1A628  0EFF     MOVLW 0xFF
1A62C  FF8C     NOP
1A62E  F004     NOP
9:             }
1A630  0EF8     MOVLW 0xF8
1A632  26E1     ADDWF 0xFE1, F, ACCESS
1A634  0EFF     MOVLW 0xFF
1A636  22E2     ADDWFC 0xFE2, F, ACCESS
1A638  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
199DC  52E6     MOVF 0xFE6, F, ACCESS
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
199E4  A03E     BTFSS flags, 0, ACCESS
199E6  D010     BRA 0x9A08
78:                    fputs((const char *)buf, fp);
199E8  0EFA     MOVLW 0xFA
199EC  FF8F     NOP
199EE  FFE6     NOP
199F2  FF8F     NOP
199F4  FFE6     NOP
199F6  0EF6     MOVLW 0xF6
199FA  FF8F     NOP
199FC  FFE6     NOP
19A00  FF8F     NOP
19A02  FFE6     NOP
19A04  ECC0     CALL 0x1A980, 0
19A06  F0D4     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
19A08  0EF7     MOVLW 0xF7
19A0A  BEE3     BTFSC 0xFE3, 7, ACCESS
19A0C  D011     BRA 0x9A30
19A0E  0EF6     MOVLW 0xF6
19A12  FF8C     NOP
19A14  F001     NOP
19A16  0EFC     MOVLW 0xFC
19A1A  F007     NOP
19A1C  FFE3     NOP
19A1E  0EF7     MOVLW 0xF7
19A22  FF8C     NOP
19A24  F001     NOP
19A26  0EFD     MOVLW 0xFD
19A2A  F007     NOP
19A2C  FFE3     NOP
19A2E  D004     BRA 0x9A38
19A30  0EFC     MOVLW 0xFC
19A32  6AE3     CLRF 0xFE3, ACCESS
19A34  0EFD     MOVLW 0xFD
19A36  6AE3     CLRF 0xFE3, ACCESS
83:                i = 0;
19A38  0EFE     MOVLW 0xFE
19A3A  6AE3     CLRF 0xFE3, ACCESS
19A3C  0EFF     MOVLW 0xFF
19A3E  6AE3     CLRF 0xFE3, ACCESS
84:                while (i < w) {
19A40  D01E     BRA 0x9A7E
19A7E  50E1     MOVF 0xFE1, W, ACCESS
19A80  0FFE     ADDLW 0xFE
19A82  6ED9     MOVWF 0xFD9, ACCESS
19A84  50E2     MOVF 0xFE2, W, ACCESS
19A86  6EDA     MOVWF 0xFDA, ACCESS
19A88  0EFF     MOVLW 0xFF
19A8A  22DA     ADDWFC 0xFDA, F, ACCESS
19A8C  0EFC     MOVLW 0xFC
19A8E  50E3     MOVF 0xFE3, W, ACCESS
19A90  5CDE     SUBWF 0xFDE, W, ACCESS
19A92  50DE     MOVF 0xFDE, W, ACCESS
19A94  0A80     XORLW 0x80
19A96  6E01     MOVWF ltemp0, ACCESS
19A98  0EFD     MOVLW 0xFD
19A9A  50E3     MOVF 0xFE3, W, ACCESS
19A9C  0A80     XORLW 0x80
19A9E  5801     SUBWFB ltemp0, W, ACCESS
19AA0  A0D8     BTFSS 0xFD8, 0, ACCESS
19AA2  D7CF     BRA 0x9A42
85:                    fputc(' ', fp);
19A42  0EFA     MOVLW 0xFA
19A46  FF8F     NOP
19A48  FFE6     NOP
19A4C  FF8F     NOP
19A4E  FFE6     NOP
19A50  0E20     MOVLW 0x20
19A52  6EE6     MOVWF 0xFE6, ACCESS
19A54  0E00     MOVLW 0x0
19A56  6EE6     MOVWF 0xFE6, ACCESS
19A58  ECD0     CALL 0x197A0, 0
19A5A  F0CB     NOP
86:                    ++i;
19A5C  0EFE     MOVLW 0xFE
19A5E  50E3     MOVF 0xFE3, W, ACCESS
19A60  0F01     ADDLW 0x1
19A62  6E01     MOVWF ltemp0, ACCESS
19A64  0EFE     MOVLW 0xFE
19A68  F007     NOP
19A6A  FFE3     NOP
19A6C  6A01     CLRF ltemp0, ACCESS
19A6E  0EFF     MOVLW 0xFF
19A70  50E3     MOVF 0xFE3, W, ACCESS
19A72  2001     ADDWFC ltemp0, W, ACCESS
19A74  6E01     MOVWF ltemp0, ACCESS
19A76  0EFF     MOVLW 0xFF
19A7A  F007     NOP
19A7C  FFE3     NOP
87:                }
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
19AA4  B03E     BTFSC flags, 0, ACCESS
19AA6  D010     BRA 0x9AC8
91:                    fputs((const char *)buf, fp);
19AA8  0EFA     MOVLW 0xFA
19AAC  FF8F     NOP
19AAE  FFE6     NOP
19AB2  FF8F     NOP
19AB4  FFE6     NOP
19AB6  0EF6     MOVLW 0xF6
19ABA  FF8F     NOP
19ABC  FFE6     NOP
19AC0  FF8F     NOP
19AC2  FFE6     NOP
19AC4  ECC0     CALL 0x1A980, 0
19AC6  F0D4     NOP
92:                }
93:            
94:                return strlen(buf) + w;
19AC8  0EF8     MOVLW 0xF8
19ACC  FF8F     NOP
19ACE  FFE6     NOP
19AD2  FF8F     NOP
19AD4  FFE6     NOP
19AD6  EC6F     CALL 0x1A8DE, 0
19AD8  F0D4     NOP
19ADA  0EFC     MOVLW 0xFC
19ADC  50E3     MOVF 0xFE3, W, ACCESS
19ADE  2601     ADDWF ltemp0, F, ACCESS
19AE0  0EFD     MOVLW 0xFD
19AE2  50E3     MOVF 0xFE3, W, ACCESS
19AE4  2202     ADDWFC ttemp5, F, ACCESS
95:            }
19AE6  0EF6     MOVLW 0xF6
19AE8  26E1     ADDWF 0xFE1, F, ACCESS
19AEA  0EFF     MOVLW 0xFF
19AEC  22E2     ADDWFC 0xFE2, F, ACCESS
19AEE  0012     RETURN 0
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
1ABCC  52E6     MOVF 0xFE6, F, ACCESS
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
1ABD0  503A     MOVF width, W, ACCESS
1ABD2  103B     IORWF 0x3B, W, ACCESS
1ABD4  A4D8     BTFSS 0xFD8, 2, ACCESS
1ABD6  D009     BRA 0xABEA
1ABD8  0EFE     MOVLW 0xFE
1ABDC  F0EB     NOP
1ABDE  FFE3     NOP
1ABE0  0EFF     MOVLW 0xFF
1ABE4  F0EF     NOP
1ABE6  FFE3     NOP
1ABE8  D016     BRA 0xAC16
1ABEA  0EFF     MOVLW 0xFF
1ABEC  6E0B     MOVWF wtemp5, ACCESS
1ABEE  0EFF     MOVLW 0xFF
1ABF0  6E0C     MOVWF 0xC, ACCESS
1ABF4  F0E8     NOP
1ABF6  F009     NOP
1ABFA  F0EC     NOP
1ABFC  F00A     NOP
1ABFE  500B     MOVF wtemp5, W, ACCESS
1AC00  2609     ADDWF ltemp2, F, ACCESS
1AC02  500C     MOVF 0xC, W, ACCESS
1AC04  220A     ADDWFC ttemp3, F, ACCESS
1AC06  0EFE     MOVLW 0xFE
1AC0A  F027     NOP
1AC0C  FFE3     NOP
1AC0E  0EFF     MOVLW 0xFF
1AC12  F02B     NOP
1AC14  FFE3     NOP
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
1AC16  0EFB     MOVLW 0xFB
1AC1A  FF8C     NOP
1AC1C  F297     NOP
268:               dbuf[1] = '\0';
1AC1E  0102     MOVLB 0x2
1AC20  6B98     CLRF 0x98, BANKED
269:               return pad(fp, &dbuf[0], w);
1AC22  0EFE     MOVLW 0xFE
1AC26  FF8F     NOP
1AC28  FFE6     NOP
1AC2C  FF8F     NOP
1AC2E  FFE6     NOP
1AC30  0E97     MOVLW 0x97
1AC32  6EE6     MOVWF 0xFE6, ACCESS
1AC34  0E02     MOVLW 0x2
1AC36  6EE6     MOVWF 0xFE6, ACCESS
1AC38  0EF8     MOVLW 0xF8
1AC3C  FF8F     NOP
1AC3E  FFE6     NOP
1AC42  FF8F     NOP
1AC44  FFE6     NOP
1AC46  ECEE     CALL 0x199DC, 0
1AC48  F0CC     NOP
270:           }
1AC4A  0EFB     MOVLW 0xFB
1AC4C  26E1     ADDWF 0xFE1, F, ACCESS
1AC4E  0EFF     MOVLW 0xFF
1AC50  22E2     ADDWFC 0xFE2, F, ACCESS
1AC52  0012     RETURN 0
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
157F6  0E12     MOVLW 0x12
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
157FE  0EE4     MOVLW 0xE4
15800  24E1     ADDWF 0xFE1, W, ACCESS
15802  6ED9     MOVWF 0xFD9, ACCESS
15804  0EFF     MOVLW 0xFF
15806  20E2     ADDWFC 0xFE2, W, ACCESS
15808  6EDA     MOVWF 0xFDA, ACCESS
1580A  0E08     MOVLW 0x8
1580C  6E01     MOVWF ltemp0, ACCESS
1580E  0EF0     MOVLW 0xF0
15812  FF7B     NOP
15814  FFE3     NOP
15816  28E8     INCF 0xFE8, W, ACCESS
15818  2E01     DECFSZ ltemp0, F, ACCESS
1581A  D7FA     BRA 0x5810
281:               s = n < 0 ? 1 : 0;
1581C  0EF7     MOVLW 0xF7
1581E  AEE3     BTFSS 0xFE3, 7, ACCESS
15820  D002     BRA 0x5826
15822  0E01     MOVLW 0x1
15824  D001     BRA 0x5828
15826  0E00     MOVLW 0x0
15828  6E0B     MOVWF wtemp5, ACCESS
1582A  6A0C     CLRF 0xC, ACCESS
1582C  0EFA     MOVLW 0xFA
15830  F02F     NOP
15832  FFE3     NOP
15834  0EFB     MOVLW 0xFB
15838  F033     NOP
1583A  FFE3     NOP
282:               if (s) {
1583C  0EFA     MOVLW 0xFA
15840  FF8C     NOP
15842  F001     NOP
15844  0EFB     MOVLW 0xFB
15846  50E3     MOVF 0xFE3, W, ACCESS
15848  1001     IORWF ltemp0, W, ACCESS
1584A  B4D8     BTFSC 0xFD8, 2, ACCESS
1584C  D025     BRA 0x5898
283:                   n = -n;
1584E  0EF0     MOVLW 0xF0
15850  6CE3     NEGF 0xFE3, ACCESS
15852  0EF1     MOVLW 0xF1
15854  1EE3     COMF 0xFE3, F, ACCESS
15856  0EF2     MOVLW 0xF2
15858  1EE3     COMF 0xFE3, F, ACCESS
1585A  0EF3     MOVLW 0xF3
1585C  1EE3     COMF 0xFE3, F, ACCESS
1585E  0EF4     MOVLW 0xF4
15860  1EE3     COMF 0xFE3, F, ACCESS
15862  0EF5     MOVLW 0xF5
15864  1EE3     COMF 0xFE3, F, ACCESS
15866  0EF6     MOVLW 0xF6
15868  1EE3     COMF 0xFE3, F, ACCESS
1586A  0EF7     MOVLW 0xF7
1586C  1EE3     COMF 0xFE3, F, ACCESS
1586E  E314     BNC 0x5898
15870  0EF1     MOVLW 0xF1
15872  2AE3     INCF 0xFE3, F, ACCESS
15874  E311     BNC 0x5898
15876  0EF2     MOVLW 0xF2
15878  2AE3     INCF 0xFE3, F, ACCESS
1587A  E30E     BNC 0x5898
1587C  0EF3     MOVLW 0xF3
1587E  2AE3     INCF 0xFE3, F, ACCESS
15880  E30B     BNC 0x5898
15882  0EF4     MOVLW 0xF4
15884  2AE3     INCF 0xFE3, F, ACCESS
15886  E308     BNC 0x5898
15888  0EF5     MOVLW 0xF5
1588A  2AE3     INCF 0xFE3, F, ACCESS
1588C  E305     BNC 0x5898
1588E  0EF6     MOVLW 0xF6
15890  2AE3     INCF 0xFE3, F, ACCESS
15892  E302     BNC 0x5898
15894  0EF7     MOVLW 0xF7
15896  2AE3     INCF 0xFE3, F, ACCESS
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
15898  AE3D     BTFSS 0x3D, 7, ACCESS
288:                   flags &= ~ZERO_FLAG;
1589A  923E     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
1589C  BE3D     BTFSC 0x3D, 7, ACCESS
1589E  D005     BRA 0x58AA
158A0  503D     MOVF 0x3D, W, ACCESS
158A2  E110     BNZ 0x58C4
158A4  043C     DECF prec, W, ACCESS
158A6  B0D8     BTFSC 0xFD8, 0, ACCESS
158A8  D00D     BRA 0x58C4
158AA  0E01     MOVLW 0x1
158AC  6E0B     MOVWF wtemp5, ACCESS
158AE  0E00     MOVLW 0x0
158B0  6E0C     MOVWF 0xC, ACCESS
158B2  0EFE     MOVLW 0xFE
158B6  F02F     NOP
158B8  FFE3     NOP
158BA  0EFF     MOVLW 0xFF
158BE  F033     NOP
158C0  FFE3     NOP
158C2  D008     BRA 0x58D4
158C4  0EFE     MOVLW 0xFE
158C8  F0F3     NOP
158CA  FFE3     NOP
158CC  0EFF     MOVLW 0xFF
158D0  F0F7     NOP
158D2  FFE3     NOP
291:               w = width;
158D4  0EFC     MOVLW 0xFC
158D8  F0EB     NOP
158DA  FFE3     NOP
158DC  0EFD     MOVLW 0xFD
158E0  F0EF     NOP
158E2  FFE3     NOP
292:               if (s || (flags & PLUS_FLAG)) {
158E4  0EFA     MOVLW 0xFA
158E8  FF8C     NOP
158EA  F001     NOP
158EC  0EFB     MOVLW 0xFB
158EE  50E3     MOVF 0xFE3, W, ACCESS
158F0  1001     IORWF ltemp0, W, ACCESS
158F2  A4D8     BTFSS 0xFD8, 2, ACCESS
158F4  D002     BRA 0x58FA
158F6  A43E     BTFSS flags, 2, ACCESS
158F8  D00A     BRA 0x590E
293:                   --w;
158FA  50E1     MOVF 0xFE1, W, ACCESS
158FC  0FFC     ADDLW 0xFC
158FE  6ED9     MOVWF 0xFD9, ACCESS
15900  50E2     MOVF 0xFE2, W, ACCESS
15902  6EDA     MOVWF 0xFDA, ACCESS
15904  0EFF     MOVLW 0xFF
15906  22DA     ADDWFC 0xFDA, F, ACCESS
15908  06DE     DECF 0xFDE, F, ACCESS
1590A  0E00     MOVLW 0x0
1590C  5ADD     SUBWFB 0xFDD, F, ACCESS
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
1590E  0E4F     MOVLW 0x4F
15910  6E0B     MOVWF wtemp5, ACCESS
15912  0E00     MOVLW 0x0
15914  6E0C     MOVWF 0xC, ACCESS
15916  0EF8     MOVLW 0xF8
1591A  F02F     NOP
1591C  FFE3     NOP
1591E  0EF9     MOVLW 0xF9
15922  F033     NOP
15924  FFE3     NOP
298:               dbuf[i] = '\0';
15926  0102     MOVLB 0x2
15928  6BE6     CLRF 0xE6, BANKED
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1592A  D109     BRA 0x5B3E
15B3E  0EF9     MOVLW 0xF9
15B40  BEE3     BTFSC 0xFE3, 7, ACCESS
15B42  D036     BRA 0x5BB0
15B44  0EF9     MOVLW 0xF9
15B46  50E3     MOVF 0xFE3, W, ACCESS
15B48  E104     BNZ 0x5B52
15B4A  0EF8     MOVLW 0xF8
15B4C  04E3     DECF 0xFE3, W, ACCESS
15B4E  A0D8     BTFSS 0xFD8, 0, ACCESS
15B50  D02F     BRA 0x5BB0
15B52  0EF0     MOVLW 0xF0
15B54  50E3     MOVF 0xFE3, W, ACCESS
15B56  E115     BNZ 0x5B82
15B58  0EF1     MOVLW 0xF1
15B5A  50E3     MOVF 0xFE3, W, ACCESS
15B5C  E112     BNZ 0x5B82
15B5E  0EF2     MOVLW 0xF2
15B60  50E3     MOVF 0xFE3, W, ACCESS
15B62  E10F     BNZ 0x5B82
15B64  0EF3     MOVLW 0xF3
15B66  50E3     MOVF 0xFE3, W, ACCESS
15B68  E10C     BNZ 0x5B82
15B6A  0EF4     MOVLW 0xF4
15B6C  50E3     MOVF 0xFE3, W, ACCESS
15B6E  E109     BNZ 0x5B82
15B70  0EF5     MOVLW 0xF5
15B72  50E3     MOVF 0xFE3, W, ACCESS
15B74  E106     BNZ 0x5B82
15B76  0EF6     MOVLW 0xF6
15B78  50E3     MOVF 0xFE3, W, ACCESS
15B7A  E103     BNZ 0x5B82
15B7C  0EF7     MOVLW 0xF7
15B7E  50E3     MOVF 0xFE3, W, ACCESS
15B80  A4D8     BTFSS 0xFD8, 2, ACCESS
15B82  D6D4     BRA 0x592C
15B84  0EFF     MOVLW 0xFF
15B86  BEE3     BTFSC 0xFE3, 7, ACCESS
15B88  D007     BRA 0x5B98
15B8A  0EFF     MOVLW 0xFF
15B8C  50E3     MOVF 0xFE3, W, ACCESS
15B8E  E103     BNZ 0x5B96
15B90  0EFE     MOVLW 0xFE
15B92  04E3     DECF 0xFE3, W, ACCESS
15B94  B0D8     BTFSC 0xFD8, 0, ACCESS
15B96  D6CA     BRA 0x592C
15B98  0EFD     MOVLW 0xFD
15B9A  BEE3     BTFSC 0xFE3, 7, ACCESS
15B9C  D009     BRA 0x5BB0
15B9E  0EFD     MOVLW 0xFD
15BA0  50E3     MOVF 0xFE3, W, ACCESS
15BA2  E104     BNZ 0x5BAC
15BA4  0EFC     MOVLW 0xFC
15BA6  04E3     DECF 0xFE3, W, ACCESS
15BA8  A0D8     BTFSS 0xFD8, 0, ACCESS
15BAA  D002     BRA 0x5BB0
15BAC  B23E     BTFSC flags, 1, ACCESS
15BAE  D6BE     BRA 0x592C
300:                   --i;
1592C  50E1     MOVF 0xFE1, W, ACCESS
1592E  0FF8     ADDLW 0xF8
15930  6ED9     MOVWF 0xFD9, ACCESS
15932  50E2     MOVF 0xFE2, W, ACCESS
15934  6EDA     MOVWF 0xFDA, ACCESS
15936  0EFF     MOVLW 0xFF
15938  22DA     ADDWFC 0xFDA, F, ACCESS
1593A  06DE     DECF 0xFDE, F, ACCESS
1593C  0E00     MOVLW 0x0
1593E  5ADD     SUBWFB 0xFDD, F, ACCESS
301:                   dbuf[i] = '0' + abs(n % 10);
15940  0E0A     MOVLW 0xA
15942  6EE6     MOVWF 0xFE6, ACCESS
15944  0E00     MOVLW 0x0
15946  6EE6     MOVWF 0xFE6, ACCESS
15948  0E00     MOVLW 0x0
1594A  6EE6     MOVWF 0xFE6, ACCESS
1594C  0E00     MOVLW 0x0
1594E  6EE6     MOVWF 0xFE6, ACCESS
15950  0E00     MOVLW 0x0
15952  6EE6     MOVWF 0xFE6, ACCESS
15954  0E00     MOVLW 0x0
15956  6EE6     MOVWF 0xFE6, ACCESS
15958  0E00     MOVLW 0x0
1595A  6EE6     MOVWF 0xFE6, ACCESS
1595C  0E00     MOVLW 0x0
1595E  6EE6     MOVWF 0xFE6, ACCESS
15960  50E1     MOVF 0xFE1, W, ACCESS
15962  0FE8     ADDLW 0xE8
15964  6ED9     MOVWF 0xFD9, ACCESS
15966  50E2     MOVF 0xFE2, W, ACCESS
15968  6EDA     MOVWF 0xFDA, ACCESS
1596A  0EFF     MOVLW 0xFF
1596C  22DA     ADDWFC 0xFDA, F, ACCESS
15970  FF7B     NOP
15972  FFE6     NOP
15976  FF7B     NOP
15978  FFE6     NOP
1597C  FF7B     NOP
1597E  FFE6     NOP
15982  FF7B     NOP
15984  FFE6     NOP
15988  FF7B     NOP
1598A  FFE6     NOP
1598E  FF7B     NOP
15990  FFE6     NOP
15994  FF7B     NOP
15996  FFE6     NOP
1599A  FF7B     NOP
1599C  FFE6     NOP
1599E  EC04     CALL 0x17E08, 0
159A0  F0BF     NOP
159A2  52E5     MOVF 0xFE5, F, ACCESS
159A6  FF9C     NOP
159A8  F018     NOP
159AA  52E5     MOVF 0xFE5, F, ACCESS
159AE  FF9C     NOP
159B0  F017     NOP
159B2  52E5     MOVF 0xFE5, F, ACCESS
159B6  FF9C     NOP
159B8  F016     NOP
159BA  52E5     MOVF 0xFE5, F, ACCESS
159BE  FF9C     NOP
159C0  F015     NOP
159C2  52E5     MOVF 0xFE5, F, ACCESS
159C6  FF9C     NOP
159C8  F014     NOP
159CA  52E5     MOVF 0xFE5, F, ACCESS
159CE  FF9C     NOP
159D0  F013     NOP
159D2  52E5     MOVF 0xFE5, F, ACCESS
159D6  FF9C     NOP
159D8  F012     NOP
159DA  52E5     MOVF 0xFE5, F, ACCESS
159DE  FF9C     NOP
159E0  F011     NOP
159E2  0EF8     MOVLW 0xF8
159E4  26E1     ADDWF 0xFE1, F, ACCESS
159E6  0EFF     MOVLW 0xFF
159E8  22E2     ADDWFC 0xFE2, F, ACCESS
159EC  F044     NOP
159EE  F00B     NOP
159F2  F048     NOP
159F4  F00C     NOP
159F8  F02F     NOP
159FA  FFE6     NOP
159FE  F033     NOP
15A00  FFE6     NOP
15A02  EC9C     CALL 0x1B538, 0
15A04  F0DA     NOP
15A06  0E30     MOVLW 0x30
15A08  2601     ADDWF ltemp0, F, ACCESS
15A0A  0EF8     MOVLW 0xF8
15A0E  FF8C     NOP
15A10  F00B     NOP
15A12  0EF9     MOVLW 0xF9
15A16  FF8C     NOP
15A18  F00C     NOP
15A1A  0E97     MOVLW 0x97
15A1C  240B     ADDWF wtemp5, W, ACCESS
15A1E  6ED9     MOVWF 0xFD9, ACCESS
15A20  0E02     MOVLW 0x2
15A22  200C     ADDWFC 0xC, W, ACCESS
15A24  6EDA     MOVWF 0xFDA, ACCESS
15A28  F007     NOP
15A2A  FFDF     NOP
302:                   --p;
15A2C  50E1     MOVF 0xFE1, W, ACCESS
15A2E  0FFE     ADDLW 0xFE
15A30  6ED9     MOVWF 0xFD9, ACCESS
15A32  50E2     MOVF 0xFE2, W, ACCESS
15A34  6EDA     MOVWF 0xFDA, ACCESS
15A36  0EFF     MOVLW 0xFF
15A38  22DA     ADDWFC 0xFDA, F, ACCESS
15A3A  06DE     DECF 0xFDE, F, ACCESS
15A3C  0E00     MOVLW 0x0
15A3E  5ADD     SUBWFB 0xFDD, F, ACCESS
303:                   --w;
15A40  50E1     MOVF 0xFE1, W, ACCESS
15A42  0FFC     ADDLW 0xFC
15A44  6ED9     MOVWF 0xFD9, ACCESS
15A46  50E2     MOVF 0xFE2, W, ACCESS
15A48  6EDA     MOVWF 0xFDA, ACCESS
15A4A  0EFF     MOVLW 0xFF
15A4C  22DA     ADDWFC 0xFDA, F, ACCESS
15A4E  06DE     DECF 0xFDE, F, ACCESS
15A50  0E00     MOVLW 0x0
15A52  5ADD     SUBWFB 0xFDD, F, ACCESS
304:                   n = n / 10;
15A54  0E0A     MOVLW 0xA
15A56  6EE6     MOVWF 0xFE6, ACCESS
15A58  0E00     MOVLW 0x0
15A5A  6EE6     MOVWF 0xFE6, ACCESS
15A5C  0E00     MOVLW 0x0
15A5E  6EE6     MOVWF 0xFE6, ACCESS
15A60  0E00     MOVLW 0x0
15A62  6EE6     MOVWF 0xFE6, ACCESS
15A64  0E00     MOVLW 0x0
15A66  6EE6     MOVWF 0xFE6, ACCESS
15A68  0E00     MOVLW 0x0
15A6A  6EE6     MOVWF 0xFE6, ACCESS
15A6C  0E00     MOVLW 0x0
15A6E  6EE6     MOVWF 0xFE6, ACCESS
15A70  0E00     MOVLW 0x0
15A72  6EE6     MOVWF 0xFE6, ACCESS
15A74  50E1     MOVF 0xFE1, W, ACCESS
15A76  0FE8     ADDLW 0xE8
15A78  6ED9     MOVWF 0xFD9, ACCESS
15A7A  50E2     MOVF 0xFE2, W, ACCESS
15A7C  6EDA     MOVWF 0xFDA, ACCESS
15A7E  0EFF     MOVLW 0xFF
15A80  22DA     ADDWFC 0xFDA, F, ACCESS
15A84  FF7B     NOP
15A86  FFE6     NOP
15A8A  FF7B     NOP
15A8C  FFE6     NOP
15A90  FF7B     NOP
15A92  FFE6     NOP
15A96  FF7B     NOP
15A98  FFE6     NOP
15A9C  FF7B     NOP
15A9E  FFE6     NOP
15AA2  FF7B     NOP
15AA4  FFE6     NOP
15AA8  FF7B     NOP
15AAA  FFE6     NOP
15AAE  FF7B     NOP
15AB0  FFE6     NOP
15AB2  EC67     CALL 0x176CE, 0
15AB4  F0BB     NOP
15AB6  52E5     MOVF 0xFE5, F, ACCESS
15ABA  FF9C     NOP
15ABC  F018     NOP
15ABE  52E5     MOVF 0xFE5, F, ACCESS
15AC2  FF9C     NOP
15AC4  F017     NOP
15AC6  52E5     MOVF 0xFE5, F, ACCESS
15ACA  FF9C     NOP
15ACC  F016     NOP
15ACE  52E5     MOVF 0xFE5, F, ACCESS
15AD2  FF9C     NOP
15AD4  F015     NOP
15AD6  52E5     MOVF 0xFE5, F, ACCESS
15ADA  FF9C     NOP
15ADC  F014     NOP
15ADE  52E5     MOVF 0xFE5, F, ACCESS
15AE2  FF9C     NOP
15AE4  F013     NOP
15AE6  52E5     MOVF 0xFE5, F, ACCESS
15AEA  FF9C     NOP
15AEC  F012     NOP
15AEE  52E5     MOVF 0xFE5, F, ACCESS
15AF2  FF9C     NOP
15AF4  F011     NOP
15AF6  0EF8     MOVLW 0xF8
15AF8  26E1     ADDWF 0xFE1, F, ACCESS
15AFA  0EFF     MOVLW 0xFF
15AFC  22E2     ADDWFC 0xFE2, F, ACCESS
15AFE  0EF0     MOVLW 0xF0
15B02  F047     NOP
15B04  FFE3     NOP
15B06  0EF1     MOVLW 0xF1
15B0A  F04B     NOP
15B0C  FFE3     NOP
15B0E  0EF2     MOVLW 0xF2
15B12  F04F     NOP
15B14  FFE3     NOP
15B16  0EF3     MOVLW 0xF3
15B1A  F053     NOP
15B1C  FFE3     NOP
15B1E  0EF4     MOVLW 0xF4
15B22  F057     NOP
15B24  FFE3     NOP
15B26  0EF5     MOVLW 0xF5
15B2A  F05B     NOP
15B2C  FFE3     NOP
15B2E  0EF6     MOVLW 0xF6
15B32  F05F     NOP
15B34  FFE3     NOP
15B36  0EF7     MOVLW 0xF7
15B3A  F063     NOP
15B3C  FFE3     NOP
305:               }
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
15BB0  0EFA     MOVLW 0xFA
15BB4  FF8C     NOP
15BB6  F001     NOP
15BB8  0EFB     MOVLW 0xFB
15BBA  50E3     MOVF 0xFE3, W, ACCESS
15BBC  1001     IORWF ltemp0, W, ACCESS
15BBE  A4D8     BTFSS 0xFD8, 2, ACCESS
15BC0  D002     BRA 0x5BC6
15BC2  A43E     BTFSS flags, 2, ACCESS
15BC4  D033     BRA 0x5C2C
309:                   --i;
15BC6  50E1     MOVF 0xFE1, W, ACCESS
15BC8  0FF8     ADDLW 0xF8
15BCA  6ED9     MOVWF 0xFD9, ACCESS
15BCC  50E2     MOVF 0xFE2, W, ACCESS
15BCE  6EDA     MOVWF 0xFDA, ACCESS
15BD0  0EFF     MOVLW 0xFF
15BD2  22DA     ADDWFC 0xFDA, F, ACCESS
15BD4  06DE     DECF 0xFDE, F, ACCESS
15BD6  0E00     MOVLW 0x0
15BD8  5ADD     SUBWFB 0xFDD, F, ACCESS
310:                   dbuf[i] = s ? '-' : '+';
15BDA  0EFA     MOVLW 0xFA
15BDE  FF8C     NOP
15BE0  F001     NOP
15BE2  0EFB     MOVLW 0xFB
15BE4  50E3     MOVF 0xFE3, W, ACCESS
15BE6  1001     IORWF ltemp0, W, ACCESS
15BE8  A4D8     BTFSS 0xFD8, 2, ACCESS
15BEA  D002     BRA 0x5BF0
15BEC  0E2B     MOVLW 0x2B
15BEE  D001     BRA 0x5BF2
15BF0  0E2D     MOVLW 0x2D
15BF2  6E0B     MOVWF wtemp5, ACCESS
15BF4  0E00     MOVLW 0x0
15BF6  6E0C     MOVWF 0xC, ACCESS
15BF8  0EEE     MOVLW 0xEE
15BFC  F02F     NOP
15BFE  FFE3     NOP
15C00  0EEF     MOVLW 0xEF
15C04  F033     NOP
15C06  FFE3     NOP
15C08  0EF8     MOVLW 0xF8
15C0C  FF8C     NOP
15C0E  F00B     NOP
15C10  0EF9     MOVLW 0xF9
15C14  FF8C     NOP
15C16  F00C     NOP
15C18  0E97     MOVLW 0x97
15C1A  240B     ADDWF wtemp5, W, ACCESS
15C1C  6ED9     MOVWF 0xFD9, ACCESS
15C1E  0E02     MOVLW 0x2
15C20  200C     ADDWFC 0xC, W, ACCESS
15C22  6EDA     MOVWF 0xFDA, ACCESS
15C24  0EEE     MOVLW 0xEE
15C28  FF8F     NOP
15C2A  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
15C2C  0EFC     MOVLW 0xFC
15C30  FF8F     NOP
15C32  FFE6     NOP
15C36  FF8F     NOP
15C38  FFE6     NOP
15C3A  0E97     MOVLW 0x97
15C3C  6E0B     MOVWF wtemp5, ACCESS
15C3E  0E02     MOVLW 0x2
15C40  6E0C     MOVWF 0xC, ACCESS
15C42  0EF6     MOVLW 0xF6
15C44  50E3     MOVF 0xFE3, W, ACCESS
15C46  260B     ADDWF wtemp5, F, ACCESS
15C48  0EF7     MOVLW 0xF7
15C4A  50E3     MOVF 0xFE3, W, ACCESS
15C4C  220C     ADDWFC 0xC, F, ACCESS
15C50  F02F     NOP
15C52  FFE6     NOP
15C56  F033     NOP
15C58  FFE6     NOP
15C5A  0EE8     MOVLW 0xE8
15C5E  FF8F     NOP
15C60  FFE6     NOP
15C64  FF8F     NOP
15C66  FFE6     NOP
15C68  ECEE     CALL 0x199DC, 0
15C6A  F0CC     NOP
315:           }
15C6C  0EE4     MOVLW 0xE4
15C6E  26E1     ADDWF 0xFE1, F, ACCESS
15C70  0EFF     MOVLW 0xFF
15C72  22E2     ADDWFC 0xFE2, F, ACCESS
15C74  0012     RETURN 0
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
10000  0E38     MOVLW 0x38
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
10008  0EF2     MOVLW 0xF2
1000A  6AE3     CLRF 0xFE3, ACCESS
1000C  0EF3     MOVLW 0xF3
1000E  6AE3     CLRF 0xFE3, ACCESS
327:               g = f;
10010  0EC2     MOVLW 0xC2
10014  FF8C     NOP
10016  F009     NOP
10018  0EC3     MOVLW 0xC3
1001C  FF8C     NOP
1001E  F00A     NOP
10020  0EC4     MOVLW 0xC4
10024  FF8C     NOP
10026  F00B     NOP
10028  0EC5     MOVLW 0xC5
1002C  FF8C     NOP
1002E  F00C     NOP
10030  0ED8     MOVLW 0xD8
10034  F027     NOP
10036  FFE3     NOP
10038  0ED9     MOVLW 0xD9
1003C  F02B     NOP
1003E  FFE3     NOP
10040  0EDA     MOVLW 0xDA
10044  F02F     NOP
10046  FFE3     NOP
10048  0EDB     MOVLW 0xDB
1004C  F033     NOP
1004E  FFE3     NOP
328:               if (g < 0.0) {
10050  0EDB     MOVLW 0xDB
10052  AEE3     BTFSS 0xFE3, 7, ACCESS
10054  D02B     BRA ivt0x8_undefint
329:                   sign = 1;
10056  0E01     MOVLW 0x1
10058  6E0B     MOVWF wtemp5, ACCESS
1005A  0E00     MOVLW 0x0
1005C  6E0C     MOVWF 0xC, ACCESS
1005E  0EF2     MOVLW 0xF2
10062  F02F     NOP
10064  FFE3     NOP
10066  0EF3     MOVLW 0xF3
1006A  F033     NOP
1006C  FFE3     NOP
330:                   g = -g;
1006E  0ED8     MOVLW 0xD8
10072  FF8F     NOP
10074  FFE6     NOP
10078  FF8F     NOP
1007A  FFE6     NOP
1007E  FF8F     NOP
10080  FFE6     NOP
10084  FF8F     NOP
10086  FFE6     NOP
10088  EC0C     CALL 0x1B418, 0
1008A  F0DA     NOP
1008C  0ED8     MOVLW 0xD8
10090  F007     NOP
10092  FFE3     NOP
10094  0ED9     MOVLW 0xD9
10098  F00B     NOP
1009A  FFE3     NOP
1009C  0EDA     MOVLW 0xDA
100A0  F00F     NOP
100A2  FFE3     NOP
100A4  0EDB     MOVLW 0xDB
100A8  F013     NOP
100AA  FFE3     NOP
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
100AC  0EE8     MOVLW 0xE8
100AE  6AE3     CLRF 0xFE3, ACCESS
100B0  0EE9     MOVLW 0xE9
100B2  6AE3     CLRF 0xFE3, ACCESS
335:               w = width;
100B4  0EEE     MOVLW 0xEE
100B8  F0EB     NOP
100BA  FFE3     NOP
100BC  0EEF     MOVLW 0xEF
100C0  F0EF     NOP
100C2  FFE3     NOP
336:               if (sign || (flags & PLUS_FLAG)) {
100C4  0EF2     MOVLW 0xF2
100C8  FF8C     NOP
100CA  F001     NOP
100CC  0EF3     MOVLW 0xF3
100CE  50E3     MOVF 0xFE3, W, ACCESS
100D0  1001     IORWF ltemp0, W, ACCESS
100D2  A4D8     BTFSS 0xFD8, 2, ACCESS
100D4  D002     BRA 0xDA
100D6  A43E     BTFSS flags, 2, ACCESS
100D8  D036     BRA 0x146
337:                   dbuf[n] = sign ? '-' : '+';
100DA  0EF2     MOVLW 0xF2
100DE  FF8C     NOP
100E0  F001     NOP
100E2  0EF3     MOVLW 0xF3
100E4  50E3     MOVF 0xFE3, W, ACCESS
100E6  1001     IORWF ltemp0, W, ACCESS
100E8  A4D8     BTFSS 0xFD8, 2, ACCESS
100EA  D002     BRA 0xF0
100EC  0E2B     MOVLW 0x2B
100EE  D001     BRA 0xF2
100F0  0E2D     MOVLW 0x2D
100F2  6E0B     MOVWF wtemp5, ACCESS
100F4  0E00     MOVLW 0x0
100F6  6E0C     MOVWF 0xC, ACCESS
100F8  0ED2     MOVLW 0xD2
100FC  F02F     NOP
100FE  FFE3     NOP
10100  0ED3     MOVLW 0xD3
10104  F033     NOP
10106  FFE3     NOP
10108  0ED2     MOVLW 0xD2
1010C  FF8C     NOP
1010E  F297     NOP
338:                   ++n;
10110  0EE8     MOVLW 0xE8
10112  50E3     MOVF 0xFE3, W, ACCESS
10114  0F01     ADDLW 0x1
10116  6E01     MOVWF ltemp0, ACCESS
10118  0EE8     MOVLW 0xE8
1011C  F007     NOP
1011E  FFE3     NOP
10120  6A01     CLRF ltemp0, ACCESS
10122  0EE9     MOVLW 0xE9
10124  50E3     MOVF 0xFE3, W, ACCESS
10126  2001     ADDWFC ltemp0, W, ACCESS
10128  6E01     MOVWF ltemp0, ACCESS
1012A  0EE9     MOVLW 0xE9
1012E  F007     NOP
10130  FFE3     NOP
339:                   --w;
10132  50E1     MOVF 0xFE1, W, ACCESS
10134  0FEE     ADDLW 0xEE
10136  6ED9     MOVWF 0xFD9, ACCESS
10138  50E2     MOVF 0xFE2, W, ACCESS
1013A  6EDA     MOVWF 0xFDA, ACCESS
1013C  0EFF     MOVLW 0xFF
1013E  22DA     ADDWFC 0xFDA, F, ACCESS
10140  06DE     DECF 0xFDE, F, ACCESS
10142  0E00     MOVLW 0x0
10144  5ADD     SUBWFB 0xFDD, F, ACCESS
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
10146  0ED8     MOVLW 0xD8
1014A  FF8F     NOP
1014C  FFE6     NOP
10150  FF8F     NOP
10152  FFE6     NOP
10156  FF8F     NOP
10158  FFE6     NOP
1015C  FF8F     NOP
1015E  FFE6     NOP
10160  ECED     CALL 0x189DA, 0
10162  F0C4     NOP
10164  0401     DECF ltemp0, W, ACCESS
10166  1002     IORWF ttemp5, W, ACCESS
10168  A4D8     BTFSS 0xFD8, 2, ACCESS
1016A  D076     BRA 0x258
344:                   if (isupper((int)c)) {
1016C  0EBF     MOVLW 0xBF
1016E  6E0B     MOVWF wtemp5, ACCESS
10170  0EFF     MOVLW 0xFF
10172  6E0C     MOVWF 0xC, ACCESS
10174  0EC1     MOVLW 0xC1
10176  50E3     MOVF 0xFE3, W, ACCESS
10178  6E09     MOVWF ltemp2, ACCESS
1017A  6A0A     CLRF ttemp3, ACCESS
1017C  500B     MOVF wtemp5, W, ACCESS
1017E  2609     ADDWF ltemp2, F, ACCESS
10180  500C     MOVF 0xC, W, ACCESS
10182  220A     ADDWFC ttemp3, F, ACCESS
10184  500A     MOVF ttemp3, W, ACCESS
10186  E106     BNZ 0x194
10188  0E1A     MOVLW 0x1A
1018A  5C09     SUBWF ltemp2, W, ACCESS
1018C  B0D8     BTFSC 0xFD8, 0, ACCESS
1018E  D002     BRA 0x194
10190  0E01     MOVLW 0x1
10192  D001     BRA 0x196
10194  0E00     MOVLW 0x0
10196  6E0B     MOVWF wtemp5, ACCESS
10198  6A0C     CLRF 0xC, ACCESS
1019A  0ED0     MOVLW 0xD0
1019E  F02F     NOP
101A0  FFE3     NOP
101A2  0ED1     MOVLW 0xD1
101A6  F033     NOP
101A8  FFE3     NOP
101AA  0ED0     MOVLW 0xD0
101AE  FF8C     NOP
101B0  F001     NOP
101B2  0ED1     MOVLW 0xD1
101B4  50E3     MOVF 0xFE3, W, ACCESS
101B6  1001     IORWF ltemp0, W, ACCESS
101B8  B4D8     BTFSC 0xFD8, 2, ACCESS
101BA  D017     BRA 0x1EA
345:                       strcpy(&dbuf[n], "INF");
101BC  0ED7     MOVLW 0xD7
101BE  6EE6     MOVWF 0xFE6, ACCESS
101C0  0EFF     MOVLW 0xFF
101C2  6EE6     MOVWF 0xFE6, ACCESS
101C4  0E97     MOVLW 0x97
101C6  6E0B     MOVWF wtemp5, ACCESS
101C8  0E02     MOVLW 0x2
101CA  6E0C     MOVWF 0xC, ACCESS
101CC  0EE6     MOVLW 0xE6
101CE  50E3     MOVF 0xFE3, W, ACCESS
101D0  260B     ADDWF wtemp5, F, ACCESS
101D2  0EE7     MOVLW 0xE7
101D4  50E3     MOVF 0xFE3, W, ACCESS
101D6  220C     ADDWFC 0xC, F, ACCESS
101DA  F02F     NOP
101DC  FFE6     NOP
101E0  F033     NOP
101E2  FFE6     NOP
101E4  EC41     CALL 0x1A282, 0
101E6  F0D1     NOP
346:                   } else {
101E8  D016     BRA 0x216
347:                       strcpy(&dbuf[n], "inf");
101EA  0EDF     MOVLW 0xDF
101EC  6EE6     MOVWF 0xFE6, ACCESS
101EE  0EFF     MOVLW 0xFF
101F0  6EE6     MOVWF 0xFE6, ACCESS
101F2  0E97     MOVLW 0x97
101F4  6E0B     MOVWF wtemp5, ACCESS
101F6  0E02     MOVLW 0x2
101F8  6E0C     MOVWF 0xC, ACCESS
101FA  0EE6     MOVLW 0xE6
101FC  50E3     MOVF 0xFE3, W, ACCESS
101FE  260B     ADDWF wtemp5, F, ACCESS
10200  0EE7     MOVLW 0xE7
10202  50E3     MOVF 0xFE3, W, ACCESS
10204  220C     ADDWFC 0xC, F, ACCESS
10208  F02F     NOP
1020A  FFE6     NOP
1020E  F033     NOP
10210  FFE6     NOP
10212  EC41     CALL 0x1A282, 0
10214  F0D1     NOP
348:                   }
349:                   w -= CSTRLEN("inf");
10216  50E1     MOVF 0xFE1, W, ACCESS
10218  0FEE     ADDLW 0xEE
1021A  6ED9     MOVWF 0xFD9, ACCESS
1021C  50E2     MOVF 0xFE2, W, ACCESS
1021E  6EDA     MOVWF 0xFDA, ACCESS
10220  0EFF     MOVLW 0xFF
10222  22DA     ADDWFC 0xFDA, F, ACCESS
10224  0EFD     MOVLW 0xFD
10226  26DE     ADDWF 0xFDE, F, ACCESS
10228  0EFF     MOVLW 0xFF
1022A  22DD     ADDWFC 0xFDD, F, ACCESS
350:                   return pad(fp, &dbuf[0], w);
1022C  0EEE     MOVLW 0xEE
10230  FF8F     NOP
10232  FFE6     NOP
10236  FF8F     NOP
10238  FFE6     NOP
1023A  0E97     MOVLW 0x97
1023C  6EE6     MOVWF 0xFE6, ACCESS
1023E  0E02     MOVLW 0x2
10240  6EE6     MOVWF 0xFE6, ACCESS
10242  0EC2     MOVLW 0xC2
10246  FF8F     NOP
10248  FFE6     NOP
1024C  FF8F     NOP
1024E  FFE6     NOP
10250  ECEE     CALL 0x199DC, 0
10252  F0CC     NOP
10254  EF1D     GOTO 0x1123A
10256  F089     NOP
351:               }
352:               if (isnan(g)) {
10258  0ED8     MOVLW 0xD8
1025C  FF8F     NOP
1025E  FFE6     NOP
10262  FF8F     NOP
10264  FFE6     NOP
10268  FF8F     NOP
1026A  FFE6     NOP
1026E  FF8F     NOP
10270  FFE6     NOP
10272  ECED     CALL 0x189DA, 0
10274  F0C4     NOP
10276  5001     MOVF ltemp0, W, ACCESS
10278  1002     IORWF ttemp5, W, ACCESS
1027A  A4D8     BTFSS 0xFD8, 2, ACCESS
1027C  D056     BRA 0x32A
353:                   if (isupper((int)c)) {
1027E  0EBF     MOVLW 0xBF
10280  6E0B     MOVWF wtemp5, ACCESS
10282  0EFF     MOVLW 0xFF
10284  6E0C     MOVWF 0xC, ACCESS
10286  0EC1     MOVLW 0xC1
10288  50E3     MOVF 0xFE3, W, ACCESS
1028A  6E09     MOVWF ltemp2, ACCESS
1028C  6A0A     CLRF ttemp3, ACCESS
1028E  500B     MOVF wtemp5, W, ACCESS
10290  2609     ADDWF ltemp2, F, ACCESS
10292  500C     MOVF 0xC, W, ACCESS
10294  220A     ADDWFC ttemp3, F, ACCESS
10296  500A     MOVF ttemp3, W, ACCESS
10298  E106     BNZ 0x2A6
1029A  0E1A     MOVLW 0x1A
1029C  5C09     SUBWF ltemp2, W, ACCESS
1029E  B0D8     BTFSC 0xFD8, 0, ACCESS
102A0  D002     BRA 0x2A6
102A2  0E01     MOVLW 0x1
102A4  D001     BRA 0x2A8
102A6  0E00     MOVLW 0x0
102A8  6E0B     MOVWF wtemp5, ACCESS
102AA  6A0C     CLRF 0xC, ACCESS
102AC  0ECE     MOVLW 0xCE
102B0  F02F     NOP
102B2  FFE3     NOP
102B4  0ECF     MOVLW 0xCF
102B8  F033     NOP
102BA  FFE3     NOP
102BC  0ECE     MOVLW 0xCE
102C0  FF8C     NOP
102C2  F001     NOP
102C4  0ECF     MOVLW 0xCF
102C6  50E3     MOVF 0xFE3, W, ACCESS
102C8  1001     IORWF ltemp0, W, ACCESS
102CA  B4D8     BTFSC 0xFD8, 2, ACCESS
102CC  D017     BRA 0x2FC
354:                       strcpy(&dbuf[n], "NAN");
102CE  0EDB     MOVLW 0xDB
102D0  6EE6     MOVWF 0xFE6, ACCESS
102D2  0EFF     MOVLW 0xFF
102D4  6EE6     MOVWF 0xFE6, ACCESS
102D6  0E97     MOVLW 0x97
102D8  6E0B     MOVWF wtemp5, ACCESS
102DA  0E02     MOVLW 0x2
102DC  6E0C     MOVWF 0xC, ACCESS
102DE  0EE6     MOVLW 0xE6
102E0  50E3     MOVF 0xFE3, W, ACCESS
102E2  260B     ADDWF wtemp5, F, ACCESS
102E4  0EE7     MOVLW 0xE7
102E6  50E3     MOVF 0xFE3, W, ACCESS
102E8  220C     ADDWFC 0xC, F, ACCESS
102EC  F02F     NOP
102EE  FFE6     NOP
102F2  F033     NOP
102F4  FFE6     NOP
102F6  EC41     CALL 0x1A282, 0
102F8  F0D1     NOP
355:                   } else {
102FA  D78D     BRA 0x216
356:                       strcpy(&dbuf[n], "nan");
102FC  0EE3     MOVLW 0xE3
102FE  6EE6     MOVWF 0xFE6, ACCESS
10300  0EFF     MOVLW 0xFF
10302  6EE6     MOVWF 0xFE6, ACCESS
10304  0E97     MOVLW 0x97
10306  6E0B     MOVWF wtemp5, ACCESS
10308  0E02     MOVLW 0x2
1030A  6E0C     MOVWF 0xC, ACCESS
1030C  0EE6     MOVLW 0xE6
1030E  50E3     MOVF 0xFE3, W, ACCESS
10310  260B     ADDWF wtemp5, F, ACCESS
10312  0EE7     MOVLW 0xE7
10314  50E3     MOVF 0xFE3, W, ACCESS
10316  220C     ADDWFC 0xC, F, ACCESS
1031A  F02F     NOP
1031C  FFE6     NOP
10320  F033     NOP
10322  FFE6     NOP
10324  EC41     CALL 0x1A282, 0
10326  F0D1     NOP
10328  D776     BRA 0x216
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
1032A  0E00     MOVLW 0x0
1032C  6E09     MOVWF ltemp2, ACCESS
1032E  0E00     MOVLW 0x0
10330  6E0A     MOVWF ttemp3, ACCESS
10332  0E80     MOVLW 0x80
10334  6E0B     MOVWF wtemp5, ACCESS
10336  0E3F     MOVLW 0x3F
10338  6E0C     MOVWF 0xC, ACCESS
1033A  0ED4     MOVLW 0xD4
1033E  F027     NOP
10340  FFE3     NOP
10342  0ED5     MOVLW 0xD5
10346  F02B     NOP
10348  FFE3     NOP
1034A  0ED6     MOVLW 0xD6
1034E  F02F     NOP
10350  FFE3     NOP
10352  0ED7     MOVLW 0xD7
10356  F033     NOP
10358  FFE3     NOP
364:               e = 0;
1035A  0EEA     MOVLW 0xEA
1035C  6AE3     CLRF 0xFE3, ACCESS
1035E  0EEB     MOVLW 0xEB
10360  6AE3     CLRF 0xFE3, ACCESS
365:               if (!(g == 0.0)) {
10362  0E00     MOVLW 0x0
10364  6EE6     MOVWF 0xFE6, ACCESS
10366  0E00     MOVLW 0x0
10368  6EE6     MOVWF 0xFE6, ACCESS
1036A  0E00     MOVLW 0x0
1036C  6EE6     MOVWF 0xFE6, ACCESS
1036E  0E00     MOVLW 0x0
10370  6EE6     MOVWF 0xFE6, ACCESS
10372  0ED4     MOVLW 0xD4
10376  FF8F     NOP
10378  FFE6     NOP
1037C  FF8F     NOP
1037E  FFE6     NOP
10382  FF8F     NOP
10384  FFE6     NOP
10388  FF8F     NOP
1038A  FFE6     NOP
1038C  ECAB     CALL 0x1A356, 0
1038E  F0D1     NOP
10390  A001     BTFSS ltemp0, 0, ACCESS
10392  D039     BRA 0x406
10394  D0BC     BRA 0x50E
366:                   while (!(g < (u*10.0))) {
10406  0E00     MOVLW 0x0
10408  6EE6     MOVWF 0xFE6, ACCESS
1040A  0E00     MOVLW 0x0
1040C  6EE6     MOVWF 0xFE6, ACCESS
1040E  0E20     MOVLW 0x20
10410  6EE6     MOVWF 0xFE6, ACCESS
10412  0E41     MOVLW 0x41
10414  6EE6     MOVWF 0xFE6, ACCESS
10416  0ED0     MOVLW 0xD0
1041A  FF8F     NOP
1041C  FFE6     NOP
10420  FF8F     NOP
10422  FFE6     NOP
10426  FF8F     NOP
10428  FFE6     NOP
1042C  FF8F     NOP
1042E  FFE6     NOP
10430  ECC1     CALL 0x13D82, 0
10432  F09E     NOP
10436  F007     NOP
10438  FFE6     NOP
1043C  F00B     NOP
1043E  FFE6     NOP
10442  F00F     NOP
10444  FFE6     NOP
10448  F013     NOP
1044A  FFE6     NOP
1044C  0ED4     MOVLW 0xD4
10450  FF8F     NOP
10452  FFE6     NOP
10456  FF8F     NOP
10458  FFE6     NOP
1045C  FF8F     NOP
1045E  FFE6     NOP
10462  FF8F     NOP
10464  FFE6     NOP
10466  ECF4     CALL 0x18FE8, 0
10468  F0C7     NOP
1046A  A001     BTFSS ltemp0, 0, ACCESS
1046C  D032     BRA 0x4D2
1046E  D793     BRA 0x396
367:                       u = u*10.0;
10396  0E00     MOVLW 0x0
10398  6EE6     MOVWF 0xFE6, ACCESS
1039A  0E00     MOVLW 0x0
1039C  6EE6     MOVWF 0xFE6, ACCESS
1039E  0E20     MOVLW 0x20
103A0  6EE6     MOVWF 0xFE6, ACCESS
103A2  0E41     MOVLW 0x41
103A4  6EE6     MOVWF 0xFE6, ACCESS
103A6  0ED0     MOVLW 0xD0
103AA  FF8F     NOP
103AC  FFE6     NOP
103B0  FF8F     NOP
103B2  FFE6     NOP
103B6  FF8F     NOP
103B8  FFE6     NOP
103BC  FF8F     NOP
103BE  FFE6     NOP
103C0  ECC1     CALL 0x13D82, 0
103C2  F09E     NOP
103C4  0ED4     MOVLW 0xD4
103C8  F007     NOP
103CA  FFE3     NOP
103CC  0ED5     MOVLW 0xD5
103D0  F00B     NOP
103D2  FFE3     NOP
103D4  0ED6     MOVLW 0xD6
103D8  F00F     NOP
103DA  FFE3     NOP
103DC  0ED7     MOVLW 0xD7
103E0  F013     NOP
103E2  FFE3     NOP
368:                       ++e;
103E4  0EEA     MOVLW 0xEA
103E6  50E3     MOVF 0xFE3, W, ACCESS
103E8  0F01     ADDLW 0x1
103EA  6E01     MOVWF ltemp0, ACCESS
103EC  0EEA     MOVLW 0xEA
103F0  F007     NOP
103F2  FFE3     NOP
103F4  6A01     CLRF ltemp0, ACCESS
103F6  0EEB     MOVLW 0xEB
103F8  50E3     MOVF 0xFE3, W, ACCESS
103FA  2001     ADDWFC ltemp0, W, ACCESS
103FC  6E01     MOVWF ltemp0, ACCESS
103FE  0EEB     MOVLW 0xEB
10402  F007     NOP
10404  FFE3     NOP
369:                   }
370:                   while (g < u) {
104D2  0ED4     MOVLW 0xD4
104D6  FF8F     NOP
104D8  FFE6     NOP
104DC  FF8F     NOP
104DE  FFE6     NOP
104E2  FF8F     NOP
104E4  FFE6     NOP
104E8  FF8F     NOP
104EA  FFE6     NOP
104EC  0ED4     MOVLW 0xD4
104F0  FF8F     NOP
104F2  FFE6     NOP
104F6  FF8F     NOP
104F8  FFE6     NOP
104FC  FF8F     NOP
104FE  FFE6     NOP
10502  FF8F     NOP
10504  FFE6     NOP
10506  ECF4     CALL 0x18FE8, 0
10508  F0C7     NOP
1050A  A001     BTFSS ltemp0, 0, ACCESS
1050C  D7B1     BRA 0x470
371:                       u = u/10.0;
10470  0E00     MOVLW 0x0
10472  6EE6     MOVWF 0xFE6, ACCESS
10474  0E00     MOVLW 0x0
10476  6EE6     MOVWF 0xFE6, ACCESS
10478  0E20     MOVLW 0x20
1047A  6EE6     MOVWF 0xFE6, ACCESS
1047C  0E41     MOVLW 0x41
1047E  6EE6     MOVWF 0xFE6, ACCESS
10480  0ED0     MOVLW 0xD0
10484  FF8F     NOP
10486  FFE6     NOP
1048A  FF8F     NOP
1048C  FFE6     NOP
10490  FF8F     NOP
10492  FFE6     NOP
10496  FF8F     NOP
10498  FFE6     NOP
1049A  ECB4     CALL 0x14D68, 0
1049C  F0A6     NOP
1049E  0ED4     MOVLW 0xD4
104A2  F007     NOP
104A4  FFE3     NOP
104A6  0ED5     MOVLW 0xD5
104AA  F00B     NOP
104AC  FFE3     NOP
104AE  0ED6     MOVLW 0xD6
104B2  F00F     NOP
104B4  FFE3     NOP
104B6  0ED7     MOVLW 0xD7
104BA  F013     NOP
104BC  FFE3     NOP
372:                       --e;
104BE  50E1     MOVF 0xFE1, W, ACCESS
104C0  0FEA     ADDLW 0xEA
104C2  6ED9     MOVWF 0xFD9, ACCESS
104C4  50E2     MOVF 0xFE2, W, ACCESS
104C6  6EDA     MOVWF 0xFDA, ACCESS
104C8  0EFF     MOVLW 0xFF
104CA  22DA     ADDWFC 0xFDA, F, ACCESS
104CC  06DE     DECF 0xFDE, F, ACCESS
104CE  0E00     MOVLW 0x0
104D0  5ADD     SUBWFB 0xFDD, F, ACCESS
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
1050E  0EC1     MOVLW 0xC1
10510  50E3     MOVF 0xFE3, W, ACCESS
10512  6EE6     MOVWF 0xFE6, ACCESS
10514  0E00     MOVLW 0x0
10516  6EE6     MOVWF 0xFE6, ACCESS
10518  EC6C     CALL 0x1ACD8, 0
1051A  F0D6     NOP
1051C  0EFE     MOVLW 0xFE
10520  F007     NOP
10522  FFE3     NOP
378:               nmode = mode;
10524  0EFE     MOVLW 0xFE
10528  FF8C     NOP
1052A  F001     NOP
1052C  0EFF     MOVLW 0xFF
10530  F007     NOP
10532  FFE3     NOP
379:               if (mode == 'g') {
10534  0EFE     MOVLW 0xFE
10538  FF8C     NOP
1053A  F001     NOP
1053C  0E67     MOVLW 0x67
1053E  1801     XORWF ltemp0, W, ACCESS
10540  A4D8     BTFSS 0xFD8, 2, ACCESS
10542  D025     BRA 0x58E
380:           		if (prec == 0) {
10544  503C     MOVF prec, W, ACCESS
10546  103D     IORWF 0x3D, W, ACCESS
10548  A4D8     BTFSS 0xFD8, 2, ACCESS
1054A  D004     BRA 0x554
381:           			prec = 1;
1054C  0E00     MOVLW 0x0
1054E  6E3D     MOVWF 0x3D, ACCESS
10550  0E01     MOVLW 0x1
10552  6E3C     MOVWF prec, ACCESS
382:           		}
383:                   p = (0 < prec) ? prec : 6;
10554  BE3D     BTFSC 0x3D, 7, ACCESS
10556  D005     BRA 0x562
10558  503D     MOVF 0x3D, W, ACCESS
1055A  E110     BNZ 0x57C
1055C  043C     DECF prec, W, ACCESS
1055E  B0D8     BTFSC 0xFD8, 0, ACCESS
10560  D00D     BRA 0x57C
10562  0E06     MOVLW 0x6
10564  6E0B     MOVWF wtemp5, ACCESS
10566  0E00     MOVLW 0x0
10568  6E0C     MOVWF 0xC, ACCESS
1056A  0EF0     MOVLW 0xF0
1056E  F02F     NOP
10570  FFE3     NOP
10572  0EF1     MOVLW 0xF1
10576  F033     NOP
10578  FFE3     NOP
1057A  D00C     BRA 0x594
1057C  0EF0     MOVLW 0xF0
10580  F0F3     NOP
10582  FFE3     NOP
10584  0EF1     MOVLW 0xF1
10588  F0F7     NOP
1058A  FFE3     NOP
1058C  D003     BRA 0x594
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
1058E  AE3D     BTFSS 0x3D, 7, ACCESS
10590  D7F5     BRA 0x57C
10592  D7E7     BRA 0x562
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
10594  0EFE     MOVLW 0xFE
10598  FF8C     NOP
1059A  F001     NOP
1059C  0E67     MOVLW 0x67
1059E  1801     XORWF ltemp0, W, ACCESS
105A0  A4D8     BTFSS 0xFD8, 2, ACCESS
105A2  D02F     BRA 0x602
390:                   if (!(e < -4) && !((p - 1) < e)) {
105A4  0EEB     MOVLW 0xEB
105A6  AEE3     BTFSS 0xFE3, 7, ACCESS
105A8  D00E     BRA 0x5C6
105AA  0EEA     MOVLW 0xEA
105AE  FF8C     NOP
105B0  F001     NOP
105B2  0EFC     MOVLW 0xFC
105B4  5E01     SUBWF ltemp0, F, ACCESS
105B6  0EEB     MOVLW 0xEB
105BA  FF8C     NOP
105BC  F001     NOP
105BE  0EFF     MOVLW 0xFF
105C0  5A01     SUBWFB ltemp0, F, ACCESS
105C2  A0D8     BTFSS 0xFD8, 0, ACCESS
105C4  D018     BRA 0x5F6
105C6  0EF0     MOVLW 0xF0
105C8  50E3     MOVF 0xFE3, W, ACCESS
105CA  0FFF     ADDLW 0xFF
105CC  6E0B     MOVWF wtemp5, ACCESS
105CE  0EF1     MOVLW 0xF1
105D2  FF8C     NOP
105D4  F00C     NOP
105D6  0EFF     MOVLW 0xFF
105D8  220C     ADDWFC 0xC, F, ACCESS
105DA  0EEA     MOVLW 0xEA
105DC  50E3     MOVF 0xFE3, W, ACCESS
105DE  5C0B     SUBWF wtemp5, W, ACCESS
105E0  500C     MOVF 0xC, W, ACCESS
105E2  0A80     XORLW 0x80
105E4  6E01     MOVWF ltemp0, ACCESS
105E6  0EEB     MOVLW 0xEB
105E8  50E3     MOVF 0xFE3, W, ACCESS
105EA  0A80     XORLW 0x80
105EC  5801     SUBWFB ltemp0, W, ACCESS
105EE  A0D8     BTFSS 0xFD8, 0, ACCESS
105F0  D002     BRA 0x5F6
391:                       nmode = 'f';
105F2  0E66     MOVLW 0x66
105F4  D001     BRA 0x5F8
392:                   } else {
393:                       nmode = 'e';
105F6  0E65     MOVLW 0x65
105F8  6E0C     MOVWF 0xC, ACCESS
105FA  0EFF     MOVLW 0xFF
105FE  F033     NOP
10600  FFE3     NOP
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
10602  0EF0     MOVLW 0xF0
10606  FF8C     NOP
10608  F001     NOP
1060A  0EF8     MOVLW 0xF8
1060E  F007     NOP
10610  FFE3     NOP
10612  0EF1     MOVLW 0xF1
10616  FF8C     NOP
10618  F001     NOP
1061A  0EF9     MOVLW 0xF9
1061E  F007     NOP
10620  FFE3     NOP
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
10622  0EFE     MOVLW 0xFE
10626  FF8C     NOP
10628  F001     NOP
1062A  0E67     MOVLW 0x67
1062C  1801     XORWF ltemp0, W, ACCESS
1062E  A4D8     BTFSS 0xFD8, 2, ACCESS
10630  D00B     BRA 0x648
10632  0EFF     MOVLW 0xFF
10636  FF8C     NOP
10638  F001     NOP
1063A  0E66     MOVLW 0x66
1063C  1801     XORWF ltemp0, W, ACCESS
1063E  A4D8     BTFSS 0xFD8, 2, ACCESS
10640  D014     BRA 0x66A
10642  0EEB     MOVLW 0xEB
10644  AEE3     BTFSS 0xFE3, 7, ACCESS
10646  D011     BRA 0x66A
400:                   ++m;
10648  0EF8     MOVLW 0xF8
1064A  50E3     MOVF 0xFE3, W, ACCESS
1064C  0F01     ADDLW 0x1
1064E  6E01     MOVWF ltemp0, ACCESS
10650  0EF8     MOVLW 0xF8
10654  F007     NOP
10656  FFE3     NOP
10658  6A01     CLRF ltemp0, ACCESS
1065A  0EF9     MOVLW 0xF9
1065C  50E3     MOVF 0xFE3, W, ACCESS
1065E  2001     ADDWFC ltemp0, W, ACCESS
10660  6E01     MOVWF ltemp0, ACCESS
10662  0EF9     MOVLW 0xF9
10666  F007     NOP
10668  FFE3     NOP
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
1066A  0EFF     MOVLW 0xFF
1066E  FF8C     NOP
10670  F001     NOP
10672  0E66     MOVLW 0x66
10674  1801     XORWF ltemp0, W, ACCESS
10676  A4D8     BTFSS 0xFD8, 2, ACCESS
10678  D03B     BRA 0x6F0
405:                   if (e < 0) {
1067A  0EEB     MOVLW 0xEB
1067C  AEE3     BTFSS 0xFE3, 7, ACCESS
1067E  D01C     BRA 0x6B8
406:                       u = 1.0;
10680  0E00     MOVLW 0x0
10682  6E09     MOVWF ltemp2, ACCESS
10684  0E00     MOVLW 0x0
10686  6E0A     MOVWF ttemp3, ACCESS
10688  0E80     MOVLW 0x80
1068A  6E0B     MOVWF wtemp5, ACCESS
1068C  0E3F     MOVLW 0x3F
1068E  6E0C     MOVWF 0xC, ACCESS
10690  0ED4     MOVLW 0xD4
10694  F027     NOP
10696  FFE3     NOP
10698  0ED5     MOVLW 0xD5
1069C  F02B     NOP
1069E  FFE3     NOP
106A0  0ED6     MOVLW 0xD6
106A4  F02F     NOP
106A6  FFE3     NOP
106A8  0ED7     MOVLW 0xD7
106AC  F033     NOP
106AE  FFE3     NOP
407:                       e = 0;
106B0  0EEA     MOVLW 0xEA
106B2  6AE3     CLRF 0xFE3, ACCESS
106B4  0EEB     MOVLW 0xEB
106B6  6AE3     CLRF 0xFE3, ACCESS
408:                   }
409:                   if (!(mode == 'g')) {
106B8  0EFE     MOVLW 0xFE
106BC  FF8C     NOP
106BE  F001     NOP
106C0  0E67     MOVLW 0x67
106C2  1801     XORWF ltemp0, W, ACCESS
106C4  B4D8     BTFSC 0xFD8, 2, ACCESS
106C6  D014     BRA 0x6F0
410:                       m += e;
106C8  0EF8     MOVLW 0xF8
106CA  50E3     MOVF 0xFE3, W, ACCESS
106CC  6E01     MOVWF ltemp0, ACCESS
106CE  0EEA     MOVLW 0xEA
106D0  50E3     MOVF 0xFE3, W, ACCESS
106D2  2601     ADDWF ltemp0, F, ACCESS
106D4  0EF8     MOVLW 0xF8
106D8  F007     NOP
106DA  FFE3     NOP
106DC  0EF9     MOVLW 0xF9
106DE  50E3     MOVF 0xFE3, W, ACCESS
106E0  6E01     MOVWF ltemp0, ACCESS
106E2  0EEB     MOVLW 0xEB
106E4  50E3     MOVF 0xFE3, W, ACCESS
106E6  2201     ADDWFC ltemp0, F, ACCESS
106E8  0EF9     MOVLW 0xF9
106EC  F007     NOP
106EE  FFE3     NOP
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
106F0  0EEC     MOVLW 0xEC
106F2  6AE3     CLRF 0xFE3, ACCESS
106F4  0EED     MOVLW 0xED
106F6  6AE3     CLRF 0xFE3, ACCESS
416:               h = g;
106F8  0ED8     MOVLW 0xD8
106FC  FF8C     NOP
106FE  F009     NOP
10700  0ED9     MOVLW 0xD9
10704  FF8C     NOP
10706  F00A     NOP
10708  0EDA     MOVLW 0xDA
1070C  FF8C     NOP
1070E  F00B     NOP
10710  0EDB     MOVLW 0xDB
10714  FF8C     NOP
10716  F00C     NOP
10718  0EE0     MOVLW 0xE0
1071C  F027     NOP
1071E  FFE3     NOP
10720  0EE1     MOVLW 0xE1
10724  F02B     NOP
10726  FFE3     NOP
10728  0EE2     MOVLW 0xE2
1072C  F02F     NOP
1072E  FFE3     NOP
10730  0EE3     MOVLW 0xE3
10734  F033     NOP
10736  FFE3     NOP
417:               ou = u;
10738  0ED4     MOVLW 0xD4
1073C  FF8C     NOP
1073E  F009     NOP
10740  0ED5     MOVLW 0xD5
10744  FF8C     NOP
10746  F00A     NOP
10748  0ED6     MOVLW 0xD6
1074C  FF8C     NOP
1074E  F00B     NOP
10750  0ED7     MOVLW 0xD7
10754  FF8C     NOP
10756  F00C     NOP
10758  0EE4     MOVLW 0xE4
1075C  F027     NOP
1075E  FFE3     NOP
10760  0EE5     MOVLW 0xE5
10764  F02B     NOP
10766  FFE3     NOP
10768  0EE6     MOVLW 0xE6
1076C  F02F     NOP
1076E  FFE3     NOP
10770  0EE7     MOVLW 0xE7
10774  F033     NOP
10776  FFE3     NOP
418:               while (i < m) {
10778  D0D6     BRA 0x926
10926  50E1     MOVF 0xFE1, W, ACCESS
10928  0FEC     ADDLW 0xEC
1092A  6ED9     MOVWF 0xFD9, ACCESS
1092C  50E2     MOVF 0xFE2, W, ACCESS
1092E  6EDA     MOVWF 0xFDA, ACCESS
10930  0EFF     MOVLW 0xFF
10932  22DA     ADDWFC 0xFDA, F, ACCESS
10934  0EF8     MOVLW 0xF8
10936  50E3     MOVF 0xFE3, W, ACCESS
10938  5CDE     SUBWF 0xFDE, W, ACCESS
1093A  50DE     MOVF 0xFDE, W, ACCESS
1093C  0A80     XORLW 0x80
1093E  6E01     MOVWF ltemp0, ACCESS
10940  0EF9     MOVLW 0xF9
10942  50E3     MOVF 0xFE3, W, ACCESS
10944  0A80     XORLW 0x80
10946  5801     SUBWFB ltemp0, W, ACCESS
10948  A0D8     BTFSS 0xFD8, 0, ACCESS
1094A  D717     BRA 0x77A
419:                   l = floor(h/u);
1077A  0ED4     MOVLW 0xD4
1077E  FF8F     NOP
10780  FFE6     NOP
10784  FF8F     NOP
10786  FFE6     NOP
1078A  FF8F     NOP
1078C  FFE6     NOP
10790  FF8F     NOP
10792  FFE6     NOP
10794  0EDC     MOVLW 0xDC
10798  FF8F     NOP
1079A  FFE6     NOP
1079E  FF8F     NOP
107A0  FFE6     NOP
107A4  FF8F     NOP
107A6  FFE6     NOP
107AA  FF8F     NOP
107AC  FFE6     NOP
107AE  ECB4     CALL 0x14D68, 0
107B0  F0A6     NOP
107B4  F007     NOP
107B6  FFE6     NOP
107BA  F00B     NOP
107BC  FFE6     NOP
107C0  F00F     NOP
107C2  FFE6     NOP
107C6  F013     NOP
107C8  FFE6     NOP
107CA  EC3E     CALL 0x1647C, 0
107CC  F0B2     NOP
107CE  0EDC     MOVLW 0xDC
107D2  F007     NOP
107D4  FFE3     NOP
107D6  0EDD     MOVLW 0xDD
107DA  F00B     NOP
107DC  FFE3     NOP
107DE  0EDE     MOVLW 0xDE
107E2  F00F     NOP
107E4  FFE3     NOP
107E6  0EDF     MOVLW 0xDF
107EA  F013     NOP
107EC  FFE3     NOP
420:                   d = (int)l;
107EE  0EDC     MOVLW 0xDC
107F2  FF8F     NOP
107F4  FFE6     NOP
107F8  FF8F     NOP
107FA  FFE6     NOP
107FE  FF8F     NOP
10800  FFE6     NOP
10804  FF8F     NOP
10806  FFE6     NOP
10808  EC3B     CALL 0x18E76, 0
1080A  F0C7     NOP
1080E  F004     NOP
10810  F00B     NOP
10814  F008     NOP
10816  F00C     NOP
10818  0EF4     MOVLW 0xF4
1081C  F02F     NOP
1081E  FFE3     NOP
10820  0EF5     MOVLW 0xF5
10824  F033     NOP
10826  FFE3     NOP
421:                   h -= l*u;
10828  0ED4     MOVLW 0xD4
1082C  FF8F     NOP
1082E  FFE6     NOP
10832  FF8F     NOP
10834  FFE6     NOP
10838  FF8F     NOP
1083A  FFE6     NOP
1083E  FF8F     NOP
10840  FFE6     NOP
10842  0ED8     MOVLW 0xD8
10846  FF8F     NOP
10848  FFE6     NOP
1084C  FF8F     NOP
1084E  FFE6     NOP
10852  FF8F     NOP
10854  FFE6     NOP
10858  FF8F     NOP
1085A  FFE6     NOP
1085C  ECC1     CALL 0x13D82, 0
1085E  F09E     NOP
10862  F007     NOP
10864  FFE6     NOP
10868  F00B     NOP
1086A  FFE6     NOP
1086E  F00F     NOP
10870  FFE6     NOP
10874  F013     NOP
10876  FFE6     NOP
10878  0EDC     MOVLW 0xDC
1087C  FF8F     NOP
1087E  FFE6     NOP
10882  FF8F     NOP
10884  FFE6     NOP
10888  FF8F     NOP
1088A  FFE6     NOP
1088E  FF8F     NOP
10890  FFE6     NOP
10892  ECBF     CALL 0x1B57E, 0
10894  F0DA     NOP
10896  0EE0     MOVLW 0xE0
1089A  F007     NOP
1089C  FFE3     NOP
1089E  0EE1     MOVLW 0xE1
108A2  F00B     NOP
108A4  FFE3     NOP
108A6  0EE2     MOVLW 0xE2
108AA  F00F     NOP
108AC  FFE3     NOP
108AE  0EE3     MOVLW 0xE3
108B2  F013     NOP
108B4  FFE3     NOP
422:                   u = u/10.0;
108B6  0E00     MOVLW 0x0
108B8  6EE6     MOVWF 0xFE6, ACCESS
108BA  0E00     MOVLW 0x0
108BC  6EE6     MOVWF 0xFE6, ACCESS
108BE  0E20     MOVLW 0x20
108C0  6EE6     MOVWF 0xFE6, ACCESS
108C2  0E41     MOVLW 0x41
108C4  6EE6     MOVWF 0xFE6, ACCESS
108C6  0ED0     MOVLW 0xD0
108CA  FF8F     NOP
108CC  FFE6     NOP
108D0  FF8F     NOP
108D2  FFE6     NOP
108D6  FF8F     NOP
108D8  FFE6     NOP
108DC  FF8F     NOP
108DE  FFE6     NOP
108E0  ECB4     CALL 0x14D68, 0
108E2  F0A6     NOP
108E4  0ED4     MOVLW 0xD4
108E8  F007     NOP
108EA  FFE3     NOP
108EC  0ED5     MOVLW 0xD5
108F0  F00B     NOP
108F2  FFE3     NOP
108F4  0ED6     MOVLW 0xD6
108F8  F00F     NOP
108FA  FFE3     NOP
108FC  0ED7     MOVLW 0xD7
10900  F013     NOP
10902  FFE3     NOP
423:                   ++i;
10904  0EEC     MOVLW 0xEC
10906  50E3     MOVF 0xFE3, W, ACCESS
10908  0F01     ADDLW 0x1
1090A  6E01     MOVWF ltemp0, ACCESS
1090C  0EEC     MOVLW 0xEC
10910  F007     NOP
10912  FFE3     NOP
10914  6A01     CLRF ltemp0, ACCESS
10916  0EED     MOVLW 0xED
10918  50E3     MOVF 0xFE3, W, ACCESS
1091A  2001     ADDWFC ltemp0, W, ACCESS
1091C  6E01     MOVWF ltemp0, ACCESS
1091E  0EED     MOVLW 0xED
10922  F007     NOP
10924  FFE3     NOP
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
1094C  0E00     MOVLW 0x0
1094E  6EE6     MOVWF 0xFE6, ACCESS
10950  0E00     MOVLW 0x0
10952  6EE6     MOVWF 0xFE6, ACCESS
10954  0EA0     MOVLW 0xA0
10956  6EE6     MOVWF 0xFE6, ACCESS
10958  0E40     MOVLW 0x40
1095A  6EE6     MOVWF 0xFE6, ACCESS
1095C  0ED0     MOVLW 0xD0
10960  FF8F     NOP
10962  FFE6     NOP
10966  FF8F     NOP
10968  FFE6     NOP
1096C  FF8F     NOP
1096E  FFE6     NOP
10972  FF8F     NOP
10974  FFE6     NOP
10976  ECC1     CALL 0x13D82, 0
10978  F09E     NOP
1097A  0EDC     MOVLW 0xDC
1097E  F007     NOP
10980  FFE3     NOP
10982  0EDD     MOVLW 0xDD
10986  F00B     NOP
10988  FFE3     NOP
1098A  0EDE     MOVLW 0xDE
1098E  F00F     NOP
10990  FFE3     NOP
10992  0EDF     MOVLW 0xDF
10996  F013     NOP
10998  FFE3     NOP
428:               if (h < l) {
1099A  0EDC     MOVLW 0xDC
1099E  FF8F     NOP
109A0  FFE6     NOP
109A4  FF8F     NOP
109A6  FFE6     NOP
109AA  FF8F     NOP
109AC  FFE6     NOP
109B0  FF8F     NOP
109B2  FFE6     NOP
109B4  0EDC     MOVLW 0xDC
109B8  FF8F     NOP
109BA  FFE6     NOP
109BE  FF8F     NOP
109C0  FFE6     NOP
109C4  FF8F     NOP
109C6  FFE6     NOP
109CA  FF8F     NOP
109CC  FFE6     NOP
109CE  ECF4     CALL 0x18FE8, 0
109D0  F0C7     NOP
109D2  A001     BTFSS ltemp0, 0, ACCESS
429:                   l = 0.0;
109D4  D021     BRA 0xA18
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
109D6  0EDC     MOVLW 0xDC
109DA  FF8F     NOP
109DC  FFE6     NOP
109E0  FF8F     NOP
109E2  FFE6     NOP
109E6  FF8F     NOP
109E8  FFE6     NOP
109EC  FF8F     NOP
109EE  FFE6     NOP
109F0  0EDC     MOVLW 0xDC
109F4  FF8F     NOP
109F6  FFE6     NOP
109FA  FF8F     NOP
109FC  FFE6     NOP
10A00  FF8F     NOP
10A02  FFE6     NOP
10A06  FF8F     NOP
10A08  FFE6     NOP
10A0A  ECAB     CALL 0x1A356, 0
10A0C  F0D1     NOP
10A0E  A001     BTFSS ltemp0, 0, ACCESS
10A10  D01B     BRA 0xA48
10A12  0EF4     MOVLW 0xF4
10A14  B0E3     BTFSC 0xFE3, 0, ACCESS
10A16  D018     BRA 0xA48
433:                       l = 0.0;
10A18  0E00     MOVLW 0x0
10A1A  6E09     MOVWF ltemp2, ACCESS
10A1C  0E00     MOVLW 0x0
10A1E  6E0A     MOVWF ttemp3, ACCESS
10A20  0E00     MOVLW 0x0
10A22  6E0B     MOVWF wtemp5, ACCESS
10A24  0E00     MOVLW 0x0
10A26  6E0C     MOVWF 0xC, ACCESS
10A28  0EDC     MOVLW 0xDC
10A2C  F027     NOP
10A2E  FFE3     NOP
10A30  0EDD     MOVLW 0xDD
10A34  F02B     NOP
10A36  FFE3     NOP
10A38  0EDE     MOVLW 0xDE
10A3C  F02F     NOP
10A3E  FFE3     NOP
10A40  0EDF     MOVLW 0xDF
10A44  F033     NOP
10A46  FFE3     NOP
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
10A48  0EDC     MOVLW 0xDC
10A4C  FF8F     NOP
10A4E  FFE6     NOP
10A52  FF8F     NOP
10A54  FFE6     NOP
10A58  FF8F     NOP
10A5A  FFE6     NOP
10A5E  FF8F     NOP
10A60  FFE6     NOP
10A62  0ED4     MOVLW 0xD4
10A66  FF8F     NOP
10A68  FFE6     NOP
10A6C  FF8F     NOP
10A6E  FFE6     NOP
10A72  FF8F     NOP
10A74  FFE6     NOP
10A78  FF8F     NOP
10A7A  FFE6     NOP
10A7C  ECD6     CALL 0x145AC, 0
10A7E  F0A2     NOP
10A80  0EE0     MOVLW 0xE0
10A84  F007     NOP
10A86  FFE3     NOP
10A88  0EE1     MOVLW 0xE1
10A8C  F00B     NOP
10A8E  FFE3     NOP
10A90  0EE2     MOVLW 0xE2
10A94  F00F     NOP
10A96  FFE3     NOP
10A98  0EE3     MOVLW 0xE3
10A9C  F013     NOP
10A9E  FFE3     NOP
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
10AA0  0EE4     MOVLW 0xE4
10AA4  FF8C     NOP
10AA6  F009     NOP
10AA8  0EE5     MOVLW 0xE5
10AAC  FF8C     NOP
10AAE  F00A     NOP
10AB0  0EE6     MOVLW 0xE6
10AB4  FF8C     NOP
10AB6  F00B     NOP
10AB8  0EE7     MOVLW 0xE7
10ABC  FF8C     NOP
10ABE  F00C     NOP
10AC0  0ED4     MOVLW 0xD4
10AC4  F027     NOP
10AC6  FFE3     NOP
10AC8  0ED5     MOVLW 0xD5
10ACC  F02B     NOP
10ACE  FFE3     NOP
10AD0  0ED6     MOVLW 0xD6
10AD4  F02F     NOP
10AD6  FFE3     NOP
10AD8  0ED7     MOVLW 0xD7
10ADC  F033     NOP
10ADE  FFE3     NOP
442:               ne = (nmode == 'e') ? 0 : e;
10AE0  0EFF     MOVLW 0xFF
10AE4  FF8C     NOP
10AE6  F001     NOP
10AE8  0E65     MOVLW 0x65
10AEA  1801     XORWF ltemp0, W, ACCESS
10AEC  B4D8     BTFSC 0xFD8, 2, ACCESS
10AEE  D011     BRA 0xB12
10AF0  0EEA     MOVLW 0xEA
10AF4  FF8C     NOP
10AF6  F001     NOP
10AF8  0EF6     MOVLW 0xF6
10AFC  F007     NOP
10AFE  FFE3     NOP
10B00  0EEB     MOVLW 0xEB
10B04  FF8C     NOP
10B06  F001     NOP
10B08  0EF7     MOVLW 0xF7
10B0C  F007     NOP
10B0E  FFE3     NOP
10B10  D004     BRA 0xB1A
10B12  0EF6     MOVLW 0xF6
10B14  6AE3     CLRF 0xFE3, ACCESS
10B16  0EF7     MOVLW 0xF7
10B18  6AE3     CLRF 0xFE3, ACCESS
443:               pp = 0;
10B1A  0EFA     MOVLW 0xFA
10B1C  6AE3     CLRF 0xFE3, ACCESS
10B1E  0EFB     MOVLW 0xFB
10B20  6AE3     CLRF 0xFE3, ACCESS
444:               t = 0;
10B22  0EFC     MOVLW 0xFC
10B24  6AE3     CLRF 0xFE3, ACCESS
10B26  0EFD     MOVLW 0xFD
10B28  6AE3     CLRF 0xFE3, ACCESS
445:               i = 0;
10B2A  0EEC     MOVLW 0xEC
10B2C  6AE3     CLRF 0xFE3, ACCESS
10B2E  0EED     MOVLW 0xED
10B30  6AE3     CLRF 0xFE3, ACCESS
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
10B32  D1B7     BRA 0xEA2
10EA2  50E1     MOVF 0xFE1, W, ACCESS
10EA4  0FEC     ADDLW 0xEC
10EA6  6ED9     MOVWF 0xFD9, ACCESS
10EA8  50E2     MOVF 0xFE2, W, ACCESS
10EAA  6EDA     MOVWF 0xFDA, ACCESS
10EAC  0EFF     MOVLW 0xFF
10EAE  22DA     ADDWFC 0xFDA, F, ACCESS
10EB0  0EF8     MOVLW 0xF8
10EB2  50E3     MOVF 0xFE3, W, ACCESS
10EB4  5CDE     SUBWF 0xFDE, W, ACCESS
10EB6  50DE     MOVF 0xFDE, W, ACCESS
10EB8  0A80     XORLW 0x80
10EBA  6E01     MOVWF ltemp0, ACCESS
10EBC  0EF9     MOVLW 0xF9
10EBE  50E3     MOVF 0xFE3, W, ACCESS
10EC0  0A80     XORLW 0x80
10EC2  5801     SUBWFB ltemp0, W, ACCESS
10EC4  B0D8     BTFSC 0xFD8, 0, ACCESS
10EC6  D00E     BRA 0xEE4
10EC8  0EE9     MOVLW 0xE9
10ECA  BEE3     BTFSC 0xFE3, 7, ACCESS
10ECC  D633     BRA 0xB34
10ECE  0EE9     MOVLW 0xE9
10ED0  50E3     MOVF 0xFE3, W, ACCESS
10ED2  E108     BNZ 0xEE4
10ED4  0EE8     MOVLW 0xE8
10ED8  FF8C     NOP
10EDA  F001     NOP
10EDC  0E4B     MOVLW 0x4B
10EDE  5E01     SUBWF ltemp0, F, ACCESS
10EE0  A0D8     BTFSS 0xFD8, 0, ACCESS
10EE2  D628     BRA 0xB34
447:                   l = floor(h/u);
10B34  0ED4     MOVLW 0xD4
10B38  FF8F     NOP
10B3A  FFE6     NOP
10B3E  FF8F     NOP
10B40  FFE6     NOP
10B44  FF8F     NOP
10B46  FFE6     NOP
10B4A  FF8F     NOP
10B4C  FFE6     NOP
10B4E  0EDC     MOVLW 0xDC
10B52  FF8F     NOP
10B54  FFE6     NOP
10B58  FF8F     NOP
10B5A  FFE6     NOP
10B5E  FF8F     NOP
10B60  FFE6     NOP
10B64  FF8F     NOP
10B66  FFE6     NOP
10B68  ECB4     CALL 0x14D68, 0
10B6A  F0A6     NOP
10B6E  F007     NOP
10B70  FFE6     NOP
10B74  F00B     NOP
10B76  FFE6     NOP
10B7A  F00F     NOP
10B7C  FFE6     NOP
10B80  F013     NOP
10B82  FFE6     NOP
10B84  EC3E     CALL 0x1647C, 0
10B86  F0B2     NOP
10B88  0EDC     MOVLW 0xDC
10B8C  F007     NOP
10B8E  FFE3     NOP
10B90  0EDD     MOVLW 0xDD
10B94  F00B     NOP
10B96  FFE3     NOP
10B98  0EDE     MOVLW 0xDE
10B9C  F00F     NOP
10B9E  FFE3     NOP
10BA0  0EDF     MOVLW 0xDF
10BA4  F013     NOP
10BA6  FFE3     NOP
448:                   d = (int)l;
10BA8  0EDC     MOVLW 0xDC
10BAC  FF8F     NOP
10BAE  FFE6     NOP
10BB2  FF8F     NOP
10BB4  FFE6     NOP
10BB8  FF8F     NOP
10BBA  FFE6     NOP
10BBE  FF8F     NOP
10BC0  FFE6     NOP
10BC2  EC3B     CALL 0x18E76, 0
10BC4  F0C7     NOP
10BC8  F004     NOP
10BCA  F00B     NOP
10BCE  F008     NOP
10BD0  F00C     NOP
10BD2  0EF4     MOVLW 0xF4
10BD6  F02F     NOP
10BD8  FFE3     NOP
10BDA  0EF5     MOVLW 0xF5
10BDE  F033     NOP
10BE0  FFE3     NOP
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
10BE2  B83E     BTFSC flags, 4, ACCESS
10BE4  D026     BRA 0xC32
10BE6  0EF4     MOVLW 0xF4
10BEA  FF8C     NOP
10BEC  F001     NOP
10BEE  0EF5     MOVLW 0xF5
10BF0  50E3     MOVF 0xFE3, W, ACCESS
10BF2  1001     IORWF ltemp0, W, ACCESS
10BF4  A4D8     BTFSS 0xFD8, 2, ACCESS
10BF6  D01D     BRA 0xC32
10BF8  0EFE     MOVLW 0xFE
10BFC  FF8C     NOP
10BFE  F001     NOP
10C00  0E67     MOVLW 0x67
10C02  1801     XORWF ltemp0, W, ACCESS
10C04  A4D8     BTFSS 0xFD8, 2, ACCESS
10C06  D015     BRA 0xC32
10C08  0EF7     MOVLW 0xF7
10C0A  AEE3     BTFSS 0xFE3, 7, ACCESS
10C0C  D012     BRA 0xC32
450:                       ++t;
10C0E  0EFC     MOVLW 0xFC
10C10  50E3     MOVF 0xFE3, W, ACCESS
10C12  0F01     ADDLW 0x1
10C14  6E01     MOVWF ltemp0, ACCESS
10C16  0EFC     MOVLW 0xFC
10C1A  F007     NOP
10C1C  FFE3     NOP
10C1E  6A01     CLRF ltemp0, ACCESS
10C20  0EFD     MOVLW 0xFD
10C22  50E3     MOVF 0xFE3, W, ACCESS
10C24  2001     ADDWFC ltemp0, W, ACCESS
10C26  6E01     MOVWF ltemp0, ACCESS
10C28  0EFD     MOVLW 0xFD
10C2C  F007     NOP
10C2E  FFE3     NOP
451:                   } else {
10C30  D0AF     BRA 0xD90
452:                       if (!pp && (ne < 0)) {
10C32  0EFA     MOVLW 0xFA
10C36  FF8C     NOP
10C38  F001     NOP
10C3A  0EFB     MOVLW 0xFB
10C3C  50E3     MOVF 0xFE3, W, ACCESS
10C3E  1001     IORWF ltemp0, W, ACCESS
10C40  A4D8     BTFSS 0xFD8, 2, ACCESS
10C42  D070     BRA 0xD24
10C44  0EF7     MOVLW 0xF7
10C46  AEE3     BTFSS 0xFE3, 7, ACCESS
10C48  D06D     BRA 0xD24
453:                           dbuf[n++] = '.';
10C4A  0EE8     MOVLW 0xE8
10C4E  FF8C     NOP
10C50  F00B     NOP
10C52  0EE9     MOVLW 0xE9
10C56  FF8C     NOP
10C58  F00C     NOP
10C5A  0E97     MOVLW 0x97
10C5C  240B     ADDWF wtemp5, W, ACCESS
10C5E  6ED9     MOVWF 0xFD9, ACCESS
10C60  0E02     MOVLW 0x2
10C62  200C     ADDWFC 0xC, W, ACCESS
10C64  6EDA     MOVWF 0xFDA, ACCESS
10C66  0E2E     MOVLW 0x2E
10C68  6EDF     MOVWF 0xFDF, ACCESS
10C6A  0EE8     MOVLW 0xE8
10C6C  50E3     MOVF 0xFE3, W, ACCESS
10C6E  0F01     ADDLW 0x1
10C70  6E01     MOVWF ltemp0, ACCESS
10C72  0EE8     MOVLW 0xE8
10C76  F007     NOP
10C78  FFE3     NOP
10C7A  6A01     CLRF ltemp0, ACCESS
10C7C  0EE9     MOVLW 0xE9
10C7E  50E3     MOVF 0xFE3, W, ACCESS
10C80  2001     ADDWFC ltemp0, W, ACCESS
10C82  6E01     MOVWF ltemp0, ACCESS
10C84  0EE9     MOVLW 0xE9
10C88  F007     NOP
10C8A  FFE3     NOP
454:                           --w;
10C8C  50E1     MOVF 0xFE1, W, ACCESS
10C8E  0FEE     ADDLW 0xEE
10C90  6ED9     MOVWF 0xFD9, ACCESS
10C92  50E2     MOVF 0xFE2, W, ACCESS
10C94  6EDA     MOVWF 0xFDA, ACCESS
10C96  0EFF     MOVLW 0xFF
10C98  22DA     ADDWFC 0xFDA, F, ACCESS
10C9A  06DE     DECF 0xFDE, F, ACCESS
10C9C  0E00     MOVLW 0x0
10C9E  5ADD     SUBWFB 0xFDD, F, ACCESS
455:                           pp = 1;
10CA0  0E01     MOVLW 0x1
10CA2  6E0B     MOVWF wtemp5, ACCESS
10CA4  0E00     MOVLW 0x0
10CA6  6E0C     MOVWF 0xC, ACCESS
10CA8  0EFA     MOVLW 0xFA
10CAC  F02F     NOP
10CAE  FFE3     NOP
10CB0  0EFB     MOVLW 0xFB
10CB4  F033     NOP
10CB6  FFE3     NOP
10CB8  D035     BRA 0xD24
456:                       }
457:                       while (t) {
10D24  0EFC     MOVLW 0xFC
10D28  FF8C     NOP
10D2A  F001     NOP
10D2C  0EFD     MOVLW 0xFD
10D2E  50E3     MOVF 0xFE3, W, ACCESS
10D30  1001     IORWF ltemp0, W, ACCESS
10D32  A4D8     BTFSS 0xFD8, 2, ACCESS
10D34  D7C2     BRA 0xCBA
458:                           dbuf[n++] = '0';
10CBA  0EE8     MOVLW 0xE8
10CBE  FF8C     NOP
10CC0  F00B     NOP
10CC2  0EE9     MOVLW 0xE9
10CC6  FF8C     NOP
10CC8  F00C     NOP
10CCA  0E97     MOVLW 0x97
10CCC  240B     ADDWF wtemp5, W, ACCESS
10CCE  6ED9     MOVWF 0xFD9, ACCESS
10CD0  0E02     MOVLW 0x2
10CD2  200C     ADDWFC 0xC, W, ACCESS
10CD4  6EDA     MOVWF 0xFDA, ACCESS
10CD6  0E30     MOVLW 0x30
10CD8  6EDF     MOVWF 0xFDF, ACCESS
10CDA  0EE8     MOVLW 0xE8
10CDC  50E3     MOVF 0xFE3, W, ACCESS
10CDE  0F01     ADDLW 0x1
10CE0  6E01     MOVWF ltemp0, ACCESS
10CE2  0EE8     MOVLW 0xE8
10CE6  F007     NOP
10CE8  FFE3     NOP
10CEA  6A01     CLRF ltemp0, ACCESS
10CEC  0EE9     MOVLW 0xE9
10CEE  50E3     MOVF 0xFE3, W, ACCESS
10CF0  2001     ADDWFC ltemp0, W, ACCESS
10CF2  6E01     MOVWF ltemp0, ACCESS
10CF4  0EE9     MOVLW 0xE9
10CF8  F007     NOP
10CFA  FFE3     NOP
459:                           --w;
10CFC  50E1     MOVF 0xFE1, W, ACCESS
10CFE  0FEE     ADDLW 0xEE
10D00  6ED9     MOVWF 0xFD9, ACCESS
10D02  50E2     MOVF 0xFE2, W, ACCESS
10D04  6EDA     MOVWF 0xFDA, ACCESS
10D06  0EFF     MOVLW 0xFF
10D08  22DA     ADDWFC 0xFDA, F, ACCESS
10D0A  06DE     DECF 0xFDE, F, ACCESS
10D0C  0E00     MOVLW 0x0
10D0E  5ADD     SUBWFB 0xFDD, F, ACCESS
460:                           --t;
10D10  50E1     MOVF 0xFE1, W, ACCESS
10D12  0FFC     ADDLW 0xFC
10D14  6ED9     MOVWF 0xFD9, ACCESS
10D16  50E2     MOVF 0xFE2, W, ACCESS
10D18  6EDA     MOVWF 0xFDA, ACCESS
10D1A  0EFF     MOVLW 0xFF
10D1C  22DA     ADDWFC 0xFDA, F, ACCESS
10D1E  06DE     DECF 0xFDE, F, ACCESS
10D20  0E00     MOVLW 0x0
10D22  5ADD     SUBWFB 0xFDD, F, ACCESS
461:                       }
462:                       dbuf[n++] = '0' + d;
10D36  0EE8     MOVLW 0xE8
10D3A  FF8C     NOP
10D3C  F00B     NOP
10D3E  0EE9     MOVLW 0xE9
10D42  FF8C     NOP
10D44  F00C     NOP
10D46  0E97     MOVLW 0x97
10D48  240B     ADDWF wtemp5, W, ACCESS
10D4A  6ED9     MOVWF 0xFD9, ACCESS
10D4C  0E02     MOVLW 0x2
10D4E  200C     ADDWFC 0xC, W, ACCESS
10D50  6EDA     MOVWF 0xFDA, ACCESS
10D52  0EF4     MOVLW 0xF4
10D54  50E3     MOVF 0xFE3, W, ACCESS
10D56  0F30     ADDLW 0x30
10D58  6EDF     MOVWF 0xFDF, ACCESS
10D5A  0EE8     MOVLW 0xE8
10D5C  50E3     MOVF 0xFE3, W, ACCESS
10D5E  0F01     ADDLW 0x1
10D60  6E01     MOVWF ltemp0, ACCESS
10D62  0EE8     MOVLW 0xE8
10D66  F007     NOP
10D68  FFE3     NOP
10D6A  6A01     CLRF ltemp0, ACCESS
10D6C  0EE9     MOVLW 0xE9
10D6E  50E3     MOVF 0xFE3, W, ACCESS
10D70  2001     ADDWFC ltemp0, W, ACCESS
10D72  6E01     MOVWF ltemp0, ACCESS
10D74  0EE9     MOVLW 0xE9
10D78  F007     NOP
10D7A  FFE3     NOP
463:                       --w;
10D7C  50E1     MOVF 0xFE1, W, ACCESS
10D7E  0FEE     ADDLW 0xEE
10D80  6ED9     MOVWF 0xFD9, ACCESS
10D82  50E2     MOVF 0xFE2, W, ACCESS
10D84  6EDA     MOVWF 0xFDA, ACCESS
10D86  0EFF     MOVLW 0xFF
10D88  22DA     ADDWFC 0xFDA, F, ACCESS
10D8A  06DE     DECF 0xFDE, F, ACCESS
10D8C  0E00     MOVLW 0x0
10D8E  5ADD     SUBWFB 0xFDD, F, ACCESS
464:                   }
465:                   h -= l*u;
10D90  0ED4     MOVLW 0xD4
10D94  FF8F     NOP
10D96  FFE6     NOP
10D9A  FF8F     NOP
10D9C  FFE6     NOP
10DA0  FF8F     NOP
10DA2  FFE6     NOP
10DA6  FF8F     NOP
10DA8  FFE6     NOP
10DAA  0ED8     MOVLW 0xD8
10DAE  FF8F     NOP
10DB0  FFE6     NOP
10DB4  FF8F     NOP
10DB6  FFE6     NOP
10DBA  FF8F     NOP
10DBC  FFE6     NOP
10DC0  FF8F     NOP
10DC2  FFE6     NOP
10DC4  ECC1     CALL 0x13D82, 0
10DC6  F09E     NOP
10DCA  F007     NOP
10DCC  FFE6     NOP
10DD0  F00B     NOP
10DD2  FFE6     NOP
10DD6  F00F     NOP
10DD8  FFE6     NOP
10DDC  F013     NOP
10DDE  FFE6     NOP
10DE0  0EDC     MOVLW 0xDC
10DE4  FF8F     NOP
10DE6  FFE6     NOP
10DEA  FF8F     NOP
10DEC  FFE6     NOP
10DF0  FF8F     NOP
10DF2  FFE6     NOP
10DF6  FF8F     NOP
10DF8  FFE6     NOP
10DFA  ECBF     CALL 0x1B57E, 0
10DFC  F0DA     NOP
10DFE  0EE0     MOVLW 0xE0
10E02  F007     NOP
10E04  FFE3     NOP
10E06  0EE1     MOVLW 0xE1
10E0A  F00B     NOP
10E0C  FFE3     NOP
10E0E  0EE2     MOVLW 0xE2
10E12  F00F     NOP
10E14  FFE3     NOP
10E16  0EE3     MOVLW 0xE3
10E1A  F013     NOP
10E1C  FFE3     NOP
466:                   u = u/10.0;
10E1E  0E00     MOVLW 0x0
10E20  6EE6     MOVWF 0xFE6, ACCESS
10E22  0E00     MOVLW 0x0
10E24  6EE6     MOVWF 0xFE6, ACCESS
10E26  0E20     MOVLW 0x20
10E28  6EE6     MOVWF 0xFE6, ACCESS
10E2A  0E41     MOVLW 0x41
10E2C  6EE6     MOVWF 0xFE6, ACCESS
10E2E  0ED0     MOVLW 0xD0
10E32  FF8F     NOP
10E34  FFE6     NOP
10E38  FF8F     NOP
10E3A  FFE6     NOP
10E3E  FF8F     NOP
10E40  FFE6     NOP
10E44  FF8F     NOP
10E46  FFE6     NOP
10E48  ECB4     CALL 0x14D68, 0
10E4A  F0A6     NOP
10E4C  0ED4     MOVLW 0xD4
10E50  F007     NOP
10E52  FFE3     NOP
10E54  0ED5     MOVLW 0xD5
10E58  F00B     NOP
10E5A  FFE3     NOP
10E5C  0ED6     MOVLW 0xD6
10E60  F00F     NOP
10E62  FFE3     NOP
10E64  0ED7     MOVLW 0xD7
10E68  F013     NOP
10E6A  FFE3     NOP
467:                   --ne;
10E6C  50E1     MOVF 0xFE1, W, ACCESS
10E6E  0FF6     ADDLW 0xF6
10E70  6ED9     MOVWF 0xFD9, ACCESS
10E72  50E2     MOVF 0xFE2, W, ACCESS
10E74  6EDA     MOVWF 0xFDA, ACCESS
10E76  0EFF     MOVLW 0xFF
10E78  22DA     ADDWFC 0xFDA, F, ACCESS
10E7A  06DE     DECF 0xFDE, F, ACCESS
10E7C  0E00     MOVLW 0x0
10E7E  5ADD     SUBWFB 0xFDD, F, ACCESS
468:                   ++i;
10E80  0EEC     MOVLW 0xEC
10E82  50E3     MOVF 0xFE3, W, ACCESS
10E84  0F01     ADDLW 0x1
10E86  6E01     MOVWF ltemp0, ACCESS
10E88  0EEC     MOVLW 0xEC
10E8C  F007     NOP
10E8E  FFE3     NOP
10E90  6A01     CLRF ltemp0, ACCESS
10E92  0EED     MOVLW 0xED
10E94  50E3     MOVF 0xFE3, W, ACCESS
10E96  2001     ADDWFC ltemp0, W, ACCESS
10E98  6E01     MOVWF ltemp0, ACCESS
10E9A  0EED     MOVLW 0xED
10E9E  F007     NOP
10EA0  FFE3     NOP
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
10EE4  0EFA     MOVLW 0xFA
10EE8  FF8C     NOP
10EEA  F001     NOP
10EEC  0EFB     MOVLW 0xFB
10EEE  50E3     MOVF 0xFE3, W, ACCESS
10EF0  1001     IORWF ltemp0, W, ACCESS
10EF2  B4D8     BTFSC 0xFD8, 2, ACCESS
10EF4  A83E     BTFSS flags, 4, ACCESS
10EF6  D021     BRA 0xF3A
471:                   dbuf[n++] = '.';
10EF8  0EE8     MOVLW 0xE8
10EFC  FF8C     NOP
10EFE  F00B     NOP
10F00  0EE9     MOVLW 0xE9
10F04  FF8C     NOP
10F06  F00C     NOP
10F08  0E97     MOVLW 0x97
10F0A  240B     ADDWF wtemp5, W, ACCESS
10F0C  6ED9     MOVWF 0xFD9, ACCESS
10F0E  0E02     MOVLW 0x2
10F10  200C     ADDWFC 0xC, W, ACCESS
10F12  6EDA     MOVWF 0xFDA, ACCESS
10F14  0E2E     MOVLW 0x2E
10F16  6EDF     MOVWF 0xFDF, ACCESS
10F18  0EE8     MOVLW 0xE8
10F1A  50E3     MOVF 0xFE3, W, ACCESS
10F1C  0F01     ADDLW 0x1
10F1E  6E01     MOVWF ltemp0, ACCESS
10F20  0EE8     MOVLW 0xE8
10F24  F007     NOP
10F26  FFE3     NOP
10F28  6A01     CLRF ltemp0, ACCESS
10F2A  0EE9     MOVLW 0xE9
10F2C  50E3     MOVF 0xFE3, W, ACCESS
10F2E  2001     ADDWFC ltemp0, W, ACCESS
10F30  6E01     MOVWF ltemp0, ACCESS
10F32  0EE9     MOVLW 0xE9
10F36  F007     NOP
10F38  FFE3     NOP
472:               }
473:               dbuf[n] = '\0';
10F3A  0EE8     MOVLW 0xE8
10F3E  FF8C     NOP
10F40  F00B     NOP
10F42  0EE9     MOVLW 0xE9
10F46  FF8C     NOP
10F48  F00C     NOP
10F4A  0E97     MOVLW 0x97
10F4C  240B     ADDWF wtemp5, W, ACCESS
10F4E  6ED9     MOVWF 0xFD9, ACCESS
10F50  0E02     MOVLW 0x2
10F52  200C     ADDWFC 0xC, W, ACCESS
10F54  6EDA     MOVWF 0xFDA, ACCESS
10F56  0E00     MOVLW 0x0
10F58  6EDF     MOVWF 0xFDF, ACCESS
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
10F5A  0EFF     MOVLW 0xFF
10F5E  FF8C     NOP
10F60  F001     NOP
10F62  0E65     MOVLW 0x65
10F64  1801     XORWF ltemp0, W, ACCESS
10F66  A4D8     BTFSS 0xFD8, 2, ACCESS
10F68  EF16     GOTO 0x1022C
10F6A  F081     NOP
477:                   i = sizeof(dbuf) - 1;
10F6C  0E4F     MOVLW 0x4F
10F6E  6E0B     MOVWF wtemp5, ACCESS
10F70  0E00     MOVLW 0x0
10F72  6E0C     MOVWF 0xC, ACCESS
10F74  0EEC     MOVLW 0xEC
10F78  F02F     NOP
10F7A  FFE3     NOP
10F7C  0EED     MOVLW 0xED
10F80  F033     NOP
10F82  FFE3     NOP
478:                   dbuf[i] = '\0';
10F84  0EEC     MOVLW 0xEC
10F88  FF8C     NOP
10F8A  F00B     NOP
10F8C  0EED     MOVLW 0xED
10F90  FF8C     NOP
10F92  F00C     NOP
10F94  0E97     MOVLW 0x97
10F96  240B     ADDWF wtemp5, W, ACCESS
10F98  6ED9     MOVWF 0xFD9, ACCESS
10F9A  0E02     MOVLW 0x2
10F9C  200C     ADDWFC 0xC, W, ACCESS
10F9E  6EDA     MOVWF 0xFDA, ACCESS
10FA0  0E00     MOVLW 0x0
10FA2  6EDF     MOVWF 0xFDF, ACCESS
479:                   sign = 0;
10FA4  0EF2     MOVLW 0xF2
10FA6  6AE3     CLRF 0xFE3, ACCESS
10FA8  0EF3     MOVLW 0xF3
10FAA  6AE3     CLRF 0xFE3, ACCESS
480:                   if (e < 0) {
10FAC  0EEB     MOVLW 0xEB
10FAE  AEE3     BTFSS 0xFE3, 7, ACCESS
10FB0  D012     BRA 0xFD6
481:                       sign = 1;
10FB2  0E01     MOVLW 0x1
10FB4  6E0B     MOVWF wtemp5, ACCESS
10FB6  0E00     MOVLW 0x0
10FB8  6E0C     MOVWF 0xC, ACCESS
10FBA  0EF2     MOVLW 0xF2
10FBE  F02F     NOP
10FC0  FFE3     NOP
10FC2  0EF3     MOVLW 0xF3
10FC6  F033     NOP
10FC8  FFE3     NOP
482:                       e = -e;
10FCA  0EEA     MOVLW 0xEA
10FCC  6CE3     NEGF 0xFE3, ACCESS
10FCE  0EEB     MOVLW 0xEB
10FD0  1EE3     COMF 0xFE3, F, ACCESS
10FD2  B0D8     BTFSC 0xFD8, 0, ACCESS
10FD4  2AE3     INCF 0xFE3, F, ACCESS
483:                   }
484:                   p = 2;
10FD6  0E02     MOVLW 0x2
10FD8  6E0B     MOVWF wtemp5, ACCESS
10FDA  0E00     MOVLW 0x0
10FDC  6E0C     MOVWF 0xC, ACCESS
10FDE  0EF0     MOVLW 0xF0
10FE2  F02F     NOP
10FE4  FFE3     NOP
10FE6  0EF1     MOVLW 0xF1
10FEA  F033     NOP
10FEC  FFE3     NOP
485:                   while (e || (0 < p)) {
10FEE  D051     BRA 0x1092
11092  0EEA     MOVLW 0xEA
11096  FF8C     NOP
11098  F001     NOP
1109A  0EEB     MOVLW 0xEB
1109C  50E3     MOVF 0xFE3, W, ACCESS
1109E  1001     IORWF ltemp0, W, ACCESS
110A0  A4D8     BTFSS 0xFD8, 2, ACCESS
110A2  D7A6     BRA 0xFF0
110A4  0EF1     MOVLW 0xF1
110A6  BEE3     BTFSC 0xFE3, 7, ACCESS
110A8  D007     BRA 0x10B8
110AA  0EF1     MOVLW 0xF1
110AC  50E3     MOVF 0xFE3, W, ACCESS
110AE  E1A0     BNZ 0xFF0
110B0  0EF0     MOVLW 0xF0
110B2  04E3     DECF 0xFE3, W, ACCESS
110B4  B0D8     BTFSC 0xFD8, 0, ACCESS
110B6  D79C     BRA 0xFF0
486:                       --i;
10FF0  50E1     MOVF 0xFE1, W, ACCESS
10FF2  0FEC     ADDLW 0xEC
10FF4  6ED9     MOVWF 0xFD9, ACCESS
10FF6  50E2     MOVF 0xFE2, W, ACCESS
10FF8  6EDA     MOVWF 0xFDA, ACCESS
10FFA  0EFF     MOVLW 0xFF
10FFC  22DA     ADDWFC 0xFDA, F, ACCESS
10FFE  06DE     DECF 0xFDE, F, ACCESS
11000  0E00     MOVLW 0x0
11002  5ADD     SUBWFB 0xFDD, F, ACCESS
487:                       dbuf[i] = '0' + (e % 10);
11004  0EEC     MOVLW 0xEC
11008  FF8C     NOP
1100A  F00B     NOP
1100C  0EED     MOVLW 0xED
11010  FF8C     NOP
11012  F00C     NOP
11014  0E97     MOVLW 0x97
11016  240B     ADDWF wtemp5, W, ACCESS
11018  6ED9     MOVWF 0xFD9, ACCESS
1101A  0E02     MOVLW 0x2
1101C  200C     ADDWFC 0xC, W, ACCESS
1101E  6EDA     MOVWF 0xFDA, ACCESS
11020  0E0A     MOVLW 0xA
11022  6EE6     MOVWF 0xFE6, ACCESS
11024  0E00     MOVLW 0x0
11026  6EE6     MOVWF 0xFE6, ACCESS
11028  0EE8     MOVLW 0xE8
1102C  FF8F     NOP
1102E  FFE6     NOP
11032  FF8F     NOP
11034  FFE6     NOP
11036  EC62     CALL 0x198C4, 0
11038  F0CC     NOP
1103A  5001     MOVF ltemp0, W, ACCESS
1103C  0F30     ADDLW 0x30
1103E  6EDF     MOVWF 0xFDF, ACCESS
488:                       e = e / 10;
11040  0E0A     MOVLW 0xA
11042  6EE6     MOVWF 0xFE6, ACCESS
11044  0E00     MOVLW 0x0
11046  6EE6     MOVWF 0xFE6, ACCESS
11048  0EE8     MOVLW 0xE8
1104C  FF8F     NOP
1104E  FFE6     NOP
11052  FF8F     NOP
11054  FFE6     NOP
11056  EC57     CALL 0x192AE, 0
11058  F0C9     NOP
1105A  0EEA     MOVLW 0xEA
1105E  F007     NOP
11060  FFE3     NOP
11062  0EEB     MOVLW 0xEB
11066  F00B     NOP
11068  FFE3     NOP
489:                       --p;
1106A  50E1     MOVF 0xFE1, W, ACCESS
1106C  0FF0     ADDLW 0xF0
1106E  6ED9     MOVWF 0xFD9, ACCESS
11070  50E2     MOVF 0xFE2, W, ACCESS
11072  6EDA     MOVWF 0xFDA, ACCESS
11074  0EFF     MOVLW 0xFF
11076  22DA     ADDWFC 0xFDA, F, ACCESS
11078  06DE     DECF 0xFDE, F, ACCESS
1107A  0E00     MOVLW 0x0
1107C  5ADD     SUBWFB 0xFDD, F, ACCESS
490:                       --w;
1107E  50E1     MOVF 0xFE1, W, ACCESS
11080  0FEE     ADDLW 0xEE
11082  6ED9     MOVWF 0xFD9, ACCESS
11084  50E2     MOVF 0xFE2, W, ACCESS
11086  6EDA     MOVWF 0xFDA, ACCESS
11088  0EFF     MOVLW 0xFF
1108A  22DA     ADDWFC 0xFDA, F, ACCESS
1108C  06DE     DECF 0xFDE, F, ACCESS
1108E  0E00     MOVLW 0x0
11090  5ADD     SUBWFB 0xFDD, F, ACCESS
491:                   }
492:                   --i;
110B8  50E1     MOVF 0xFE1, W, ACCESS
110BA  0FEC     ADDLW 0xEC
110BC  6ED9     MOVWF 0xFD9, ACCESS
110BE  50E2     MOVF 0xFE2, W, ACCESS
110C0  6EDA     MOVWF 0xFDA, ACCESS
110C2  0EFF     MOVLW 0xFF
110C4  22DA     ADDWFC 0xFDA, F, ACCESS
110C6  06DE     DECF 0xFDE, F, ACCESS
110C8  0E00     MOVLW 0x0
110CA  5ADD     SUBWFB 0xFDD, F, ACCESS
493:                   dbuf[i] = sign ? '-' : '+';
110CC  0EF2     MOVLW 0xF2
110D0  FF8C     NOP
110D2  F001     NOP
110D4  0EF3     MOVLW 0xF3
110D6  50E3     MOVF 0xFE3, W, ACCESS
110D8  1001     IORWF ltemp0, W, ACCESS
110DA  A4D8     BTFSS 0xFD8, 2, ACCESS
110DC  D002     BRA 0x10E2
110DE  0E2B     MOVLW 0x2B
110E0  D001     BRA 0x10E4
110E2  0E2D     MOVLW 0x2D
110E4  6E0B     MOVWF wtemp5, ACCESS
110E6  0E00     MOVLW 0x0
110E8  6E0C     MOVWF 0xC, ACCESS
110EA  0ECC     MOVLW 0xCC
110EE  F02F     NOP
110F0  FFE3     NOP
110F2  0ECD     MOVLW 0xCD
110F6  F033     NOP
110F8  FFE3     NOP
110FA  0EEC     MOVLW 0xEC
110FE  FF8C     NOP
11100  F00B     NOP
11102  0EED     MOVLW 0xED
11106  FF8C     NOP
11108  F00C     NOP
1110A  0E97     MOVLW 0x97
1110C  240B     ADDWF wtemp5, W, ACCESS
1110E  6ED9     MOVWF 0xFD9, ACCESS
11110  0E02     MOVLW 0x2
11112  200C     ADDWFC 0xC, W, ACCESS
11114  6EDA     MOVWF 0xFDA, ACCESS
11116  0ECC     MOVLW 0xCC
1111A  FF8F     NOP
1111C  FFDF     NOP
494:                   --w;
1111E  50E1     MOVF 0xFE1, W, ACCESS
11120  0FEE     ADDLW 0xEE
11122  6ED9     MOVWF 0xFD9, ACCESS
11124  50E2     MOVF 0xFE2, W, ACCESS
11126  6EDA     MOVWF 0xFDA, ACCESS
11128  0EFF     MOVLW 0xFF
1112A  22DA     ADDWFC 0xFDA, F, ACCESS
1112C  06DE     DECF 0xFDE, F, ACCESS
1112E  0E00     MOVLW 0x0
11130  5ADD     SUBWFB 0xFDD, F, ACCESS
495:                   --i;
11132  50E1     MOVF 0xFE1, W, ACCESS
11134  0FEC     ADDLW 0xEC
11136  6ED9     MOVWF 0xFD9, ACCESS
11138  50E2     MOVF 0xFE2, W, ACCESS
1113A  6EDA     MOVWF 0xFDA, ACCESS
1113C  0EFF     MOVLW 0xFF
1113E  22DA     ADDWFC 0xFDA, F, ACCESS
11140  06DE     DECF 0xFDE, F, ACCESS
11142  0E00     MOVLW 0x0
11144  5ADD     SUBWFB 0xFDD, F, ACCESS
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
11146  0EBF     MOVLW 0xBF
11148  6E0B     MOVWF wtemp5, ACCESS
1114A  0EFF     MOVLW 0xFF
1114C  6E0C     MOVWF 0xC, ACCESS
1114E  0EC1     MOVLW 0xC1
11150  50E3     MOVF 0xFE3, W, ACCESS
11152  6E09     MOVWF ltemp2, ACCESS
11154  6A0A     CLRF ttemp3, ACCESS
11156  500B     MOVF wtemp5, W, ACCESS
11158  2609     ADDWF ltemp2, F, ACCESS
1115A  500C     MOVF 0xC, W, ACCESS
1115C  220A     ADDWFC ttemp3, F, ACCESS
1115E  500A     MOVF ttemp3, W, ACCESS
11160  E106     BNZ 0x116E
11162  0E1A     MOVLW 0x1A
11164  5C09     SUBWF ltemp2, W, ACCESS
11166  B0D8     BTFSC 0xFD8, 0, ACCESS
11168  D002     BRA 0x116E
1116A  0E01     MOVLW 0x1
1116C  D001     BRA 0x1170
1116E  0E00     MOVLW 0x0
11170  6E0B     MOVWF wtemp5, ACCESS
11172  6A0C     CLRF 0xC, ACCESS
11174  0EC8     MOVLW 0xC8
11178  F02F     NOP
1117A  FFE3     NOP
1117C  0EC9     MOVLW 0xC9
11180  F033     NOP
11182  FFE3     NOP
11184  0EC8     MOVLW 0xC8
11188  FF8C     NOP
1118A  F001     NOP
1118C  0EC9     MOVLW 0xC9
1118E  50E3     MOVF 0xFE3, W, ACCESS
11190  1001     IORWF ltemp0, W, ACCESS
11192  A4D8     BTFSS 0xFD8, 2, ACCESS
11194  D002     BRA 0x119A
11196  0E65     MOVLW 0x65
11198  D001     BRA 0x119C
1119A  0E45     MOVLW 0x45
1119C  6E0B     MOVWF wtemp5, ACCESS
1119E  0E00     MOVLW 0x0
111A0  6E0C     MOVWF 0xC, ACCESS
111A2  0ECA     MOVLW 0xCA
111A6  F02F     NOP
111A8  FFE3     NOP
111AA  0ECB     MOVLW 0xCB
111AE  F033     NOP
111B0  FFE3     NOP
111B2  0EEC     MOVLW 0xEC
111B6  FF8C     NOP
111B8  F00B     NOP
111BA  0EED     MOVLW 0xED
111BE  FF8C     NOP
111C0  F00C     NOP
111C2  0E97     MOVLW 0x97
111C4  240B     ADDWF wtemp5, W, ACCESS
111C6  6ED9     MOVWF 0xFD9, ACCESS
111C8  0E02     MOVLW 0x2
111CA  200C     ADDWFC 0xC, W, ACCESS
111CC  6EDA     MOVWF 0xFDA, ACCESS
111CE  0ECA     MOVLW 0xCA
111D2  FF8F     NOP
111D4  FFDF     NOP
497:                   --w;
111D6  50E1     MOVF 0xFE1, W, ACCESS
111D8  0FEE     ADDLW 0xEE
111DA  6ED9     MOVWF 0xFD9, ACCESS
111DC  50E2     MOVF 0xFE2, W, ACCESS
111DE  6EDA     MOVWF 0xFDA, ACCESS
111E0  0EFF     MOVLW 0xFF
111E2  22DA     ADDWFC 0xFDA, F, ACCESS
111E4  06DE     DECF 0xFDE, F, ACCESS
111E6  0E00     MOVLW 0x0
111E8  5ADD     SUBWFB 0xFDD, F, ACCESS
498:                   strcpy(&dbuf[n], &dbuf[i]);
111EA  0EEC     MOVLW 0xEC
111EE  FF8C     NOP
111F0  F00B     NOP
111F2  0EED     MOVLW 0xED
111F6  FF8C     NOP
111F8  F00C     NOP
111FA  0E97     MOVLW 0x97
111FC  240B     ADDWF wtemp5, W, ACCESS
111FE  6E09     MOVWF ltemp2, ACCESS
11200  0E02     MOVLW 0x2
11202  200C     ADDWFC 0xC, W, ACCESS
11204  6E0A     MOVWF ttemp3, ACCESS
11208  F027     NOP
1120A  FFE6     NOP
1120E  F02B     NOP
11210  FFE6     NOP
11212  0E97     MOVLW 0x97
11214  6E0B     MOVWF wtemp5, ACCESS
11216  0E02     MOVLW 0x2
11218  6E0C     MOVWF 0xC, ACCESS
1121A  0EE6     MOVLW 0xE6
1121C  50E3     MOVF 0xFE3, W, ACCESS
1121E  260B     ADDWF wtemp5, F, ACCESS
11220  0EE7     MOVLW 0xE7
11222  50E3     MOVF 0xFE3, W, ACCESS
11224  220C     ADDWFC 0xC, F, ACCESS
11228  F02F     NOP
1122A  FFE6     NOP
1122E  F033     NOP
11230  FFE6     NOP
11232  EC41     CALL 0x1A282, 0
11234  F0D1     NOP
11236  EF16     GOTO 0x1022C
11238  F081     NOP
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
1123A  0EC1     MOVLW 0xC1
1123C  26E1     ADDWF 0xFE1, F, ACCESS
1123E  0EFF     MOVLW 0xFF
11240  22E2     ADDWFC 0xFE2, F, ACCESS
11242  0012     RETURN 0
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
514:                   flags &= ~ZERO_FLAG;
515:               }
516:               p = (0 < prec) ? prec : 1;
517:               w = width;
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
521:               i = sizeof(dbuf) - 1;
522:               dbuf[i] = '\0';
523:               t = 0;
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
525:                   --i;
526:                   t = n & 07;
527:                   dbuf[i] = '0' + t;
528:                   --p;
529:                   --w;
530:                   n = n >> 3;
531:               }
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
535:                   --i;
536:                   dbuf[i] = '0';
537:                   --w;
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
17410  0E11     MOVLW 0x11
547:           {
548:               char *cp, nuls[] = "(null)";
17418  EE20     LFSR 2, 0xF0
1741A  F0F0     NOP
1741C  0E07     MOVLW 0x7
1741E  6E01     MOVWF ltemp0, ACCESS
17420  0EEF     MOVLW 0xEF
17424  FF7B     NOP
17426  FFE3     NOP
17428  28E8     INCF 0xFE8, W, ACCESS
1742A  2E01     DECFSZ ltemp0, F, ACCESS
1742C  D7FA     BRA 0x7422
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
1742E  0EEB     MOVLW 0xEB
17432  FF8C     NOP
17434  F00B     NOP
17436  0EEC     MOVLW 0xEC
1743A  FF8C     NOP
1743C  F00C     NOP
1743E  0EFB     MOVLW 0xFB
17442  F033     NOP
17444  FFE3     NOP
17446  0EFA     MOVLW 0xFA
1744A  F02F     NOP
1744C  FFE3     NOP
553:               if (!cp) {
1744E  0EFA     MOVLW 0xFA
17452  FF8C     NOP
17454  F001     NOP
17456  0EFB     MOVLW 0xFB
17458  50E3     MOVF 0xFE3, W, ACCESS
1745A  1001     IORWF ltemp0, W, ACCESS
1745C  A4D8     BTFSS 0xFD8, 2, ACCESS
1745E  D00E     BRA 0x747C
554:                   cp = nuls;
17460  0EEF     MOVLW 0xEF
17462  24E1     ADDWF 0xFE1, W, ACCESS
17464  6E0B     MOVWF wtemp5, ACCESS
17466  0EFF     MOVLW 0xFF
17468  20E2     ADDWFC 0xFE2, W, ACCESS
1746A  6E0C     MOVWF 0xC, ACCESS
1746C  0EFB     MOVLW 0xFB
17470  F033     NOP
17472  FFE3     NOP
17474  0EFA     MOVLW 0xFA
17478  F02F     NOP
1747A  FFE3     NOP
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
1747C  0EFA     MOVLW 0xFA
17480  FF8F     NOP
17482  FFE6     NOP
17486  FF8F     NOP
17488  FFE6     NOP
1748A  EC6F     CALL 0x1A8DE, 0
1748C  F0D4     NOP
1748E  0EF6     MOVLW 0xF6
17492  F007     NOP
17494  FFE3     NOP
17496  0EF7     MOVLW 0xF7
1749A  F00B     NOP
1749C  FFE3     NOP
559:               p = prec;
1749E  0EF8     MOVLW 0xF8
174A2  F0F3     NOP
174A4  FFE3     NOP
174A6  0EF9     MOVLW 0xF9
174AA  F0F7     NOP
174AC  FFE3     NOP
560:               l = (!(p < 0) && (p < l)) ? p : l;
174AE  0EF9     MOVLW 0xF9
174B0  BEE3     BTFSC 0xFE3, 7, ACCESS
174B2  D023     BRA 0x74FA
174B4  50E1     MOVF 0xFE1, W, ACCESS
174B6  0FF8     ADDLW 0xF8
174B8  6ED9     MOVWF 0xFD9, ACCESS
174BA  50E2     MOVF 0xFE2, W, ACCESS
174BC  6EDA     MOVWF 0xFDA, ACCESS
174BE  0EFF     MOVLW 0xFF
174C0  22DA     ADDWFC 0xFDA, F, ACCESS
174C2  0EF6     MOVLW 0xF6
174C4  50E3     MOVF 0xFE3, W, ACCESS
174C6  5CDE     SUBWF 0xFDE, W, ACCESS
174C8  50DE     MOVF 0xFDE, W, ACCESS
174CA  0A80     XORLW 0x80
174CC  6E01     MOVWF ltemp0, ACCESS
174CE  0EF7     MOVLW 0xF7
174D0  50E3     MOVF 0xFE3, W, ACCESS
174D2  0A80     XORLW 0x80
174D4  5801     SUBWFB ltemp0, W, ACCESS
174D6  B0D8     BTFSC 0xFD8, 0, ACCESS
174D8  D010     BRA 0x74FA
174DA  0EF8     MOVLW 0xF8
174DE  FF8C     NOP
174E0  F001     NOP
174E2  0EF6     MOVLW 0xF6
174E6  F007     NOP
174E8  FFE3     NOP
174EA  0EF9     MOVLW 0xF9
174EE  FF8C     NOP
174F0  F001     NOP
174F2  0EF7     MOVLW 0xF7
174F6  F007     NOP
174F8  FFE3     NOP
561:               p = l;
174FA  0EF6     MOVLW 0xF6
174FE  FF8C     NOP
17500  F001     NOP
17502  0EF8     MOVLW 0xF8
17506  F007     NOP
17508  FFE3     NOP
1750A  0EF7     MOVLW 0xF7
1750E  FF8C     NOP
17510  F001     NOP
17512  0EF9     MOVLW 0xF9
17516  F007     NOP
17518  FFE3     NOP
562:               w = width;
1751A  0EFC     MOVLW 0xFC
1751E  F0EB     NOP
17520  FFE3     NOP
17522  0EFD     MOVLW 0xFD
17526  F0EF     NOP
17528  FFE3     NOP
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
1752A  A03E     BTFSS flags, 0, ACCESS
1752C  D01F     BRA 0x756C
1752E  D031     BRA 0x7592
566:                   while (l < w) {
1756C  50E1     MOVF 0xFE1, W, ACCESS
1756E  0FF6     ADDLW 0xF6
17570  6ED9     MOVWF 0xFD9, ACCESS
17572  50E2     MOVF 0xFE2, W, ACCESS
17574  6EDA     MOVWF 0xFDA, ACCESS
17576  0EFF     MOVLW 0xFF
17578  22DA     ADDWFC 0xFDA, F, ACCESS
1757A  0EFC     MOVLW 0xFC
1757C  50E3     MOVF 0xFE3, W, ACCESS
1757E  5CDE     SUBWF 0xFDE, W, ACCESS
17580  50DE     MOVF 0xFDE, W, ACCESS
17582  0A80     XORLW 0x80
17584  6E01     MOVWF ltemp0, ACCESS
17586  0EFD     MOVLW 0xFD
17588  50E3     MOVF 0xFE3, W, ACCESS
1758A  0A80     XORLW 0x80
1758C  5801     SUBWFB ltemp0, W, ACCESS
1758E  A0D8     BTFSS 0xFD8, 0, ACCESS
17590  D7CF     BRA 0x7530
567:                       fputc(' ', fp);
17530  0EED     MOVLW 0xED
17534  FF8F     NOP
17536  FFE6     NOP
1753A  FF8F     NOP
1753C  FFE6     NOP
1753E  0E20     MOVLW 0x20
17540  6EE6     MOVWF 0xFE6, ACCESS
17542  0E00     MOVLW 0x0
17544  6EE6     MOVWF 0xFE6, ACCESS
17546  ECD0     CALL 0x197A0, 0
17548  F0CB     NOP
568:                       ++l;
1754A  0EF6     MOVLW 0xF6
1754C  50E3     MOVF 0xFE3, W, ACCESS
1754E  0F01     ADDLW 0x1
17550  6E01     MOVWF ltemp0, ACCESS
17552  0EF6     MOVLW 0xF6
17556  F007     NOP
17558  FFE3     NOP
1755A  6A01     CLRF ltemp0, ACCESS
1755C  0EF7     MOVLW 0xF7
1755E  50E3     MOVF 0xFE3, W, ACCESS
17560  2001     ADDWFC ltemp0, W, ACCESS
17562  6E01     MOVWF ltemp0, ACCESS
17564  0EF7     MOVLW 0xF7
17568  F007     NOP
1756A  FFE3     NOP
569:                   }
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
17592  0EFE     MOVLW 0xFE
17594  6AE3     CLRF 0xFE3, ACCESS
17596  0EFF     MOVLW 0xFF
17598  6AE3     CLRF 0xFE3, ACCESS
574:               while (i < p) {
1759A  D045     BRA 0x7626
17626  50E1     MOVF 0xFE1, W, ACCESS
17628  0FFE     ADDLW 0xFE
1762A  6ED9     MOVWF 0xFD9, ACCESS
1762C  50E2     MOVF 0xFE2, W, ACCESS
1762E  6EDA     MOVWF 0xFDA, ACCESS
17630  0EFF     MOVLW 0xFF
17632  22DA     ADDWFC 0xFDA, F, ACCESS
17634  0EF8     MOVLW 0xF8
17636  50E3     MOVF 0xFE3, W, ACCESS
17638  5CDE     SUBWF 0xFDE, W, ACCESS
1763A  50DE     MOVF 0xFDE, W, ACCESS
1763C  0A80     XORLW 0x80
1763E  6E01     MOVWF ltemp0, ACCESS
17640  0EF9     MOVLW 0xF9
17642  50E3     MOVF 0xFE3, W, ACCESS
17644  0A80     XORLW 0x80
17646  5801     SUBWFB ltemp0, W, ACCESS
17648  A0D8     BTFSS 0xFD8, 0, ACCESS
1764A  D7A8     BRA 0x759C
575:                   fputc(*cp, fp);
1759C  0EED     MOVLW 0xED
175A0  FF8F     NOP
175A2  FFE6     NOP
175A6  FF8F     NOP
175A8  FFE6     NOP
175AA  0EF8     MOVLW 0xF8
175AE  FF8F     NOP
175B0  FFF6     NOP
175B2  0EF9     MOVLW 0xF9
175B6  FF8F     NOP
175B8  FFF7     NOP
175BA  0E00     MOVLW 0x0
175BC  6EF8     MOVWF 0xFF8, ACCESS
175BE  0E1F     MOVLW 0x1F
175C0  64F7     CPFSGT 0xFF7, ACCESS
175C2  D003     BRA 0x75CA
175C4  0008     TBLRD*
175C6  50F5     MOVF 0xFF5, W, ACCESS
175C8  D007     BRA 0x75D8
175CC  FFDB     NOP
175CE  FFE9     NOP
175D2  FFDF     NOP
175D4  FFEA     NOP
175D6  50EF     MOVF 0xFEF, W, ACCESS
175D8  6EE6     MOVWF 0xFE6, ACCESS
175DA  0E00     MOVLW 0x0
175DC  6EE6     MOVWF 0xFE6, ACCESS
175DE  ECD0     CALL 0x197A0, 0
175E0  F0CB     NOP
576:                   ++cp;
175E2  0EFA     MOVLW 0xFA
175E4  50E3     MOVF 0xFE3, W, ACCESS
175E6  0F01     ADDLW 0x1
175E8  6E01     MOVWF ltemp0, ACCESS
175EA  0EFA     MOVLW 0xFA
175EE  F007     NOP
175F0  FFE3     NOP
175F2  6A01     CLRF ltemp0, ACCESS
175F4  0EFB     MOVLW 0xFB
175F6  50E3     MOVF 0xFE3, W, ACCESS
175F8  2001     ADDWFC ltemp0, W, ACCESS
175FA  6E01     MOVWF ltemp0, ACCESS
175FC  0EFB     MOVLW 0xFB
17600  F007     NOP
17602  FFE3     NOP
577:                   ++i;
17604  0EFE     MOVLW 0xFE
17606  50E3     MOVF 0xFE3, W, ACCESS
17608  0F01     ADDLW 0x1
1760A  6E01     MOVWF ltemp0, ACCESS
1760C  0EFE     MOVLW 0xFE
17610  F007     NOP
17612  FFE3     NOP
17614  6A01     CLRF ltemp0, ACCESS
17616  0EFF     MOVLW 0xFF
17618  50E3     MOVF 0xFE3, W, ACCESS
1761A  2001     ADDWFC ltemp0, W, ACCESS
1761C  6E01     MOVWF ltemp0, ACCESS
1761E  0EFF     MOVLW 0xFF
17622  F007     NOP
17624  FFE3     NOP
578:               }
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
1764C  B03E     BTFSC flags, 0, ACCESS
1764E  D01F     BRA 0x768E
17650  D031     BRA 0x76B4
582:                   while (l < w) {
1768E  50E1     MOVF 0xFE1, W, ACCESS
17690  0FF6     ADDLW 0xF6
17692  6ED9     MOVWF 0xFD9, ACCESS
17694  50E2     MOVF 0xFE2, W, ACCESS
17696  6EDA     MOVWF 0xFDA, ACCESS
17698  0EFF     MOVLW 0xFF
1769A  22DA     ADDWFC 0xFDA, F, ACCESS
1769C  0EFC     MOVLW 0xFC
1769E  50E3     MOVF 0xFE3, W, ACCESS
176A0  5CDE     SUBWF 0xFDE, W, ACCESS
176A2  50DE     MOVF 0xFDE, W, ACCESS
176A4  0A80     XORLW 0x80
176A6  6E01     MOVWF ltemp0, ACCESS
176A8  0EFD     MOVLW 0xFD
176AA  50E3     MOVF 0xFE3, W, ACCESS
176AC  0A80     XORLW 0x80
176AE  5801     SUBWFB ltemp0, W, ACCESS
176B0  A0D8     BTFSS 0xFD8, 0, ACCESS
176B2  D7CF     BRA 0x7652
583:                       fputc(' ', fp);
17652  0EED     MOVLW 0xED
17656  FF8F     NOP
17658  FFE6     NOP
1765C  FF8F     NOP
1765E  FFE6     NOP
17660  0E20     MOVLW 0x20
17662  6EE6     MOVWF 0xFE6, ACCESS
17664  0E00     MOVLW 0x0
17666  6EE6     MOVWF 0xFE6, ACCESS
17668  ECD0     CALL 0x197A0, 0
1766A  F0CB     NOP
584:                       ++l;
1766C  0EF6     MOVLW 0xF6
1766E  50E3     MOVF 0xFE3, W, ACCESS
17670  0F01     ADDLW 0x1
17672  6E01     MOVWF ltemp0, ACCESS
17674  0EF6     MOVLW 0xF6
17678  F007     NOP
1767A  FFE3     NOP
1767C  6A01     CLRF ltemp0, ACCESS
1767E  0EF7     MOVLW 0xF7
17680  50E3     MOVF 0xFE3, W, ACCESS
17682  2001     ADDWFC ltemp0, W, ACCESS
17684  6E01     MOVWF ltemp0, ACCESS
17686  0EF7     MOVLW 0xF7
1768A  F007     NOP
1768C  FFE3     NOP
585:                   }
586:               }
587:           
588:               return l;
176B4  0EF6     MOVLW 0xF6
176B8  FF8C     NOP
176BA  F001     NOP
176BC  0EF7     MOVLW 0xF7
176C0  FF8C     NOP
176C2  F002     NOP
589:           }
176C4  0EEB     MOVLW 0xEB
176C6  26E1     ADDWF 0xFE1, F, ACCESS
176C8  0EFF     MOVLW 0xFF
176CA  22E2     ADDWFC 0xFE2, F, ACCESS
176CC  0012     RETURN 0
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
167E8  0E0E     MOVLW 0xE
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
167F0  AE3D     BTFSS 0x3D, 7, ACCESS
600:                   flags &= ~ZERO_FLAG;
167F2  923E     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
167F4  BE3D     BTFSC 0x3D, 7, ACCESS
167F6  D005     BRA 0x6802
167F8  503D     MOVF 0x3D, W, ACCESS
167FA  E110     BNZ 0x681C
167FC  043C     DECF prec, W, ACCESS
167FE  B0D8     BTFSC 0xFD8, 0, ACCESS
16800  D00D     BRA 0x681C
16802  0E01     MOVLW 0x1
16804  6E0B     MOVWF wtemp5, ACCESS
16806  0E00     MOVLW 0x0
16808  6E0C     MOVWF 0xC, ACCESS
1680A  0EFE     MOVLW 0xFE
1680E  F02F     NOP
16810  FFE3     NOP
16812  0EFF     MOVLW 0xFF
16816  F033     NOP
16818  FFE3     NOP
1681A  D008     BRA 0x682C
1681C  0EFE     MOVLW 0xFE
16820  F0F3     NOP
16822  FFE3     NOP
16824  0EFF     MOVLW 0xFF
16828  F0F7     NOP
1682A  FFE3     NOP
603:               w = width;
1682C  0EFC     MOVLW 0xFC
16830  F0EB     NOP
16832  FFE3     NOP
16834  0EFD     MOVLW 0xFD
16838  F0EF     NOP
1683A  FFE3     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
1683C  0EE8     MOVLW 0xE8
1683E  24E1     ADDWF 0xFE1, W, ACCESS
16840  6ED9     MOVWF 0xFD9, ACCESS
16842  0EFF     MOVLW 0xFF
16844  20E2     ADDWFC 0xFE2, W, ACCESS
16846  6EDA     MOVWF 0xFDA, ACCESS
16848  0E08     MOVLW 0x8
1684A  6E01     MOVWF ltemp0, ACCESS
1684C  0EF2     MOVLW 0xF2
16850  FF7B     NOP
16852  FFE3     NOP
16854  28E8     INCF 0xFE8, W, ACCESS
16856  2E01     DECFSZ ltemp0, F, ACCESS
16858  D7FA     BRA 0x684E
607:               i = sizeof(dbuf) - 1;
1685A  0E4F     MOVLW 0x4F
1685C  6E0B     MOVWF wtemp5, ACCESS
1685E  0E00     MOVLW 0x0
16860  6E0C     MOVWF 0xC, ACCESS
16862  0EFA     MOVLW 0xFA
16866  F02F     NOP
16868  FFE3     NOP
1686A  0EFB     MOVLW 0xFB
1686E  F033     NOP
16870  FFE3     NOP
608:               dbuf[i] = '\0';
16872  0102     MOVLB 0x2
16874  6BE6     CLRF 0xE6, BANKED
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
16876  D0FB     BRA 0x6A6E
16A6E  0EFA     MOVLW 0xFA
16A72  FF8C     NOP
16A74  F001     NOP
16A76  0EFB     MOVLW 0xFB
16A78  50E3     MOVF 0xFE3, W, ACCESS
16A7A  1001     IORWF ltemp0, W, ACCESS
16A7C  B4D8     BTFSC 0xFD8, 2, ACCESS
16A7E  D02F     BRA 0x6ADE
16A80  0EF2     MOVLW 0xF2
16A82  50E3     MOVF 0xFE3, W, ACCESS
16A84  E115     BNZ 0x6AB0
16A86  0EF3     MOVLW 0xF3
16A88  50E3     MOVF 0xFE3, W, ACCESS
16A8A  E112     BNZ 0x6AB0
16A8C  0EF4     MOVLW 0xF4
16A8E  50E3     MOVF 0xFE3, W, ACCESS
16A90  E10F     BNZ 0x6AB0
16A92  0EF5     MOVLW 0xF5
16A94  50E3     MOVF 0xFE3, W, ACCESS
16A96  E10C     BNZ 0x6AB0
16A98  0EF6     MOVLW 0xF6
16A9A  50E3     MOVF 0xFE3, W, ACCESS
16A9C  E109     BNZ 0x6AB0
16A9E  0EF7     MOVLW 0xF7
16AA0  50E3     MOVF 0xFE3, W, ACCESS
16AA2  E106     BNZ 0x6AB0
16AA4  0EF8     MOVLW 0xF8
16AA6  50E3     MOVF 0xFE3, W, ACCESS
16AA8  E103     BNZ 0x6AB0
16AAA  0EF9     MOVLW 0xF9
16AAC  50E3     MOVF 0xFE3, W, ACCESS
16AAE  A4D8     BTFSS 0xFD8, 2, ACCESS
16AB0  D6E3     BRA 0x6878
16AB2  0EFF     MOVLW 0xFF
16AB4  BEE3     BTFSC 0xFE3, 7, ACCESS
16AB6  D007     BRA 0x6AC6
16AB8  0EFF     MOVLW 0xFF
16ABA  50E3     MOVF 0xFE3, W, ACCESS
16ABC  E103     BNZ 0x6AC4
16ABE  0EFE     MOVLW 0xFE
16AC0  04E3     DECF 0xFE3, W, ACCESS
16AC2  B0D8     BTFSC 0xFD8, 0, ACCESS
16AC4  D6D9     BRA 0x6878
16AC6  0EFD     MOVLW 0xFD
16AC8  BEE3     BTFSC 0xFE3, 7, ACCESS
16ACA  D009     BRA 0x6ADE
16ACC  0EFD     MOVLW 0xFD
16ACE  50E3     MOVF 0xFE3, W, ACCESS
16AD0  E104     BNZ 0x6ADA
16AD2  0EFC     MOVLW 0xFC
16AD4  04E3     DECF 0xFE3, W, ACCESS
16AD6  A0D8     BTFSS 0xFD8, 0, ACCESS
16AD8  D002     BRA 0x6ADE
16ADA  B23E     BTFSC flags, 1, ACCESS
16ADC  D6CD     BRA 0x6878
610:                   --i;
16878  50E1     MOVF 0xFE1, W, ACCESS
1687A  0FFA     ADDLW 0xFA
1687C  6ED9     MOVWF 0xFD9, ACCESS
1687E  50E2     MOVF 0xFE2, W, ACCESS
16880  6EDA     MOVWF 0xFDA, ACCESS
16882  0EFF     MOVLW 0xFF
16884  22DA     ADDWFC 0xFDA, F, ACCESS
16886  06DE     DECF 0xFDE, F, ACCESS
16888  0E00     MOVLW 0x0
1688A  5ADD     SUBWFB 0xFDD, F, ACCESS
611:                   dbuf[i] = '0' + (n % 10);
1688C  0E0A     MOVLW 0xA
1688E  6EE6     MOVWF 0xFE6, ACCESS
16890  0E00     MOVLW 0x0
16892  6EE6     MOVWF 0xFE6, ACCESS
16894  0E00     MOVLW 0x0
16896  6EE6     MOVWF 0xFE6, ACCESS
16898  0E00     MOVLW 0x0
1689A  6EE6     MOVWF 0xFE6, ACCESS
1689C  0E00     MOVLW 0x0
1689E  6EE6     MOVWF 0xFE6, ACCESS
168A0  0E00     MOVLW 0x0
168A2  6EE6     MOVWF 0xFE6, ACCESS
168A4  0E00     MOVLW 0x0
168A6  6EE6     MOVWF 0xFE6, ACCESS
168A8  0E00     MOVLW 0x0
168AA  6EE6     MOVWF 0xFE6, ACCESS
168AC  50E1     MOVF 0xFE1, W, ACCESS
168AE  0FEA     ADDLW 0xEA
168B0  6ED9     MOVWF 0xFD9, ACCESS
168B2  50E2     MOVF 0xFE2, W, ACCESS
168B4  6EDA     MOVWF 0xFDA, ACCESS
168B6  0EFF     MOVLW 0xFF
168B8  22DA     ADDWFC 0xFDA, F, ACCESS
168BC  FF7B     NOP
168BE  FFE6     NOP
168C2  FF7B     NOP
168C4  FFE6     NOP
168C8  FF7B     NOP
168CA  FFE6     NOP
168CE  FF7B     NOP
168D0  FFE6     NOP
168D4  FF7B     NOP
168D6  FFE6     NOP
168DA  FF7B     NOP
168DC  FFE6     NOP
168E0  FF7B     NOP
168E2  FFE6     NOP
168E6  FF7B     NOP
168E8  FFE6     NOP
168EA  ECFE     CALL 0x193FC, 0
168EC  F0C9     NOP
168EE  52E5     MOVF 0xFE5, F, ACCESS
168F2  FF9C     NOP
168F4  F018     NOP
168F6  52E5     MOVF 0xFE5, F, ACCESS
168FA  FF9C     NOP
168FC  F017     NOP
168FE  52E5     MOVF 0xFE5, F, ACCESS
16902  FF9C     NOP
16904  F016     NOP
16906  52E5     MOVF 0xFE5, F, ACCESS
1690A  FF9C     NOP
1690C  F015     NOP
1690E  52E5     MOVF 0xFE5, F, ACCESS
16912  FF9C     NOP
16914  F014     NOP
16916  52E5     MOVF 0xFE5, F, ACCESS
1691A  FF9C     NOP
1691C  F013     NOP
1691E  52E5     MOVF 0xFE5, F, ACCESS
16922  FF9C     NOP
16924  F012     NOP
16926  52E5     MOVF 0xFE5, F, ACCESS
1692A  FF9C     NOP
1692C  F011     NOP
1692E  0EF8     MOVLW 0xF8
16930  26E1     ADDWF 0xFE1, F, ACCESS
16932  0EFF     MOVLW 0xFF
16934  22E2     ADDWFC 0xFE2, F, ACCESS
16936  0E30     MOVLW 0x30
16938  2611     ADDWF lltemp2, F, ACCESS
1693A  0EFA     MOVLW 0xFA
1693E  FF8C     NOP
16940  F00B     NOP
16942  0EFB     MOVLW 0xFB
16946  FF8C     NOP
16948  F00C     NOP
1694A  0E97     MOVLW 0x97
1694C  240B     ADDWF wtemp5, W, ACCESS
1694E  6ED9     MOVWF 0xFD9, ACCESS
16950  0E02     MOVLW 0x2
16952  200C     ADDWFC 0xC, W, ACCESS
16954  6EDA     MOVWF 0xFDA, ACCESS
16958  F047     NOP
1695A  FFDF     NOP
612:                   --p;
1695C  50E1     MOVF 0xFE1, W, ACCESS
1695E  0FFE     ADDLW 0xFE
16960  6ED9     MOVWF 0xFD9, ACCESS
16962  50E2     MOVF 0xFE2, W, ACCESS
16964  6EDA     MOVWF 0xFDA, ACCESS
16966  0EFF     MOVLW 0xFF
16968  22DA     ADDWFC 0xFDA, F, ACCESS
1696A  06DE     DECF 0xFDE, F, ACCESS
1696C  0E00     MOVLW 0x0
1696E  5ADD     SUBWFB 0xFDD, F, ACCESS
613:                   --w;
16970  50E1     MOVF 0xFE1, W, ACCESS
16972  0FFC     ADDLW 0xFC
16974  6ED9     MOVWF 0xFD9, ACCESS
16976  50E2     MOVF 0xFE2, W, ACCESS
16978  6EDA     MOVWF 0xFDA, ACCESS
1697A  0EFF     MOVLW 0xFF
1697C  22DA     ADDWFC 0xFDA, F, ACCESS
1697E  06DE     DECF 0xFDE, F, ACCESS
16980  0E00     MOVLW 0x0
16982  5ADD     SUBWFB 0xFDD, F, ACCESS
614:                   n = n / 10;
16984  0E0A     MOVLW 0xA
16986  6EE6     MOVWF 0xFE6, ACCESS
16988  0E00     MOVLW 0x0
1698A  6EE6     MOVWF 0xFE6, ACCESS
1698C  0E00     MOVLW 0x0
1698E  6EE6     MOVWF 0xFE6, ACCESS
16990  0E00     MOVLW 0x0
16992  6EE6     MOVWF 0xFE6, ACCESS
16994  0E00     MOVLW 0x0
16996  6EE6     MOVWF 0xFE6, ACCESS
16998  0E00     MOVLW 0x0
1699A  6EE6     MOVWF 0xFE6, ACCESS
1699C  0E00     MOVLW 0x0
1699E  6EE6     MOVWF 0xFE6, ACCESS
169A0  0E00     MOVLW 0x0
169A2  6EE6     MOVWF 0xFE6, ACCESS
169A4  50E1     MOVF 0xFE1, W, ACCESS
169A6  0FEA     ADDLW 0xEA
169A8  6ED9     MOVWF 0xFD9, ACCESS
169AA  50E2     MOVF 0xFE2, W, ACCESS
169AC  6EDA     MOVWF 0xFDA, ACCESS
169AE  0EFF     MOVLW 0xFF
169B0  22DA     ADDWFC 0xFDA, F, ACCESS
169B4  FF7B     NOP
169B6  FFE6     NOP
169BA  FF7B     NOP
169BC  FFE6     NOP
169C0  FF7B     NOP
169C2  FFE6     NOP
169C6  FF7B     NOP
169C8  FFE6     NOP
169CC  FF7B     NOP
169CE  FFE6     NOP
169D2  FF7B     NOP
169D4  FFE6     NOP
169D8  FF7B     NOP
169DA  FFE6     NOP
169DE  FF7B     NOP
169E0  FFE6     NOP
169E2  EC7B     CALL 0x18CF6, 0
169E4  F0C6     NOP
169E6  52E5     MOVF 0xFE5, F, ACCESS
169EA  FF9C     NOP
169EC  F018     NOP
169EE  52E5     MOVF 0xFE5, F, ACCESS
169F2  FF9C     NOP
169F4  F017     NOP
169F6  52E5     MOVF 0xFE5, F, ACCESS
169FA  FF9C     NOP
169FC  F016     NOP
169FE  52E5     MOVF 0xFE5, F, ACCESS
16A02  FF9C     NOP
16A04  F015     NOP
16A06  52E5     MOVF 0xFE5, F, ACCESS
16A0A  FF9C     NOP
16A0C  F014     NOP
16A0E  52E5     MOVF 0xFE5, F, ACCESS
16A12  FF9C     NOP
16A14  F013     NOP
16A16  52E5     MOVF 0xFE5, F, ACCESS
16A1A  FF9C     NOP
16A1C  F012     NOP
16A1E  52E5     MOVF 0xFE5, F, ACCESS
16A22  FF9C     NOP
16A24  F011     NOP
16A26  0EF8     MOVLW 0xF8
16A28  26E1     ADDWF 0xFE1, F, ACCESS
16A2A  0EFF     MOVLW 0xFF
16A2C  22E2     ADDWFC 0xFE2, F, ACCESS
16A2E  0EF2     MOVLW 0xF2
16A32  F047     NOP
16A34  FFE3     NOP
16A36  0EF3     MOVLW 0xF3
16A3A  F04B     NOP
16A3C  FFE3     NOP
16A3E  0EF4     MOVLW 0xF4
16A42  F04F     NOP
16A44  FFE3     NOP
16A46  0EF5     MOVLW 0xF5
16A4A  F053     NOP
16A4C  FFE3     NOP
16A4E  0EF6     MOVLW 0xF6
16A52  F057     NOP
16A54  FFE3     NOP
16A56  0EF7     MOVLW 0xF7
16A5A  F05B     NOP
16A5C  FFE3     NOP
16A5E  0EF8     MOVLW 0xF8
16A62  F05F     NOP
16A64  FFE3     NOP
16A66  0EF9     MOVLW 0xF9
16A6A  F063     NOP
16A6C  FFE3     NOP
615:               }
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
16ADE  0EFC     MOVLW 0xFC
16AE2  FF8F     NOP
16AE4  FFE6     NOP
16AE8  FF8F     NOP
16AEA  FFE6     NOP
16AEC  0E97     MOVLW 0x97
16AEE  6E0B     MOVWF wtemp5, ACCESS
16AF0  0E02     MOVLW 0x2
16AF2  6E0C     MOVWF 0xC, ACCESS
16AF4  0EF8     MOVLW 0xF8
16AF6  50E3     MOVF 0xFE3, W, ACCESS
16AF8  260B     ADDWF wtemp5, F, ACCESS
16AFA  0EF9     MOVLW 0xF9
16AFC  50E3     MOVF 0xFE3, W, ACCESS
16AFE  220C     ADDWFC 0xC, F, ACCESS
16B02  F02F     NOP
16B04  FFE6     NOP
16B08  F033     NOP
16B0A  FFE6     NOP
16B0C  0EEC     MOVLW 0xEC
16B10  FF8F     NOP
16B12  FFE6     NOP
16B16  FF8F     NOP
16B18  FFE6     NOP
16B1A  ECEE     CALL 0x199DC, 0
16B1C  F0CC     NOP
619:           }
16B1E  0EE8     MOVLW 0xE8
16B20  26E1     ADDWF 0xFE1, F, ACCESS
16B22  0EFF     MOVLW 0xFF
16B24  22E2     ADDWFC 0xFE2, F, ACCESS
16B26  0012     RETURN 0
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
160C2  0E14     MOVLW 0x14
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
160CA  AE3D     BTFSS 0x3D, 7, ACCESS
630:                   flags &= ~ZERO_FLAG;
160CC  923E     BCF flags, 1, ACCESS
631:               }
632:               p = (0 < prec) ? prec : 1;
160CE  BE3D     BTFSC 0x3D, 7, ACCESS
160D0  D005     BRA 0x60DC
160D2  503D     MOVF 0x3D, W, ACCESS
160D4  E110     BNZ 0x60F6
160D6  043C     DECF prec, W, ACCESS
160D8  B0D8     BTFSC 0xFD8, 0, ACCESS
160DA  D00D     BRA 0x60F6
160DC  0E01     MOVLW 0x1
160DE  6E0B     MOVWF wtemp5, ACCESS
160E0  0E00     MOVLW 0x0
160E2  6E0C     MOVWF 0xC, ACCESS
160E4  0EFE     MOVLW 0xFE
160E8  F02F     NOP
160EA  FFE3     NOP
160EC  0EFF     MOVLW 0xFF
160F0  F033     NOP
160F2  FFE3     NOP
160F4  D008     BRA 0x6106
160F6  0EFE     MOVLW 0xFE
160FA  F0F3     NOP
160FC  FFE3     NOP
160FE  0EFF     MOVLW 0xFF
16102  F0F7     NOP
16104  FFE3     NOP
633:               w = width;
16106  0EFC     MOVLW 0xFC
1610A  F0EB     NOP
1610C  FFE3     NOP
1610E  0EFD     MOVLW 0xFD
16112  F0EF     NOP
16114  FFE3     NOP
634:               if (flags & POUND_FLAG) {
16116  A83E     BTFSS flags, 4, ACCESS
16118  D00B     BRA 0x6130
635:                   w -= 2;
1611A  50E1     MOVF 0xFE1, W, ACCESS
1611C  0FFC     ADDLW 0xFC
1611E  6ED9     MOVWF 0xFD9, ACCESS
16120  50E2     MOVF 0xFE2, W, ACCESS
16122  6EDA     MOVWF 0xFDA, ACCESS
16124  0EFF     MOVLW 0xFF
16126  22DA     ADDWFC 0xFDA, F, ACCESS
16128  0EFE     MOVLW 0xFE
1612A  26DE     ADDWF 0xFDE, F, ACCESS
1612C  0EFF     MOVLW 0xFF
1612E  22DD     ADDWFC 0xFDD, F, ACCESS
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
16130  0EE2     MOVLW 0xE2
16132  24E1     ADDWF 0xFE1, W, ACCESS
16134  6ED9     MOVWF 0xFD9, ACCESS
16136  0EFF     MOVLW 0xFF
16138  20E2     ADDWFC 0xFE2, W, ACCESS
1613A  6EDA     MOVWF 0xFDA, ACCESS
1613C  0E08     MOVLW 0x8
1613E  6E01     MOVWF ltemp0, ACCESS
16140  0EF0     MOVLW 0xF0
16144  FF7B     NOP
16146  FFE3     NOP
16148  28E8     INCF 0xFE8, W, ACCESS
1614A  2E01     DECFSZ ltemp0, F, ACCESS
1614C  D7FA     BRA 0x6142
640:               i = sizeof(dbuf) - 1;
1614E  0E4F     MOVLW 0x4F
16150  6E0B     MOVWF wtemp5, ACCESS
16152  0E00     MOVLW 0x0
16154  6E0C     MOVWF 0xC, ACCESS
16156  0EFA     MOVLW 0xFA
1615A  F02F     NOP
1615C  FFE3     NOP
1615E  0EFB     MOVLW 0xFB
16162  F033     NOP
16164  FFE3     NOP
641:               dbuf[i] = '\0';
16166  0102     MOVLB 0x2
16168  6BE6     CLRF 0xE6, BANKED
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
1616A  D0EE     BRA 0x6348
16348  0EFB     MOVLW 0xFB
1634A  BEE3     BTFSC 0xFE3, 7, ACCESS
1634C  D03A     BRA 0x63C2
1634E  0EFB     MOVLW 0xFB
16350  50E3     MOVF 0xFE3, W, ACCESS
16352  E108     BNZ 0x6364
16354  0EFA     MOVLW 0xFA
16358  FF8C     NOP
1635A  F001     NOP
1635C  0E02     MOVLW 0x2
1635E  5E01     SUBWF ltemp0, F, ACCESS
16360  A0D8     BTFSS 0xFD8, 0, ACCESS
16362  D02F     BRA 0x63C2
16364  0EF0     MOVLW 0xF0
16366  50E3     MOVF 0xFE3, W, ACCESS
16368  E115     BNZ 0x6394
1636A  0EF1     MOVLW 0xF1
1636C  50E3     MOVF 0xFE3, W, ACCESS
1636E  E112     BNZ 0x6394
16370  0EF2     MOVLW 0xF2
16372  50E3     MOVF 0xFE3, W, ACCESS
16374  E10F     BNZ 0x6394
16376  0EF3     MOVLW 0xF3
16378  50E3     MOVF 0xFE3, W, ACCESS
1637A  E10C     BNZ 0x6394
1637C  0EF4     MOVLW 0xF4
1637E  50E3     MOVF 0xFE3, W, ACCESS
16380  E109     BNZ 0x6394
16382  0EF5     MOVLW 0xF5
16384  50E3     MOVF 0xFE3, W, ACCESS
16386  E106     BNZ 0x6394
16388  0EF6     MOVLW 0xF6
1638A  50E3     MOVF 0xFE3, W, ACCESS
1638C  E103     BNZ 0x6394
1638E  0EF7     MOVLW 0xF7
16390  50E3     MOVF 0xFE3, W, ACCESS
16392  A4D8     BTFSS 0xFD8, 2, ACCESS
16394  D6EB     BRA 0x616C
16396  0EFF     MOVLW 0xFF
16398  BEE3     BTFSC 0xFE3, 7, ACCESS
1639A  D007     BRA 0x63AA
1639C  0EFF     MOVLW 0xFF
1639E  50E3     MOVF 0xFE3, W, ACCESS
163A0  E103     BNZ 0x63A8
163A2  0EFE     MOVLW 0xFE
163A4  04E3     DECF 0xFE3, W, ACCESS
163A6  B0D8     BTFSC 0xFD8, 0, ACCESS
163A8  D6E1     BRA 0x616C
163AA  0EFD     MOVLW 0xFD
163AC  BEE3     BTFSC 0xFE3, 7, ACCESS
163AE  D009     BRA 0x63C2
163B0  0EFD     MOVLW 0xFD
163B2  50E3     MOVF 0xFE3, W, ACCESS
163B4  E104     BNZ 0x63BE
163B6  0EFC     MOVLW 0xFC
163B8  04E3     DECF 0xFE3, W, ACCESS
163BA  A0D8     BTFSS 0xFD8, 0, ACCESS
163BC  D002     BRA 0x63C2
163BE  B23E     BTFSC flags, 1, ACCESS
163C0  D6D5     BRA 0x616C
643:                   --i;
1616C  50E1     MOVF 0xFE1, W, ACCESS
1616E  0FFA     ADDLW 0xFA
16170  6ED9     MOVWF 0xFD9, ACCESS
16172  50E2     MOVF 0xFE2, W, ACCESS
16174  6EDA     MOVWF 0xFDA, ACCESS
16176  0EFF     MOVLW 0xFF
16178  22DA     ADDWFC 0xFDA, F, ACCESS
1617A  06DE     DECF 0xFDE, F, ACCESS
1617C  0E00     MOVLW 0x0
1617E  5ADD     SUBWFB 0xFDD, F, ACCESS
644:                   c = n & 0x0f;
16180  0EF0     MOVLW 0xF0
16184  FF8C     NOP
16186  F00B     NOP
16188  0EF1     MOVLW 0xF1
1618C  FF8C     NOP
1618E  F00C     NOP
16190  0E0F     MOVLW 0xF
16192  160B     ANDWF wtemp5, F, ACCESS
16194  0E00     MOVLW 0x0
16196  160C     ANDWF 0xC, F, ACCESS
16198  0EF8     MOVLW 0xF8
1619C  F02F     NOP
1619E  FFE3     NOP
161A0  0EF9     MOVLW 0xF9
161A4  F033     NOP
161A6  FFE3     NOP
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
161A8  0EF9     MOVLW 0xF9
161AA  BEE3     BTFSC 0xFE3, 7, ACCESS
161AC  D00F     BRA 0x61CC
161AE  0EF9     MOVLW 0xF9
161B0  50E3     MOVF 0xFE3, W, ACCESS
161B2  E108     BNZ 0x61C4
161B4  0EF8     MOVLW 0xF8
161B8  FF8C     NOP
161BA  F001     NOP
161BC  0E0A     MOVLW 0xA
161BE  5E01     SUBWF ltemp0, F, ACCESS
161C0  A0D8     BTFSS 0xFD8, 0, ACCESS
161C2  D004     BRA 0x61CC
161C4  0EF8     MOVLW 0xF8
161C6  50E3     MOVF 0xFE3, W, ACCESS
161C8  0F57     ADDLW 0x57
161CA  D003     BRA 0x61D2
161CC  0EF8     MOVLW 0xF8
161CE  50E3     MOVF 0xFE3, W, ACCESS
161D0  0F30     ADDLW 0x30
161D2  6E0B     MOVWF wtemp5, ACCESS
161D4  0EF9     MOVLW 0xF9
161D8  FF8C     NOP
161DA  F00C     NOP
161DC  0E00     MOVLW 0x0
161DE  220C     ADDWFC 0xC, F, ACCESS
161E0  0EF8     MOVLW 0xF8
161E4  F02F     NOP
161E6  FFE3     NOP
161E8  0EF9     MOVLW 0xF9
161EC  F033     NOP
161EE  FFE3     NOP
646:                   if (isupper((int)x) && isalpha(c)) {
161F0  0EBF     MOVLW 0xBF
161F2  6E0B     MOVWF wtemp5, ACCESS
161F4  0EFF     MOVLW 0xFF
161F6  6E0C     MOVWF 0xC, ACCESS
161F8  0EE1     MOVLW 0xE1
161FA  50E3     MOVF 0xFE3, W, ACCESS
161FC  6E09     MOVWF ltemp2, ACCESS
161FE  6A0A     CLRF ttemp3, ACCESS
16200  500B     MOVF wtemp5, W, ACCESS
16202  2609     ADDWF ltemp2, F, ACCESS
16204  500C     MOVF 0xC, W, ACCESS
16206  220A     ADDWFC ttemp3, F, ACCESS
16208  500A     MOVF ttemp3, W, ACCESS
1620A  E106     BNZ 0x6218
1620C  0E1A     MOVLW 0x1A
1620E  5C09     SUBWF ltemp2, W, ACCESS
16210  B0D8     BTFSC 0xFD8, 0, ACCESS
16212  D002     BRA 0x6218
16214  0E01     MOVLW 0x1
16216  D001     BRA 0x621A
16218  0E00     MOVLW 0x0
1621A  6E0B     MOVWF wtemp5, ACCESS
1621C  6A0C     CLRF 0xC, ACCESS
1621E  0EEE     MOVLW 0xEE
16222  F02F     NOP
16224  FFE3     NOP
16226  0EEF     MOVLW 0xEF
1622A  F033     NOP
1622C  FFE3     NOP
1622E  0EEE     MOVLW 0xEE
16232  FF8C     NOP
16234  F001     NOP
16236  0EEF     MOVLW 0xEF
16238  50E3     MOVF 0xFE3, W, ACCESS
1623A  1001     IORWF ltemp0, W, ACCESS
1623C  B4D8     BTFSC 0xFD8, 2, ACCESS
1623E  D041     BRA 0x62C2
16240  0E9F     MOVLW 0x9F
16242  6E0B     MOVWF wtemp5, ACCESS
16244  0EFF     MOVLW 0xFF
16246  6E0C     MOVWF 0xC, ACCESS
16248  0EF8     MOVLW 0xF8
1624C  FF8C     NOP
1624E  F009     NOP
16250  0EF9     MOVLW 0xF9
16254  FF8C     NOP
16256  F00A     NOP
16258  0E20     MOVLW 0x20
1625A  1209     IORWF ltemp2, F, ACCESS
1625C  0E00     MOVLW 0x0
1625E  120A     IORWF ttemp3, F, ACCESS
16260  500B     MOVF wtemp5, W, ACCESS
16262  2609     ADDWF ltemp2, F, ACCESS
16264  500C     MOVF 0xC, W, ACCESS
16266  220A     ADDWFC ttemp3, F, ACCESS
16268  500A     MOVF ttemp3, W, ACCESS
1626A  E106     BNZ 0x6278
1626C  0E1A     MOVLW 0x1A
1626E  5C09     SUBWF ltemp2, W, ACCESS
16270  B0D8     BTFSC 0xFD8, 0, ACCESS
16272  D002     BRA 0x6278
16274  0E01     MOVLW 0x1
16276  D001     BRA 0x627A
16278  0E00     MOVLW 0x0
1627A  6E0B     MOVWF wtemp5, ACCESS
1627C  6A0C     CLRF 0xC, ACCESS
1627E  0EEC     MOVLW 0xEC
16282  F02F     NOP
16284  FFE3     NOP
16286  0EED     MOVLW 0xED
1628A  F033     NOP
1628C  FFE3     NOP
1628E  0EEC     MOVLW 0xEC
16292  FF8C     NOP
16294  F001     NOP
16296  0EED     MOVLW 0xED
16298  50E3     MOVF 0xFE3, W, ACCESS
1629A  1001     IORWF ltemp0, W, ACCESS
1629C  B4D8     BTFSC 0xFD8, 2, ACCESS
1629E  D011     BRA 0x62C2
647:                       c = toupper(c);
162A0  0EF8     MOVLW 0xF8
162A4  FF8F     NOP
162A6  FFE6     NOP
162AA  FF8F     NOP
162AC  FFE6     NOP
162AE  EC2A     CALL 0x1AC54, 0
162B0  F0D6     NOP
162B2  0EF8     MOVLW 0xF8
162B6  F007     NOP
162B8  FFE3     NOP
162BA  0EF9     MOVLW 0xF9
162BE  F00B     NOP
162C0  FFE3     NOP
648:                   }
649:                   dbuf[i] = (char)c;
162C2  0EFA     MOVLW 0xFA
162C6  FF8C     NOP
162C8  F00B     NOP
162CA  0EFB     MOVLW 0xFB
162CE  FF8C     NOP
162D0  F00C     NOP
162D2  0E97     MOVLW 0x97
162D4  240B     ADDWF wtemp5, W, ACCESS
162D6  6ED9     MOVWF 0xFD9, ACCESS
162D8  0E02     MOVLW 0x2
162DA  200C     ADDWFC 0xC, W, ACCESS
162DC  6EDA     MOVWF 0xFDA, ACCESS
162DE  0EF8     MOVLW 0xF8
162E2  FF8F     NOP
162E4  FFDF     NOP
650:                   --p;
162E6  50E1     MOVF 0xFE1, W, ACCESS
162E8  0FFE     ADDLW 0xFE
162EA  6ED9     MOVWF 0xFD9, ACCESS
162EC  50E2     MOVF 0xFE2, W, ACCESS
162EE  6EDA     MOVWF 0xFDA, ACCESS
162F0  0EFF     MOVLW 0xFF
162F2  22DA     ADDWFC 0xFDA, F, ACCESS
162F4  06DE     DECF 0xFDE, F, ACCESS
162F6  0E00     MOVLW 0x0
162F8  5ADD     SUBWFB 0xFDD, F, ACCESS
651:                   --w;
162FA  50E1     MOVF 0xFE1, W, ACCESS
162FC  0FFC     ADDLW 0xFC
162FE  6ED9     MOVWF 0xFD9, ACCESS
16300  50E2     MOVF 0xFE2, W, ACCESS
16302  6EDA     MOVWF 0xFDA, ACCESS
16304  0EFF     MOVLW 0xFF
16306  22DA     ADDWFC 0xFDA, F, ACCESS
16308  06DE     DECF 0xFDE, F, ACCESS
1630A  0E00     MOVLW 0x0
1630C  5ADD     SUBWFB 0xFDD, F, ACCESS
652:                   n = n >> 4;
1630E  0E04     MOVLW 0x4
16310  6E0C     MOVWF 0xC, ACCESS
16312  50E1     MOVF 0xFE1, W, ACCESS
16314  0FF0     ADDLW 0xF0
16316  6ED9     MOVWF 0xFD9, ACCESS
16318  50E2     MOVF 0xFE2, W, ACCESS
1631A  6EDA     MOVWF 0xFDA, ACCESS
1631C  0EFF     MOVLW 0xFF
1631E  22DA     ADDWFC 0xFDA, F, ACCESS
16320  280C     INCF 0xC, W, ACCESS
16322  52DE     MOVF 0xFDE, F, ACCESS
16324  D00F     BRA 0x6344
16326  52DE     MOVF 0xFDE, F, ACCESS
16328  52DE     MOVF 0xFDE, F, ACCESS
1632A  52DE     MOVF 0xFDE, F, ACCESS
1632C  52DE     MOVF 0xFDE, F, ACCESS
1632E  52DE     MOVF 0xFDE, F, ACCESS
16330  52DE     MOVF 0xFDE, F, ACCESS
16332  90D8     BCF 0xFD8, 0, ACCESS
16334  32DD     RRCF 0xFDD, F, ACCESS
16336  32DD     RRCF 0xFDD, F, ACCESS
16338  32DD     RRCF 0xFDD, F, ACCESS
1633A  32DD     RRCF 0xFDD, F, ACCESS
1633C  32DD     RRCF 0xFDD, F, ACCESS
1633E  32DD     RRCF 0xFDD, F, ACCESS
16340  32DD     RRCF 0xFDD, F, ACCESS
16342  32DE     RRCF 0xFDE, F, ACCESS
16344  2EE8     DECFSZ 0xFE8, F, ACCESS
16346  D7EF     BRA 0x6326
653:               }
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
163C2  A83E     BTFSS flags, 4, ACCESS
163C4  D036     BRA 0x6432
657:                   --i;
163C6  50E1     MOVF 0xFE1, W, ACCESS
163C8  0FFA     ADDLW 0xFA
163CA  6ED9     MOVWF 0xFD9, ACCESS
163CC  50E2     MOVF 0xFE2, W, ACCESS
163CE  6EDA     MOVWF 0xFDA, ACCESS
163D0  0EFF     MOVLW 0xFF
163D2  22DA     ADDWFC 0xFDA, F, ACCESS
163D4  06DE     DECF 0xFDE, F, ACCESS
163D6  0E00     MOVLW 0x0
163D8  5ADD     SUBWFB 0xFDD, F, ACCESS
658:                   dbuf[i] = x;
163DA  0EFA     MOVLW 0xFA
163DE  FF8C     NOP
163E0  F00B     NOP
163E2  0EFB     MOVLW 0xFB
163E6  FF8C     NOP
163E8  F00C     NOP
163EA  0E97     MOVLW 0x97
163EC  240B     ADDWF wtemp5, W, ACCESS
163EE  6ED9     MOVWF 0xFD9, ACCESS
163F0  0E02     MOVLW 0x2
163F2  200C     ADDWFC 0xC, W, ACCESS
163F4  6EDA     MOVWF 0xFDA, ACCESS
163F6  0EE1     MOVLW 0xE1
163FA  FF8F     NOP
163FC  FFDF     NOP
659:                   --i;
163FE  50E1     MOVF 0xFE1, W, ACCESS
16400  0FFA     ADDLW 0xFA
16402  6ED9     MOVWF 0xFD9, ACCESS
16404  50E2     MOVF 0xFE2, W, ACCESS
16406  6EDA     MOVWF 0xFDA, ACCESS
16408  0EFF     MOVLW 0xFF
1640A  22DA     ADDWFC 0xFDA, F, ACCESS
1640C  06DE     DECF 0xFDE, F, ACCESS
1640E  0E00     MOVLW 0x0
16410  5ADD     SUBWFB 0xFDD, F, ACCESS
660:                   dbuf[i] = '0';
16412  0EFA     MOVLW 0xFA
16416  FF8C     NOP
16418  F00B     NOP
1641A  0EFB     MOVLW 0xFB
1641E  FF8C     NOP
16420  F00C     NOP
16422  0E97     MOVLW 0x97
16424  240B     ADDWF wtemp5, W, ACCESS
16426  6ED9     MOVWF 0xFD9, ACCESS
16428  0E02     MOVLW 0x2
1642A  200C     ADDWFC 0xC, W, ACCESS
1642C  6EDA     MOVWF 0xFDA, ACCESS
1642E  0E30     MOVLW 0x30
16430  6EDF     MOVWF 0xFDF, ACCESS
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
16432  0EFC     MOVLW 0xFC
16436  FF8F     NOP
16438  FFE6     NOP
1643C  FF8F     NOP
1643E  FFE6     NOP
16440  0E97     MOVLW 0x97
16442  6E0B     MOVWF wtemp5, ACCESS
16444  0E02     MOVLW 0x2
16446  6E0C     MOVWF 0xC, ACCESS
16448  0EF8     MOVLW 0xF8
1644A  50E3     MOVF 0xFE3, W, ACCESS
1644C  260B     ADDWF wtemp5, F, ACCESS
1644E  0EF9     MOVLW 0xF9
16450  50E3     MOVF 0xFE3, W, ACCESS
16452  220C     ADDWFC 0xC, F, ACCESS
16456  F02F     NOP
16458  FFE6     NOP
1645C  F033     NOP
1645E  FFE6     NOP
16460  0EE6     MOVLW 0xE6
16464  FF8F     NOP
16466  FFE6     NOP
1646A  FF8F     NOP
1646C  FFE6     NOP
1646E  ECEE     CALL 0x199DC, 0
16470  F0CC     NOP
665:           }
16472  0EE1     MOVLW 0xE1
16474  26E1     ADDWF 0xFE1, F, ACCESS
16476  0EFF     MOVLW 0xFF
16478  22E2     ADDWFC 0xFE2, F, ACCESS
1647A  0012     RETURN 0
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
123A0  0E20     MOVLW 0x20
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
123A8  0EDC     MOVLW 0xDC
123AC  FF8F     NOP
123AE  FFD9     NOP
123B0  0EDD     MOVLW 0xDD
123B4  FF8F     NOP
123B6  FFDA     NOP
123BA  FF7B     NOP
123BC  FFF6     NOP
123C0  FF77     NOP
123C2  FFF7     NOP
123C4  0E00     MOVLW 0x0
123C6  6EF8     MOVWF 0xFF8, ACCESS
123C8  0008     TBLRD*
123CA  50F5     MOVF 0xFF5, W, ACCESS
123CC  0A25     XORLW 0x25
123CE  A4D8     BTFSS 0xFD8, 2, ACCESS
123D0  EF77     GOTO 0x132EE
123D2  F099     NOP
681:                   ++*fmt;
123D4  0EDC     MOVLW 0xDC
123D8  FF8F     NOP
123DA  FFD9     NOP
123DC  0EDD     MOVLW 0xDD
123E0  FF8F     NOP
123E2  FFDA     NOP
123E4  2ADE     INCF 0xFDE, F, ACCESS
123E6  0E00     MOVLW 0x0
123E8  22DD     ADDWFC 0xFDD, F, ACCESS
682:           
683:                   flags = width = 0;
123EA  6A3A     CLRF width, ACCESS
123EC  6A3B     CLRF 0x3B, ACCESS
123EE  6A3E     CLRF flags, ACCESS
123F0  6A3F     CLRF 0x3F, ACCESS
684:                   prec = -1;
123F2  683C     SETF prec, ACCESS
123F4  683D     SETF 0x3D, ACCESS
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
689:                   while (!done) {
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
693:                               ++*fmt;
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
697:                               ++*fmt;
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
701:                               ++*fmt;
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
705:                               ++*fmt;
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
709:                               ++*fmt;
710:                               break;
711:                           default:
712:                               done = 1;
713:                               break;
714:                       }
715:                   }
716:                   if (flags & MINUS_FLAG) {
717:                       flags &= ~ZERO_FLAG;
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
123F6  0EDC     MOVLW 0xDC
123FA  FF8F     NOP
123FC  FFD9     NOP
123FE  0EDD     MOVLW 0xDD
12402  FF8F     NOP
12404  FFDA     NOP
12408  FF7B     NOP
1240A  FFF6     NOP
1240E  FF77     NOP
12410  FFF7     NOP
12412  0E00     MOVLW 0x0
12414  6EF8     MOVWF 0xFF8, ACCESS
12416  0008     TBLRD*
12418  50F5     MOVF 0xFF5, W, ACCESS
1241A  0A2A     XORLW 0x2A
1241C  A4D8     BTFSS 0xFD8, 2, ACCESS
1241E  D031     BRA 0x2482
724:                       ++*fmt;
12420  0EDC     MOVLW 0xDC
12424  FF8F     NOP
12426  FFD9     NOP
12428  0EDD     MOVLW 0xDD
1242C  FF8F     NOP
1242E  FFDA     NOP
12430  2ADE     INCF 0xFDE, F, ACCESS
12432  0E00     MOVLW 0x0
12434  22DD     ADDWFC 0xFDD, F, ACCESS
725:                       width = va_arg(ap, int);
12436  0EDA     MOVLW 0xDA
1243A  FF8F     NOP
1243C  FFD9     NOP
1243E  0EDB     MOVLW 0xDB
12442  FF8F     NOP
12444  FFDA     NOP
12446  0E02     MOVLW 0x2
12448  5EDE     SUBWF 0xFDE, F, ACCESS
1244A  0E00     MOVLW 0x0
1244C  5ADD     SUBWFB 0xFDD, F, ACCESS
12450  FF78     NOP
12452  F00B     NOP
12456  FF74     NOP
12458  F00C     NOP
1245C  F02F     NOP
1245E  FFD9     NOP
12462  F033     NOP
12464  FFDA     NOP
12468  FF78     NOP
1246A  F03A     NOP
1246E  FF74     NOP
12470  F03B     NOP
726:                       if (width < 0) {
12472  AE3B     BTFSS 0x3B, 7, ACCESS
12474  D066     BRA 0x2542
727:                           flags |= MINUS_FLAG;
12476  803E     BSF flags, 0, ACCESS
728:                           width = -width;
12478  6C3A     NEGF width, ACCESS
1247A  1E3B     COMF 0x3B, F, ACCESS
1247C  B0D8     BTFSC 0xFD8, 0, ACCESS
1247E  2A3B     INCF 0x3B, F, ACCESS
12480  D060     BRA 0x2542
729:                       }
730:                   } else {
731:                       width = atoi(*fmt);
12482  0EDC     MOVLW 0xDC
12486  FF8F     NOP
12488  FFD9     NOP
1248A  0EDD     MOVLW 0xDD
1248E  FF8F     NOP
12490  FFDA     NOP
12494  FF78     NOP
12496  F00B     NOP
1249A  FF74     NOP
1249C  F00C     NOP
124A0  F02F     NOP
124A2  FFE6     NOP
124A6  F033     NOP
124A8  FFE6     NOP
124AA  ECA7     CALL 0x1794E, 0
124AC  F0BC     NOP
124B0  F004     NOP
124B2  F03A     NOP
124B6  F008     NOP
124B8  F03B     NOP
732:                       while (isdigit((*fmt)[0])) {
124BA  D00B     BRA 0x24D2
124D2  0ED0     MOVLW 0xD0
124D4  6E0B     MOVWF wtemp5, ACCESS
124D6  0EFF     MOVLW 0xFF
124D8  6E0C     MOVWF 0xC, ACCESS
124DA  0EDC     MOVLW 0xDC
124DE  FF8F     NOP
124E0  FFD9     NOP
124E2  0EDD     MOVLW 0xDD
124E6  FF8F     NOP
124E8  FFDA     NOP
124EC  FF7B     NOP
124EE  FFF6     NOP
124F2  FF77     NOP
124F4  FFF7     NOP
124F6  0E00     MOVLW 0x0
124F8  6EF8     MOVWF 0xFF8, ACCESS
124FA  0008     TBLRD*
124FC  50F5     MOVF 0xFF5, W, ACCESS
124FE  6E09     MOVWF ltemp2, ACCESS
12500  6A0A     CLRF ttemp3, ACCESS
12502  500B     MOVF wtemp5, W, ACCESS
12504  2609     ADDWF ltemp2, F, ACCESS
12506  500C     MOVF 0xC, W, ACCESS
12508  220A     ADDWFC ttemp3, F, ACCESS
1250A  500A     MOVF ttemp3, W, ACCESS
1250C  E106     BNZ 0x251A
1250E  0E0A     MOVLW 0xA
12510  5C09     SUBWF ltemp2, W, ACCESS
12512  B0D8     BTFSC 0xFD8, 0, ACCESS
12514  D002     BRA 0x251A
12516  0E01     MOVLW 0x1
12518  D001     BRA 0x251C
1251A  0E00     MOVLW 0x0
1251C  6E0B     MOVWF wtemp5, ACCESS
1251E  6A0C     CLRF 0xC, ACCESS
12520  0EE4     MOVLW 0xE4
12524  F02F     NOP
12526  FFE3     NOP
12528  0EE5     MOVLW 0xE5
1252C  F033     NOP
1252E  FFE3     NOP
12530  0EE4     MOVLW 0xE4
12534  FF8C     NOP
12536  F001     NOP
12538  0EE5     MOVLW 0xE5
1253A  50E3     MOVF 0xFE3, W, ACCESS
1253C  1001     IORWF ltemp0, W, ACCESS
1253E  A4D8     BTFSS 0xFD8, 2, ACCESS
12540  D7BD     BRA 0x24BC
733:                           ++*fmt;
124BC  0EDC     MOVLW 0xDC
124C0  FF8F     NOP
124C2  FFD9     NOP
124C4  0EDD     MOVLW 0xDD
124C8  FF8F     NOP
124CA  FFDA     NOP
124CC  2ADE     INCF 0xFDE, F, ACCESS
124CE  0E00     MOVLW 0x0
124D0  22DD     ADDWFC 0xFDD, F, ACCESS
734:                       }
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
12542  0EDC     MOVLW 0xDC
12546  FF8F     NOP
12548  FFD9     NOP
1254A  0EDD     MOVLW 0xDD
1254E  FF8F     NOP
12550  FFDA     NOP
12554  FF7B     NOP
12556  FFF6     NOP
1255A  FF77     NOP
1255C  FFF7     NOP
1255E  0E00     MOVLW 0x0
12560  6EF8     MOVWF 0xFF8, ACCESS
12562  0008     TBLRD*
12564  50F5     MOVF 0xFF5, W, ACCESS
12566  0A2E     XORLW 0x2E
12568  A4D8     BTFSS 0xFD8, 2, ACCESS
1256A  D0AC     BRA 0x26C4
741:                       prec = 0;
1256C  6A3C     CLRF prec, ACCESS
1256E  6A3D     CLRF 0x3D, ACCESS
742:                       ++*fmt;
12570  0EDC     MOVLW 0xDC
12574  FF8F     NOP
12576  FFD9     NOP
12578  0EDD     MOVLW 0xDD
1257C  FF8F     NOP
1257E  FFDA     NOP
12580  2ADE     INCF 0xFDE, F, ACCESS
12582  0E00     MOVLW 0x0
12584  22DD     ADDWFC 0xFDD, F, ACCESS
743:                       if ((*fmt)[0] == '*') {
12586  0EDC     MOVLW 0xDC
1258A  FF8F     NOP
1258C  FFD9     NOP
1258E  0EDD     MOVLW 0xDD
12592  FF8F     NOP
12594  FFDA     NOP
12598  FF7B     NOP
1259A  FFF6     NOP
1259E  FF77     NOP
125A0  FFF7     NOP
125A2  0E00     MOVLW 0x0
125A4  6EF8     MOVWF 0xFF8, ACCESS
125A6  0008     TBLRD*
125A8  50F5     MOVF 0xFF5, W, ACCESS
125AA  0A2A     XORLW 0x2A
125AC  A4D8     BTFSS 0xFD8, 2, ACCESS
125AE  D02A     BRA 0x2604
744:                           ++*fmt;
125B0  0EDC     MOVLW 0xDC
125B4  FF8F     NOP
125B6  FFD9     NOP
125B8  0EDD     MOVLW 0xDD
125BC  FF8F     NOP
125BE  FFDA     NOP
125C0  2ADE     INCF 0xFDE, F, ACCESS
125C2  0E00     MOVLW 0x0
125C4  22DD     ADDWFC 0xFDD, F, ACCESS
745:                           prec = va_arg(ap, int);
125C6  0EDA     MOVLW 0xDA
125CA  FF8F     NOP
125CC  FFD9     NOP
125CE  0EDB     MOVLW 0xDB
125D2  FF8F     NOP
125D4  FFDA     NOP
125D6  0E02     MOVLW 0x2
125D8  5EDE     SUBWF 0xFDE, F, ACCESS
125DA  0E00     MOVLW 0x0
125DC  5ADD     SUBWFB 0xFDD, F, ACCESS
125E0  FF78     NOP
125E2  F00B     NOP
125E6  FF74     NOP
125E8  F00C     NOP
125EC  F02F     NOP
125EE  FFD9     NOP
125F2  F033     NOP
125F4  FFDA     NOP
125F8  FF78     NOP
125FA  F03C     NOP
125FE  FF74     NOP
12600  F03D     NOP
746:                       } else {
12602  D060     BRA 0x26C4
747:                           prec = atoi(*fmt);
12604  0EDC     MOVLW 0xDC
12608  FF8F     NOP
1260A  FFD9     NOP
1260C  0EDD     MOVLW 0xDD
12610  FF8F     NOP
12612  FFDA     NOP
12616  FF78     NOP
12618  F00B     NOP
1261C  FF74     NOP
1261E  F00C     NOP
12622  F02F     NOP
12624  FFE6     NOP
12628  F033     NOP
1262A  FFE6     NOP
1262C  ECA7     CALL 0x1794E, 0
1262E  F0BC     NOP
12632  F004     NOP
12634  F03C     NOP
12638  F008     NOP
1263A  F03D     NOP
748:                           while (isdigit((*fmt)[0])) {
1263C  D00B     BRA 0x2654
12654  0ED0     MOVLW 0xD0
12656  6E0B     MOVWF wtemp5, ACCESS
12658  0EFF     MOVLW 0xFF
1265A  6E0C     MOVWF 0xC, ACCESS
1265C  0EDC     MOVLW 0xDC
12660  FF8F     NOP
12662  FFD9     NOP
12664  0EDD     MOVLW 0xDD
12668  FF8F     NOP
1266A  FFDA     NOP
1266E  FF7B     NOP
12670  FFF6     NOP
12674  FF77     NOP
12676  FFF7     NOP
12678  0E00     MOVLW 0x0
1267A  6EF8     MOVWF 0xFF8, ACCESS
1267C  0008     TBLRD*
1267E  50F5     MOVF 0xFF5, W, ACCESS
12680  6E09     MOVWF ltemp2, ACCESS
12682  6A0A     CLRF ttemp3, ACCESS
12684  500B     MOVF wtemp5, W, ACCESS
12686  2609     ADDWF ltemp2, F, ACCESS
12688  500C     MOVF 0xC, W, ACCESS
1268A  220A     ADDWFC ttemp3, F, ACCESS
1268C  500A     MOVF ttemp3, W, ACCESS
1268E  E106     BNZ 0x269C
12690  0E0A     MOVLW 0xA
12692  5C09     SUBWF ltemp2, W, ACCESS
12694  B0D8     BTFSC 0xFD8, 0, ACCESS
12696  D002     BRA 0x269C
12698  0E01     MOVLW 0x1
1269A  D001     BRA 0x269E
1269C  0E00     MOVLW 0x0
1269E  6E0B     MOVWF wtemp5, ACCESS
126A0  6A0C     CLRF 0xC, ACCESS
126A2  0EE0     MOVLW 0xE0
126A6  F02F     NOP
126A8  FFE3     NOP
126AA  0EE1     MOVLW 0xE1
126AE  F033     NOP
126B0  FFE3     NOP
126B2  0EE0     MOVLW 0xE0
126B6  FF8C     NOP
126B8  F001     NOP
126BA  0EE1     MOVLW 0xE1
126BC  50E3     MOVF 0xFE3, W, ACCESS
126BE  1001     IORWF ltemp0, W, ACCESS
126C0  A4D8     BTFSS 0xFD8, 2, ACCESS
126C2  D7BD     BRA 0x263E
749:                               ++*fmt;
1263E  0EDC     MOVLW 0xDC
12642  FF8F     NOP
12644  FFD9     NOP
12646  0EDD     MOVLW 0xDD
1264A  FF8F     NOP
1264C  FFDA     NOP
1264E  2ADE     INCF 0xFDE, F, ACCESS
12650  0E00     MOVLW 0x0
12652  22DD     ADDWFC 0xFDD, F, ACCESS
750:                           }
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
126C4  0EDC     MOVLW 0xDC
126C8  FF8F     NOP
126CA  FFD9     NOP
126CC  0EDD     MOVLW 0xDD
126D0  FF8F     NOP
126D2  FFDA     NOP
126D6  FF7B     NOP
126D8  FFF6     NOP
126DC  FF77     NOP
126DE  FFF7     NOP
126E0  0E00     MOVLW 0x0
126E2  6EF8     MOVWF 0xFF8, ACCESS
126E4  0008     TBLRD*
126E6  50F5     MOVF 0xFF5, W, ACCESS
126E8  6EE6     MOVWF 0xFE6, ACCESS
126EA  0E00     MOVLW 0x0
126EC  6EE6     MOVWF 0xFE6, ACCESS
126EE  EC6C     CALL 0x1ACD8, 0
126F0  F0D6     NOP
126F2  0EFA     MOVLW 0xFA
126F6  F007     NOP
126F8  FFE3     NOP
758:                   if (ct[0]) {
126FA  0EFA     MOVLW 0xFA
126FC  50E3     MOVF 0xFE3, W, ACCESS
126FE  B4D8     BTFSC 0xFD8, 2, ACCESS
12700  D05B     BRA 0x27B8
759:                       ct[1] = tolower((int)(*fmt)[1]);
12702  0EFB     MOVLW 0xFB
12704  24E1     ADDWF 0xFE1, W, ACCESS
12706  6ED9     MOVWF 0xFD9, ACCESS
12708  0EFF     MOVLW 0xFF
1270A  20E2     ADDWFC 0xFE2, W, ACCESS
1270C  6EDA     MOVWF 0xFDA, ACCESS
1270E  0EDC     MOVLW 0xDC
12712  FF8F     NOP
12714  FFE9     NOP
12716  0EDD     MOVLW 0xDD
1271A  FF8F     NOP
1271C  FFEA     NOP
12720  FFB8     NOP
12722  F00B     NOP
12726  FFB4     NOP
12728  F00C     NOP
1272A  0E01     MOVLW 0x1
1272C  260B     ADDWF wtemp5, F, ACCESS
1272E  0E00     MOVLW 0x0
12730  220C     ADDWFC 0xC, F, ACCESS
12734  F02F     NOP
12736  FFF6     NOP
1273A  F033     NOP
1273C  FFF7     NOP
1273E  0E00     MOVLW 0x0
12740  6EF8     MOVWF 0xFF8, ACCESS
12742  0008     TBLRD*
12744  50F5     MOVF 0xFF5, W, ACCESS
12746  6EE6     MOVWF 0xFE6, ACCESS
12748  0E00     MOVLW 0x0
1274A  6EE6     MOVWF 0xFE6, ACCESS
1274C  EC6C     CALL 0x1ACD8, 0
1274E  F0D6     NOP
12750  5001     MOVF ltemp0, W, ACCESS
12752  6EDF     MOVWF 0xFDF, ACCESS
760:                       if (ct[1]) {
12754  0EFB     MOVLW 0xFB
12756  24E1     ADDWF 0xFE1, W, ACCESS
12758  6ED9     MOVWF 0xFD9, ACCESS
1275A  0EFF     MOVLW 0xFF
1275C  20E2     ADDWFC 0xFE2, W, ACCESS
1275E  6EDA     MOVWF 0xFDA, ACCESS
12760  50DF     MOVF 0xFDF, W, ACCESS
12762  B4D8     BTFSC 0xFD8, 2, ACCESS
12764  D029     BRA 0x27B8
761:                           ct[2] = tolower((int)(*fmt)[2]);
12766  0EFC     MOVLW 0xFC
12768  24E1     ADDWF 0xFE1, W, ACCESS
1276A  6ED9     MOVWF 0xFD9, ACCESS
1276C  0EFF     MOVLW 0xFF
1276E  20E2     ADDWFC 0xFE2, W, ACCESS
12770  6EDA     MOVWF 0xFDA, ACCESS
12772  0EDC     MOVLW 0xDC
12776  FF8F     NOP
12778  FFE9     NOP
1277A  0EDD     MOVLW 0xDD
1277E  FF8F     NOP
12780  FFEA     NOP
12784  FFB8     NOP
12786  F00B     NOP
1278A  FFB4     NOP
1278C  F00C     NOP
1278E  0E02     MOVLW 0x2
12790  260B     ADDWF wtemp5, F, ACCESS
12792  0E00     MOVLW 0x0
12794  220C     ADDWFC 0xC, F, ACCESS
12798  F02F     NOP
1279A  FFF6     NOP
1279E  F033     NOP
127A0  FFF7     NOP
127A2  0E00     MOVLW 0x0
127A4  6EF8     MOVWF 0xFF8, ACCESS
127A6  0008     TBLRD*
127A8  50F5     MOVF 0xFF5, W, ACCESS
127AA  6EE6     MOVWF 0xFE6, ACCESS
127AC  0E00     MOVLW 0x0
127AE  6EE6     MOVWF 0xFE6, ACCESS
127B0  EC6C     CALL 0x1ACD8, 0
127B2  F0D6     NOP
127B4  5001     MOVF ltemp0, W, ACCESS
127B6  6EDF     MOVWF 0xFDF, ACCESS
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
127B8  0EDC     MOVLW 0xDC
127BC  FF8F     NOP
127BE  FFD9     NOP
127C0  0EDD     MOVLW 0xDD
127C4  FF8F     NOP
127C6  FFDA     NOP
127CA  FF7B     NOP
127CC  FFF6     NOP
127D0  FF77     NOP
127D2  FFF7     NOP
127D4  0E00     MOVLW 0x0
127D6  6EF8     MOVWF 0xFF8, ACCESS
127D8  0008     TBLRD*
127DA  50F5     MOVF 0xFF5, W, ACCESS
127DC  0A63     XORLW 0x63
127DE  A4D8     BTFSS 0xFD8, 2, ACCESS
127E0  D037     BRA 0x2850
793:                       ++*fmt;
127E2  0EDC     MOVLW 0xDC
127E6  FF8F     NOP
127E8  FFD9     NOP
127EA  0EDD     MOVLW 0xDD
127EE  FF8F     NOP
127F0  FFDA     NOP
127F2  2ADE     INCF 0xFDE, F, ACCESS
127F4  0E00     MOVLW 0x0
127F6  22DD     ADDWFC 0xFDD, F, ACCESS
794:                       c = (unsigned char)va_arg(ap, int);
127F8  0EDA     MOVLW 0xDA
127FC  FF8F     NOP
127FE  FFD9     NOP
12800  0EDB     MOVLW 0xDB
12804  FF8F     NOP
12806  FFDA     NOP
12808  0E02     MOVLW 0x2
1280A  5EDE     SUBWF 0xFDE, F, ACCESS
1280C  0E00     MOVLW 0x0
1280E  5ADD     SUBWFB 0xFDD, F, ACCESS
12812  FF78     NOP
12814  F00B     NOP
12818  FF74     NOP
1281A  F00C     NOP
1281E  F02F     NOP
12820  FFD9     NOP
12824  F033     NOP
12826  FFDA     NOP
12828  50DF     MOVF 0xFDF, W, ACCESS
1282A  6E0C     MOVWF 0xC, ACCESS
1282C  0EFF     MOVLW 0xFF
12830  F033     NOP
12832  FFE3     NOP
795:                       return ctoa(fp, c);
12834  0EFF     MOVLW 0xFF
12836  50E3     MOVF 0xFE3, W, ACCESS
12838  6EE6     MOVWF 0xFE6, ACCESS
1283A  0EDD     MOVLW 0xDD
1283E  FF8F     NOP
12840  FFE6     NOP
12844  FF8F     NOP
12846  FFE6     NOP
12848  ECE6     CALL 0x1ABCC, 0
1284A  F0D5     NOP
1284C  EFA1     GOTO 0x13342
1284E  F099     NOP
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
806:                       ll = (long long)(signed char)va_arg(ap, int);
807:                                   
808:                       return dtoa(fp, ll);
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
818:                       ll = (long long)(short)va_arg(ap, int);
819:                                   
820:                       return dtoa(fp, ll);
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
12850  0EDC     MOVLW 0xDC
12854  FF8F     NOP
12856  FFD9     NOP
12858  0EDD     MOVLW 0xDD
1285C  FF8F     NOP
1285E  FFDA     NOP
12862  FF7B     NOP
12864  FFF6     NOP
12868  FF77     NOP
1286A  FFF7     NOP
1286C  0E00     MOVLW 0x0
1286E  6EF8     MOVWF 0xFF8, ACCESS
12870  0008     TBLRD*
12872  50F5     MOVF 0xFF5, W, ACCESS
12874  0A64     XORLW 0x64
12876  B4D8     BTFSC 0xFD8, 2, ACCESS
12878  D015     BRA 0x28A4
1287A  0EDC     MOVLW 0xDC
1287E  FF8F     NOP
12880  FFD9     NOP
12882  0EDD     MOVLW 0xDD
12886  FF8F     NOP
12888  FFDA     NOP
1288C  FF7B     NOP
1288E  FFF6     NOP
12892  FF77     NOP
12894  FFF7     NOP
12896  0E00     MOVLW 0x0
12898  6EF8     MOVWF 0xFF8, ACCESS
1289A  0008     TBLRD*
1289C  50F5     MOVF 0xFF5, W, ACCESS
1289E  0A69     XORLW 0x69
128A0  A4D8     BTFSS 0xFD8, 2, ACCESS
128A2  D076     BRA 0x2990
826:           
827:                       ++*fmt;
128A4  0EDC     MOVLW 0xDC
128A8  FF8F     NOP
128AA  FFD9     NOP
128AC  0EDD     MOVLW 0xDD
128B0  FF8F     NOP
128B2  FFDA     NOP
128B4  2ADE     INCF 0xFDE, F, ACCESS
128B6  0E00     MOVLW 0x0
128B8  22DD     ADDWFC 0xFDD, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
128BA  0EDA     MOVLW 0xDA
128BE  FF8F     NOP
128C0  FFD9     NOP
128C2  0EDB     MOVLW 0xDB
128C6  FF8F     NOP
128C8  FFDA     NOP
128CA  0E02     MOVLW 0x2
128CC  5EDE     SUBWF 0xFDE, F, ACCESS
128CE  0E00     MOVLW 0x0
128D0  5ADD     SUBWFB 0xFDD, F, ACCESS
128D4  FF78     NOP
128D6  F00B     NOP
128DA  FF74     NOP
128DC  F00C     NOP
128E0  F02F     NOP
128E2  FFD9     NOP
128E6  F033     NOP
128E8  FFDA     NOP
128EC  FF78     NOP
128EE  F00B     NOP
128F2  FF74     NOP
128F4  F00C     NOP
128F6  0EEE     MOVLW 0xEE
128FA  F02F     NOP
128FC  FFE3     NOP
128FE  0EEF     MOVLW 0xEF
12902  F033     NOP
12904  FFE3     NOP
12906  6A01     CLRF ltemp0, ACCESS
12908  BEE3     BTFSC 0xFE3, 7, ACCESS
1290A  6801     SETF ltemp0, ACCESS
1290C  0EF0     MOVLW 0xF0
12910  F007     NOP
12912  FFE3     NOP
12914  0EF1     MOVLW 0xF1
12918  F007     NOP
1291A  FFE3     NOP
1291C  0EF2     MOVLW 0xF2
12920  F007     NOP
12922  FFE3     NOP
12924  0EF3     MOVLW 0xF3
12928  F007     NOP
1292A  FFE3     NOP
1292C  0EF4     MOVLW 0xF4
12930  F007     NOP
12932  FFE3     NOP
12934  0EF5     MOVLW 0xF5
12938  F007     NOP
1293A  FFE3     NOP
829:                                   
830:                       return dtoa(fp, ll);
1293C  50E1     MOVF 0xFE1, W, ACCESS
1293E  0FEE     ADDLW 0xEE
12940  6ED9     MOVWF 0xFD9, ACCESS
12942  50E2     MOVF 0xFE2, W, ACCESS
12944  6EDA     MOVWF 0xFDA, ACCESS
12946  0EFF     MOVLW 0xFF
12948  22DA     ADDWFC 0xFDA, F, ACCESS
1294C  FF7B     NOP
1294E  FFE6     NOP
12952  FF7B     NOP
12954  FFE6     NOP
12958  FF7B     NOP
1295A  FFE6     NOP
1295E  FF7B     NOP
12960  FFE6     NOP
12964  FF7B     NOP
12966  FFE6     NOP
1296A  FF7B     NOP
1296C  FFE6     NOP
12970  FF7B     NOP
12972  FFE6     NOP
12976  FF7B     NOP
12978  FFE6     NOP
1297A  0ED6     MOVLW 0xD6
1297E  FF8F     NOP
12980  FFE6     NOP
12984  FF8F     NOP
12986  FFE6     NOP
12988  ECFB     CALL 0x157F6, 0
1298A  F0AB     NOP
1298C  EFA1     GOTO 0x13342
1298E  F099     NOP
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
12990  0E02     MOVLW 0x2
12992  6EE6     MOVWF 0xFE6, ACCESS
12994  0E00     MOVLW 0x0
12996  6EE6     MOVWF 0xFE6, ACCESS
12998  0EEA     MOVLW 0xEA
1299A  6EE6     MOVWF 0xFE6, ACCESS
1299C  0EFF     MOVLW 0xFF
1299E  6EE6     MOVWF 0xFE6, ACCESS
129A0  0ED8     MOVLW 0xD8
129A4  FF8F     NOP
129A6  FFD9     NOP
129A8  0ED9     MOVLW 0xD9
129AC  FF8F     NOP
129AE  FFDA     NOP
129B2  FF78     NOP
129B4  F00B     NOP
129B8  FF74     NOP
129BA  F00C     NOP
129BE  F02F     NOP
129C0  FFE6     NOP
129C4  F033     NOP
129C6  FFE6     NOP
129C8  EC24     CALL 0x18048, 0
129CA  F0C0     NOP
129CC  5001     MOVF ltemp0, W, ACCESS
129CE  1002     IORWF ttemp5, W, ACCESS
129D0  B4D8     BTFSC 0xFD8, 2, ACCESS
129D2  D022     BRA 0x2A18
129D4  0E02     MOVLW 0x2
129D6  6EE6     MOVWF 0xFE6, ACCESS
129D8  0E00     MOVLW 0x0
129DA  6EE6     MOVWF 0xFE6, ACCESS
129DC  0EF0     MOVLW 0xF0
129DE  6EE6     MOVWF 0xFE6, ACCESS
129E0  0EFF     MOVLW 0xFF
129E2  6EE6     MOVWF 0xFE6, ACCESS
129E4  0ED8     MOVLW 0xD8
129E8  FF8F     NOP
129EA  FFD9     NOP
129EC  0ED9     MOVLW 0xD9
129F0  FF8F     NOP
129F2  FFDA     NOP
129F6  FF78     NOP
129F8  F00B     NOP
129FC  FF74     NOP
129FE  F00C     NOP
12A02  F02F     NOP
12A04  FFE6     NOP
12A08  F033     NOP
12A0A  FFE6     NOP
12A0C  EC24     CALL 0x18048, 0
12A0E  F0C0     NOP
12A10  5001     MOVF ltemp0, W, ACCESS
12A12  1002     IORWF ttemp5, W, ACCESS
12A14  A4D8     BTFSS 0xFD8, 2, ACCESS
12A16  D069     BRA 0x2AEA
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
12A18  0EDC     MOVLW 0xDC
12A1C  FF8F     NOP
12A1E  FFD9     NOP
12A20  0EDD     MOVLW 0xDD
12A24  FF8F     NOP
12A26  FFDA     NOP
12A28  0E02     MOVLW 0x2
12A2A  26DE     ADDWF 0xFDE, F, ACCESS
12A2C  0E00     MOVLW 0x0
12A2E  22DD     ADDWFC 0xFDD, F, ACCESS
839:                       ll = (long long)va_arg(ap, long);
12A30  0EDA     MOVLW 0xDA
12A34  FF8F     NOP
12A36  FFD9     NOP
12A38  0EDB     MOVLW 0xDB
12A3C  FF8F     NOP
12A3E  FFDA     NOP
12A40  0E04     MOVLW 0x4
12A42  5EDE     SUBWF 0xFDE, F, ACCESS
12A44  0E00     MOVLW 0x0
12A46  5ADD     SUBWFB 0xFDD, F, ACCESS
12A4A  FF78     NOP
12A4C  F00B     NOP
12A50  FF74     NOP
12A52  F00C     NOP
12A56  F02F     NOP
12A58  FFD9     NOP
12A5C  F033     NOP
12A5E  FFDA     NOP
12A62  FF78     NOP
12A64  F009     NOP
12A68  FF78     NOP
12A6A  F00A     NOP
12A6E  FF78     NOP
12A70  F00B     NOP
12A74  FF78     NOP
12A76  F00C     NOP
12A7A  F024     NOP
12A7C  F011     NOP
12A80  F028     NOP
12A82  F012     NOP
12A86  F02C     NOP
12A88  F013     NOP
12A8C  F030     NOP
12A8E  F014     NOP
12A90  6A15     CLRF 0x15, ACCESS
12A92  BE14     BTFSC 0x14, 7, ACCESS
12A94  6815     SETF 0x15, ACCESS
12A98  F054     NOP
12A9A  F016     NOP
12A9E  F054     NOP
12AA0  F017     NOP
12AA4  F054     NOP
12AA6  F018     NOP
12AA8  0EEE     MOVLW 0xEE
12AAC  F047     NOP
12AAE  FFE3     NOP
12AB0  0EEF     MOVLW 0xEF
12AB4  F04B     NOP
12AB6  FFE3     NOP
12AB8  0EF0     MOVLW 0xF0
12ABC  F04F     NOP
12ABE  FFE3     NOP
12AC0  0EF1     MOVLW 0xF1
12AC4  F053     NOP
12AC6  FFE3     NOP
12AC8  0EF2     MOVLW 0xF2
12ACC  F057     NOP
12ACE  FFE3     NOP
12AD0  0EF3     MOVLW 0xF3
12AD4  F05B     NOP
12AD6  FFE3     NOP
12AD8  0EF4     MOVLW 0xF4
12ADC  F05F     NOP
12ADE  FFE3     NOP
12AE0  0EF5     MOVLW 0xF5
12AE4  F063     NOP
12AE6  FFE3     NOP
12AE8  D729     BRA 0x293C
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
887:                       ll = (long long)va_arg(ap, size_t);
888:                                   
889:                       return dtoa(fp, ll);
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
12AEA  0EFA     MOVLW 0xFA
12AEE  FF8C     NOP
12AF0  F001     NOP
12AF2  0E66     MOVLW 0x66
12AF4  1801     XORWF ltemp0, W, ACCESS
12AF6  A4D8     BTFSS 0xFD8, 2, ACCESS
12AF8  D06E     BRA 0x2BD6
921:           
922:                       c = (*fmt)[0];
12AFA  0EDC     MOVLW 0xDC
12AFE  FF8F     NOP
12B00  FFD9     NOP
12B02  0EDD     MOVLW 0xDD
12B06  FF8F     NOP
12B08  FFDA     NOP
12B0C  FF7B     NOP
12B0E  FFF6     NOP
12B12  FF77     NOP
12B14  FFF7     NOP
12B16  0E00     MOVLW 0x0
12B18  6EF8     MOVWF 0xFF8, ACCESS
12B1A  0008     TBLRD*
12B1C  0EFF     MOVLW 0xFF
12B20  FFD7     NOP
12B22  FFE3     NOP
923:                       ++*fmt;
12B24  0EDC     MOVLW 0xDC
12B28  FF8F     NOP
12B2A  FFD9     NOP
12B2C  0EDD     MOVLW 0xDD
12B30  FF8F     NOP
12B32  FFDA     NOP
12B34  2ADE     INCF 0xFDE, F, ACCESS
12B36  0E00     MOVLW 0x0
12B38  22DD     ADDWFC 0xFDD, F, ACCESS
924:                       f = (long double)va_arg(ap, double);
12B3A  0EDA     MOVLW 0xDA
12B3E  FF8F     NOP
12B40  FFD9     NOP
12B42  0EDB     MOVLW 0xDB
12B46  FF8F     NOP
12B48  FFDA     NOP
12B4A  0E04     MOVLW 0x4
12B4C  5EDE     SUBWF 0xFDE, F, ACCESS
12B4E  0E00     MOVLW 0x0
12B50  5ADD     SUBWFB 0xFDD, F, ACCESS
12B54  FF78     NOP
12B56  F00B     NOP
12B5A  FF74     NOP
12B5C  F00C     NOP
12B60  F02F     NOP
12B62  FFD9     NOP
12B66  F033     NOP
12B68  FFDA     NOP
12B6C  FF78     NOP
12B6E  F009     NOP
12B72  FF78     NOP
12B74  F00A     NOP
12B78  FF78     NOP
12B7A  F00B     NOP
12B7E  FF78     NOP
12B80  F00C     NOP
12B82  0EF6     MOVLW 0xF6
12B86  F027     NOP
12B88  FFE3     NOP
12B8A  0EF7     MOVLW 0xF7
12B8E  F02B     NOP
12B90  FFE3     NOP
12B92  0EF8     MOVLW 0xF8
12B96  F02F     NOP
12B98  FFE3     NOP
12B9A  0EF9     MOVLW 0xF9
12B9E  F033     NOP
12BA0  FFE3     NOP
925:                                   
926:                       return efgtoa(fp, f, c);
12BA2  0EFF     MOVLW 0xFF
12BA4  50E3     MOVF 0xFE3, W, ACCESS
12BA6  6EE6     MOVWF 0xFE6, ACCESS
12BA8  0EF5     MOVLW 0xF5
12BAC  FF8F     NOP
12BAE  FFE6     NOP
12BB2  FF8F     NOP
12BB4  FFE6     NOP
12BB8  FF8F     NOP
12BBA  FFE6     NOP
12BBE  FF8F     NOP
12BC0  FFE6     NOP
12BC2  0ED9     MOVLW 0xD9
12BC6  FF8F     NOP
12BC8  FFE6     NOP
12BCC  FF8F     NOP
12BCE  FFE6     NOP
12BD0  EC00     CALL 0x10000, 0
12BD2  F080     NOP
12BD4  D3B6     BRA 0x3342
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
12BD6  0E02     MOVLW 0x2
12BD8  6EE6     MOVWF 0xFE6, ACCESS
12BDA  0E00     MOVLW 0x0
12BDC  6EE6     MOVWF 0xFE6, ACCESS
12BDE  0EED     MOVLW 0xED
12BE0  6EE6     MOVWF 0xFE6, ACCESS
12BE2  0EFF     MOVLW 0xFF
12BE4  6EE6     MOVWF 0xFE6, ACCESS
12BE6  0EF6     MOVLW 0xF6
12BE8  24E1     ADDWF 0xFE1, W, ACCESS
12BEA  6E01     MOVWF ltemp0, ACCESS
12BEC  0EFF     MOVLW 0xFF
12BEE  20E2     ADDWFC 0xFE2, W, ACCESS
12BF0  6E02     MOVWF ttemp5, ACCESS
12BF4  F007     NOP
12BF6  FFE6     NOP
12BFA  F00B     NOP
12BFC  FFE6     NOP
12BFE  EC24     CALL 0x18048, 0
12C00  F0C0     NOP
12C02  5001     MOVF ltemp0, W, ACCESS
12C04  1002     IORWF ttemp5, W, ACCESS
12C06  A4D8     BTFSS 0xFD8, 2, ACCESS
12C08  D096     BRA 0x2D36
929:           
930:                       c = (*fmt)[1];
12C0A  0EDC     MOVLW 0xDC
12C0E  FF8F     NOP
12C10  FFD9     NOP
12C12  0EDD     MOVLW 0xDD
12C16  FF8F     NOP
12C18  FFDA     NOP
12C1C  FF78     NOP
12C1E  F00B     NOP
12C22  FF74     NOP
12C24  F00C     NOP
12C26  0E01     MOVLW 0x1
12C28  260B     ADDWF wtemp5, F, ACCESS
12C2A  0E00     MOVLW 0x0
12C2C  220C     ADDWFC 0xC, F, ACCESS
12C30  F02F     NOP
12C32  FFF6     NOP
12C36  F033     NOP
12C38  FFF7     NOP
12C3A  0E00     MOVLW 0x0
12C3C  6EF8     MOVWF 0xFF8, ACCESS
12C3E  0008     TBLRD*
12C40  0EFF     MOVLW 0xFF
12C44  FFD7     NOP
12C46  FFE3     NOP
931:                       if (isupper((int)(*fmt)[0])) {
12C48  0EBF     MOVLW 0xBF
12C4A  6E0B     MOVWF wtemp5, ACCESS
12C4C  0EFF     MOVLW 0xFF
12C4E  6E0C     MOVWF 0xC, ACCESS
12C50  0EDC     MOVLW 0xDC
12C54  FF8F     NOP
12C56  FFD9     NOP
12C58  0EDD     MOVLW 0xDD
12C5C  FF8F     NOP
12C5E  FFDA     NOP
12C62  FF7B     NOP
12C64  FFF6     NOP
12C68  FF77     NOP
12C6A  FFF7     NOP
12C6C  0E00     MOVLW 0x0
12C6E  6EF8     MOVWF 0xFF8, ACCESS
12C70  0008     TBLRD*
12C72  50F5     MOVF 0xFF5, W, ACCESS
12C74  6E09     MOVWF ltemp2, ACCESS
12C76  6A0A     CLRF ttemp3, ACCESS
12C78  500B     MOVF wtemp5, W, ACCESS
12C7A  2609     ADDWF ltemp2, F, ACCESS
12C7C  500C     MOVF 0xC, W, ACCESS
12C7E  220A     ADDWFC ttemp3, F, ACCESS
12C80  500A     MOVF ttemp3, W, ACCESS
12C82  E106     BNZ 0x2C90
12C84  0E1A     MOVLW 0x1A
12C86  5C09     SUBWF ltemp2, W, ACCESS
12C88  B0D8     BTFSC 0xFD8, 0, ACCESS
12C8A  D002     BRA 0x2C90
12C8C  0E01     MOVLW 0x1
12C8E  D001     BRA 0x2C92
12C90  0E00     MOVLW 0x0
12C92  6E0B     MOVWF wtemp5, ACCESS
12C94  6A0C     CLRF 0xC, ACCESS
12C96  0EE2     MOVLW 0xE2
12C9A  F02F     NOP
12C9C  FFE3     NOP
12C9E  0EE3     MOVLW 0xE3
12CA2  F033     NOP
12CA4  FFE3     NOP
12CA6  0EE2     MOVLW 0xE2
12CAA  FF8C     NOP
12CAC  F001     NOP
12CAE  0EE3     MOVLW 0xE3
12CB0  50E3     MOVF 0xFE3, W, ACCESS
12CB2  1001     IORWF ltemp0, W, ACCESS
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
12CB4  0EDA     MOVLW 0xDA
12CB8  FF8F     NOP
12CBA  FFD9     NOP
12CBC  0EDB     MOVLW 0xDB
12CC0  FF8F     NOP
12CC2  FFDA     NOP
12CC4  0E04     MOVLW 0x4
12CC6  5EDE     SUBWF 0xFDE, F, ACCESS
12CC8  0E00     MOVLW 0x0
12CCA  5ADD     SUBWFB 0xFDD, F, ACCESS
12CCE  FF78     NOP
12CD0  F00B     NOP
12CD4  FF74     NOP
12CD6  F00C     NOP
12CDA  F02F     NOP
12CDC  FFD9     NOP
12CE0  F033     NOP
12CE2  FFDA     NOP
12CE6  FF78     NOP
12CE8  F009     NOP
12CEC  FF78     NOP
12CEE  F00A     NOP
12CF2  FF78     NOP
12CF4  F00B     NOP
12CF8  FF78     NOP
12CFA  F00C     NOP
12CFC  0EF6     MOVLW 0xF6
12D00  F027     NOP
12D02  FFE3     NOP
12D04  0EF7     MOVLW 0xF7
12D08  F02B     NOP
12D0A  FFE3     NOP
12D0C  0EF8     MOVLW 0xF8
12D10  F02F     NOP
12D12  FFE3     NOP
12D14  0EF9     MOVLW 0xF9
12D18  F033     NOP
12D1A  FFE3     NOP
935:                       }
936:                       *fmt += CSTRLEN("lf");
12D1C  0EDC     MOVLW 0xDC
12D20  FF8F     NOP
12D22  FFD9     NOP
12D24  0EDD     MOVLW 0xDD
12D28  FF8F     NOP
12D2A  FFDA     NOP
12D2C  0E02     MOVLW 0x2
12D2E  26DE     ADDWF 0xFDE, F, ACCESS
12D30  0E00     MOVLW 0x0
12D32  22DD     ADDWFC 0xFDD, F, ACCESS
12D34  D736     BRA 0x2BA2
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
970:           
971:                       *fmt += CSTRLEN("hho");
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
973:                                   
974:                       return otoa(fp, llu);
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
981:           
982:                       *fmt += CSTRLEN("ho");
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
984:                                   
985:                       return otoa(fp, llu);
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
991:           
992:                       ++*fmt;
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
994:                                   
995:                       return otoa(fp, llu);
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
1045:          
1046:                      *fmt += CSTRLEN("zo");
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
1048:                                  
1049:                      return otoa(fp, llu);
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
1059:          
1060:                      *fmt += CSTRLEN("hhn");
1061:                      vp = (void *)va_arg(ap, char *);
1062:                      *(char *)vp = (char)nout;
1063:                      return 0;
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
1069:          
1070:                      *fmt += CSTRLEN("hn");
1071:                      vp = (void *)va_arg(ap, short *);
1072:                      *(short *)vp = (short)nout;
1073:                      return 0;
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
1078:                      ++*fmt;
1079:                      vp = (void *)va_arg(ap, int *);
1080:                      *(int *)vp = nout;
1081:                      return 0;
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
1126:          
1127:                      *fmt += CSTRLEN("zn");
1128:                      vp = (void *)va_arg(ap, size_t *);
1129:                      *(size_t *)vp = (size_t)nout;
1130:                      return 0;
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
1139:          
1140:                      ++*fmt;
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
12D36  0EDC     MOVLW 0xDC
12D3A  FF8F     NOP
12D3C  FFD9     NOP
12D3E  0EDD     MOVLW 0xDD
12D42  FF8F     NOP
12D44  FFDA     NOP
12D48  FF7B     NOP
12D4A  FFF6     NOP
12D4E  FF77     NOP
12D50  FFF7     NOP
12D52  0E00     MOVLW 0x0
12D54  6EF8     MOVWF 0xFF8, ACCESS
12D56  0008     TBLRD*
12D58  50F5     MOVF 0xFF5, W, ACCESS
12D5A  0A73     XORLW 0x73
12D5C  A4D8     BTFSS 0xFD8, 2, ACCESS
12D5E  D042     BRA 0x2DE4
1150:          
1151:                      ++*fmt;
12D60  0EDC     MOVLW 0xDC
12D64  FF8F     NOP
12D66  FFD9     NOP
12D68  0EDD     MOVLW 0xDD
12D6C  FF8F     NOP
12D6E  FFDA     NOP
12D70  2ADE     INCF 0xFDE, F, ACCESS
12D72  0E00     MOVLW 0x0
12D74  22DD     ADDWFC 0xFDD, F, ACCESS
1152:                      cp = va_arg(ap, char *);
12D76  0EDA     MOVLW 0xDA
12D7A  FF8F     NOP
12D7C  FFD9     NOP
12D7E  0EDB     MOVLW 0xDB
12D82  FF8F     NOP
12D84  FFDA     NOP
12D86  0E02     MOVLW 0x2
12D88  5EDE     SUBWF 0xFDE, F, ACCESS
12D8A  0E00     MOVLW 0x0
12D8C  5ADD     SUBWFB 0xFDD, F, ACCESS
12D90  FF78     NOP
12D92  F00B     NOP
12D96  FF74     NOP
12D98  F00C     NOP
12D9C  F02F     NOP
12D9E  FFD9     NOP
12DA2  F033     NOP
12DA4  FFDA     NOP
12DA8  FF78     NOP
12DAA  F00B     NOP
12DAE  FF74     NOP
12DB0  F00C     NOP
12DB2  0EFE     MOVLW 0xFE
12DB6  F033     NOP
12DB8  FFE3     NOP
12DBA  0EFD     MOVLW 0xFD
12DBE  F02F     NOP
12DC0  FFE3     NOP
1153:          
1154:                      return stoa(fp, cp);
12DC2  0EFD     MOVLW 0xFD
12DC6  FF8F     NOP
12DC8  FFE6     NOP
12DCC  FF8F     NOP
12DCE  FFE6     NOP
12DD0  0EDC     MOVLW 0xDC
12DD4  FF8F     NOP
12DD6  FFE6     NOP
12DDA  FF8F     NOP
12DDC  FFE6     NOP
12DDE  EC08     CALL 0x17410, 0
12DE0  F0BA     NOP
12DE2  D2AF     BRA 0x3342
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
1162:          
1163:                      *fmt += CSTRLEN("hhu");
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1165:                                  
1166:                      return utoa(fp, llu);
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
1173:          
1174:                      *fmt += CSTRLEN("hu");
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1176:                                  
1177:                      return utoa(fp, llu);
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
12DE4  0EDC     MOVLW 0xDC
12DE8  FF8F     NOP
12DEA  FFD9     NOP
12DEC  0EDD     MOVLW 0xDD
12DF0  FF8F     NOP
12DF2  FFDA     NOP
12DF6  FF7B     NOP
12DF8  FFF6     NOP
12DFC  FF77     NOP
12DFE  FFF7     NOP
12E00  0E00     MOVLW 0x0
12E02  6EF8     MOVWF 0xFF8, ACCESS
12E04  0008     TBLRD*
12E06  50F5     MOVF 0xFF5, W, ACCESS
12E08  0A75     XORLW 0x75
12E0A  A4D8     BTFSS 0xFD8, 2, ACCESS
12E0C  D07C     BRA 0x2F06
1183:          
1184:                      ++*fmt;
12E0E  0EDC     MOVLW 0xDC
12E12  FF8F     NOP
12E14  FFD9     NOP
12E16  0EDD     MOVLW 0xDD
12E1A  FF8F     NOP
12E1C  FFDA     NOP
12E1E  2ADE     INCF 0xFDE, F, ACCESS
12E20  0E00     MOVLW 0x0
12E22  22DD     ADDWFC 0xFDD, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
12E24  0EDA     MOVLW 0xDA
12E28  FF8F     NOP
12E2A  FFD9     NOP
12E2C  0EDB     MOVLW 0xDB
12E30  FF8F     NOP
12E32  FFDA     NOP
12E34  0E02     MOVLW 0x2
12E36  5EDE     SUBWF 0xFDE, F, ACCESS
12E38  0E00     MOVLW 0x0
12E3A  5ADD     SUBWFB 0xFDD, F, ACCESS
12E3E  FF78     NOP
12E40  F00B     NOP
12E44  FF74     NOP
12E46  F00C     NOP
12E4A  F02F     NOP
12E4C  FFD9     NOP
12E50  F033     NOP
12E52  FFDA     NOP
12E56  FF78     NOP
12E58  F00B     NOP
12E5C  FF74     NOP
12E5E  F00C     NOP
12E60  500B     MOVF wtemp5, W, ACCESS
12E62  6E11     MOVWF lltemp2, ACCESS
12E64  500C     MOVF 0xC, W, ACCESS
12E66  6E12     MOVWF 0x12, ACCESS
12E68  6A13     CLRF 0x13, ACCESS
12E6A  6A14     CLRF 0x14, ACCESS
12E6C  6A15     CLRF 0x15, ACCESS
12E6E  6A16     CLRF 0x16, ACCESS
12E70  6A17     CLRF 0x17, ACCESS
12E72  6A18     CLRF 0x18, ACCESS
12E74  0EE6     MOVLW 0xE6
12E78  F047     NOP
12E7A  FFE3     NOP
12E7C  0EE7     MOVLW 0xE7
12E80  F04B     NOP
12E82  FFE3     NOP
12E84  0EE8     MOVLW 0xE8
12E88  F04F     NOP
12E8A  FFE3     NOP
12E8C  0EE9     MOVLW 0xE9
12E90  F053     NOP
12E92  FFE3     NOP
12E94  0EEA     MOVLW 0xEA
12E98  F057     NOP
12E9A  FFE3     NOP
12E9C  0EEB     MOVLW 0xEB
12EA0  F05B     NOP
12EA2  FFE3     NOP
12EA4  0EEC     MOVLW 0xEC
12EA8  F05F     NOP
12EAA  FFE3     NOP
12EAC  0EED     MOVLW 0xED
12EB0  F063     NOP
12EB2  FFE3     NOP
1186:                                  
1187:                      return utoa(fp, llu);
12EB4  50E1     MOVF 0xFE1, W, ACCESS
12EB6  0FE6     ADDLW 0xE6
12EB8  6ED9     MOVWF 0xFD9, ACCESS
12EBA  50E2     MOVF 0xFE2, W, ACCESS
12EBC  6EDA     MOVWF 0xFDA, ACCESS
12EBE  0EFF     MOVLW 0xFF
12EC0  22DA     ADDWFC 0xFDA, F, ACCESS
12EC4  FF7B     NOP
12EC6  FFE6     NOP
12ECA  FF7B     NOP
12ECC  FFE6     NOP
12ED0  FF7B     NOP
12ED2  FFE6     NOP
12ED6  FF7B     NOP
12ED8  FFE6     NOP
12EDC  FF7B     NOP
12EDE  FFE6     NOP
12EE2  FF7B     NOP
12EE4  FFE6     NOP
12EE8  FF7B     NOP
12EEA  FFE6     NOP
12EEE  FF7B     NOP
12EF0  FFE6     NOP
12EF2  0ED6     MOVLW 0xD6
12EF6  FF8F     NOP
12EF8  FFE6     NOP
12EFC  FF8F     NOP
12EFE  FFE6     NOP
12F00  ECF4     CALL 0x167E8, 0
12F02  F0B3     NOP
12F04  D21E     BRA 0x3342
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
12F06  0E02     MOVLW 0x2
12F08  6EE6     MOVWF 0xFE6, ACCESS
12F0A  0E00     MOVLW 0x0
12F0C  6EE6     MOVWF 0xFE6, ACCESS
12F0E  0EF3     MOVLW 0xF3
12F10  6EE6     MOVWF 0xFE6, ACCESS
12F12  0EFF     MOVLW 0xFF
12F14  6EE6     MOVWF 0xFE6, ACCESS
12F16  0ED8     MOVLW 0xD8
12F1A  FF8F     NOP
12F1C  FFD9     NOP
12F1E  0ED9     MOVLW 0xD9
12F22  FF8F     NOP
12F24  FFDA     NOP
12F28  FF78     NOP
12F2A  F00B     NOP
12F2E  FF74     NOP
12F30  F00C     NOP
12F34  F02F     NOP
12F36  FFE6     NOP
12F3A  F033     NOP
12F3C  FFE6     NOP
12F3E  EC24     CALL 0x18048, 0
12F40  F0C0     NOP
12F42  5001     MOVF ltemp0, W, ACCESS
12F44  1002     IORWF ttemp5, W, ACCESS
12F46  A4D8     BTFSS 0xFD8, 2, ACCESS
12F48  D039     BRA 0x2FBC
1193:          
1194:                      *fmt += CSTRLEN("lu");
12F4A  0EDC     MOVLW 0xDC
12F4E  FF8F     NOP
12F50  FFD9     NOP
12F52  0EDD     MOVLW 0xDD
12F56  FF8F     NOP
12F58  FFDA     NOP
12F5A  0E02     MOVLW 0x2
12F5C  26DE     ADDWF 0xFDE, F, ACCESS
12F5E  0E00     MOVLW 0x0
12F60  22DD     ADDWFC 0xFDD, F, ACCESS
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
12F62  0EDA     MOVLW 0xDA
12F66  FF8F     NOP
12F68  FFD9     NOP
12F6A  0EDB     MOVLW 0xDB
12F6E  FF8F     NOP
12F70  FFDA     NOP
12F72  0E04     MOVLW 0x4
12F74  5EDE     SUBWF 0xFDE, F, ACCESS
12F76  0E00     MOVLW 0x0
12F78  5ADD     SUBWFB 0xFDD, F, ACCESS
12F7C  FF78     NOP
12F7E  F00B     NOP
12F82  FF74     NOP
12F84  F00C     NOP
12F88  F02F     NOP
12F8A  FFD9     NOP
12F8E  F033     NOP
12F90  FFDA     NOP
12F94  FF78     NOP
12F96  F009     NOP
12F9A  FF78     NOP
12F9C  F00A     NOP
12FA0  FF78     NOP
12FA2  F00B     NOP
12FA6  FF78     NOP
12FA8  F00C     NOP
12FAA  5009     MOVF ltemp2, W, ACCESS
12FAC  6E11     MOVWF lltemp2, ACCESS
12FAE  500A     MOVF ttemp3, W, ACCESS
12FB0  6E12     MOVWF 0x12, ACCESS
12FB2  500B     MOVF wtemp5, W, ACCESS
12FB4  6E13     MOVWF 0x13, ACCESS
12FB6  500C     MOVF 0xC, W, ACCESS
12FB8  6E14     MOVWF 0x14, ACCESS
12FBA  D758     BRA 0x2E6C
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
1237:          
1238:                      *fmt += CSTRLEN("zu");
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
1240:                                  
1241:                      return utoa(fp, llu);
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
1253:                      *fmt += CSTRLEN("hhx");
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
1255:                                  
1256:                      return xtoa(fp, llu, c);
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
1266:                      *fmt += CSTRLEN("hx");
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
1268:                                  
1269:                      return xtoa(fp, llu, c);
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
12FBC  0EDC     MOVLW 0xDC
12FC0  FF8F     NOP
12FC2  FFD9     NOP
12FC4  0EDD     MOVLW 0xDD
12FC8  FF8F     NOP
12FCA  FFDA     NOP
12FCE  FF7B     NOP
12FD0  FFF6     NOP
12FD4  FF77     NOP
12FD6  FFF7     NOP
12FD8  0E00     MOVLW 0x0
12FDA  6EF8     MOVWF 0xFF8, ACCESS
12FDC  0008     TBLRD*
12FDE  50F5     MOVF 0xFF5, W, ACCESS
12FE0  0A78     XORLW 0x78
12FE2  B4D8     BTFSC 0xFD8, 2, ACCESS
12FE4  D015     BRA 0x3010
12FE6  0EDC     MOVLW 0xDC
12FEA  FF8F     NOP
12FEC  FFD9     NOP
12FEE  0EDD     MOVLW 0xDD
12FF2  FF8F     NOP
12FF4  FFDA     NOP
12FF8  FF7B     NOP
12FFA  FFF6     NOP
12FFE  FF77     NOP
13000  FFF7     NOP
13002  0E00     MOVLW 0x0
13004  6EF8     MOVWF 0xFF8, ACCESS
13006  0008     TBLRD*
13008  50F5     MOVF 0xFF5, W, ACCESS
1300A  0A58     XORLW 0x58
1300C  A4D8     BTFSS 0xFD8, 2, ACCESS
1300E  D094     BRA 0x3138
1275:          
1276:                      c = (*fmt)[0];
13010  0EDC     MOVLW 0xDC
13014  FF8F     NOP
13016  FFD9     NOP
13018  0EDD     MOVLW 0xDD
1301C  FF8F     NOP
1301E  FFDA     NOP
13022  FF7B     NOP
13024  FFF6     NOP
13028  FF77     NOP
1302A  FFF7     NOP
1302C  0E00     MOVLW 0x0
1302E  6EF8     MOVWF 0xFF8, ACCESS
13030  0008     TBLRD*
13032  0EFF     MOVLW 0xFF
13036  FFD7     NOP
13038  FFE3     NOP
1277:                      ++*fmt;
1303A  0EDC     MOVLW 0xDC
1303E  FF8F     NOP
13040  FFD9     NOP
13042  0EDD     MOVLW 0xDD
13046  FF8F     NOP
13048  FFDA     NOP
1304A  2ADE     INCF 0xFDE, F, ACCESS
1304C  0E00     MOVLW 0x0
1304E  22DD     ADDWFC 0xFDD, F, ACCESS
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
13050  0EDA     MOVLW 0xDA
13054  FF8F     NOP
13056  FFD9     NOP
13058  0EDB     MOVLW 0xDB
1305C  FF8F     NOP
1305E  FFDA     NOP
13060  0E02     MOVLW 0x2
13062  5EDE     SUBWF 0xFDE, F, ACCESS
13064  0E00     MOVLW 0x0
13066  5ADD     SUBWFB 0xFDD, F, ACCESS
1306A  FF78     NOP
1306C  F00B     NOP
13070  FF74     NOP
13072  F00C     NOP
13076  F02F     NOP
13078  FFD9     NOP
1307C  F033     NOP
1307E  FFDA     NOP
13082  FF78     NOP
13084  F00B     NOP
13088  FF74     NOP
1308A  F00C     NOP
1308C  500B     MOVF wtemp5, W, ACCESS
1308E  6E11     MOVWF lltemp2, ACCESS
13090  500C     MOVF 0xC, W, ACCESS
13092  6E12     MOVWF 0x12, ACCESS
13094  6A13     CLRF 0x13, ACCESS
13096  6A14     CLRF 0x14, ACCESS
13098  6A15     CLRF 0x15, ACCESS
1309A  6A16     CLRF 0x16, ACCESS
1309C  6A17     CLRF 0x17, ACCESS
1309E  6A18     CLRF 0x18, ACCESS
130A0  0EE6     MOVLW 0xE6
130A4  F047     NOP
130A6  FFE3     NOP
130A8  0EE7     MOVLW 0xE7
130AC  F04B     NOP
130AE  FFE3     NOP
130B0  0EE8     MOVLW 0xE8
130B4  F04F     NOP
130B6  FFE3     NOP
130B8  0EE9     MOVLW 0xE9
130BC  F053     NOP
130BE  FFE3     NOP
130C0  0EEA     MOVLW 0xEA
130C4  F057     NOP
130C6  FFE3     NOP
130C8  0EEB     MOVLW 0xEB
130CC  F05B     NOP
130CE  FFE3     NOP
130D0  0EEC     MOVLW 0xEC
130D4  F05F     NOP
130D6  FFE3     NOP
130D8  0EED     MOVLW 0xED
130DC  F063     NOP
130DE  FFE3     NOP
1279:                                  
1280:                      return xtoa(fp, llu, c);
130E0  0EFF     MOVLW 0xFF
130E2  50E3     MOVF 0xFE3, W, ACCESS
130E4  6EE6     MOVWF 0xFE6, ACCESS
130E6  50E1     MOVF 0xFE1, W, ACCESS
130E8  0FE5     ADDLW 0xE5
130EA  6ED9     MOVWF 0xFD9, ACCESS
130EC  50E2     MOVF 0xFE2, W, ACCESS
130EE  6EDA     MOVWF 0xFDA, ACCESS
130F0  0EFF     MOVLW 0xFF
130F2  22DA     ADDWFC 0xFDA, F, ACCESS
130F6  FF7B     NOP
130F8  FFE6     NOP
130FC  FF7B     NOP
130FE  FFE6     NOP
13102  FF7B     NOP
13104  FFE6     NOP
13108  FF7B     NOP
1310A  FFE6     NOP
1310E  FF7B     NOP
13110  FFE6     NOP
13114  FF7B     NOP
13116  FFE6     NOP
1311A  FF7B     NOP
1311C  FFE6     NOP
13120  FF7B     NOP
13122  FFE6     NOP
13124  0ED5     MOVLW 0xD5
13128  FF8F     NOP
1312A  FFE6     NOP
1312E  FF8F     NOP
13130  FFE6     NOP
13132  EC61     CALL 0x160C2, 0
13134  F0B0     NOP
13136  D105     BRA 0x3342
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
13138  0E02     MOVLW 0x2
1313A  6EE6     MOVWF 0xFE6, ACCESS
1313C  0E00     MOVLW 0x0
1313E  6EE6     MOVWF 0xFE6, ACCESS
13140  0EF6     MOVLW 0xF6
13142  6EE6     MOVWF 0xFE6, ACCESS
13144  0EFF     MOVLW 0xFF
13146  6EE6     MOVWF 0xFE6, ACCESS
13148  0ED8     MOVLW 0xD8
1314C  FF8F     NOP
1314E  FFD9     NOP
13150  0ED9     MOVLW 0xD9
13154  FF8F     NOP
13156  FFDA     NOP
1315A  FF78     NOP
1315C  F00B     NOP
13160  FF74     NOP
13162  F00C     NOP
13166  F02F     NOP
13168  FFE6     NOP
1316C  F033     NOP
1316E  FFE6     NOP
13170  EC24     CALL 0x18048, 0
13172  F0C0     NOP
13174  5001     MOVF ltemp0, W, ACCESS
13176  1002     IORWF ttemp5, W, ACCESS
13178  B4D8     BTFSC 0xFD8, 2, ACCESS
1317A  D022     BRA 0x31C0
1317C  0E02     MOVLW 0x2
1317E  6EE6     MOVWF 0xFE6, ACCESS
13180  0E00     MOVLW 0x0
13182  6EE6     MOVWF 0xFE6, ACCESS
13184  0EE7     MOVLW 0xE7
13186  6EE6     MOVWF 0xFE6, ACCESS
13188  0EFF     MOVLW 0xFF
1318A  6EE6     MOVWF 0xFE6, ACCESS
1318C  0ED8     MOVLW 0xD8
13190  FF8F     NOP
13192  FFD9     NOP
13194  0ED9     MOVLW 0xD9
13198  FF8F     NOP
1319A  FFDA     NOP
1319E  FF78     NOP
131A0  F00B     NOP
131A4  FF74     NOP
131A6  F00C     NOP
131AA  F02F     NOP
131AC  FFE6     NOP
131B0  F033     NOP
131B2  FFE6     NOP
131B4  EC24     CALL 0x18048, 0
131B6  F0C0     NOP
131B8  5001     MOVF ltemp0, W, ACCESS
131BA  1002     IORWF ttemp5, W, ACCESS
131BC  A4D8     BTFSS 0xFD8, 2, ACCESS
131BE  D058     BRA 0x3270
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
131C0  0EDC     MOVLW 0xDC
131C4  FF8F     NOP
131C6  FFD9     NOP
131C8  0EDD     MOVLW 0xDD
131CC  FF8F     NOP
131CE  FFDA     NOP
131D2  FF78     NOP
131D4  F00B     NOP
131D8  FF74     NOP
131DA  F00C     NOP
131DC  0E01     MOVLW 0x1
131DE  260B     ADDWF wtemp5, F, ACCESS
131E0  0E00     MOVLW 0x0
131E2  220C     ADDWFC 0xC, F, ACCESS
131E6  F02F     NOP
131E8  FFF6     NOP
131EC  F033     NOP
131EE  FFF7     NOP
131F0  0E00     MOVLW 0x0
131F2  6EF8     MOVWF 0xFF8, ACCESS
131F4  0008     TBLRD*
131F6  0EFF     MOVLW 0xFF
131FA  FFD7     NOP
131FC  FFE3     NOP
1289:                      *fmt += CSTRLEN("lx");
131FE  0EDC     MOVLW 0xDC
13202  FF8F     NOP
13204  FFD9     NOP
13206  0EDD     MOVLW 0xDD
1320A  FF8F     NOP
1320C  FFDA     NOP
1320E  0E02     MOVLW 0x2
13210  26DE     ADDWF 0xFDE, F, ACCESS
13212  0E00     MOVLW 0x0
13214  22DD     ADDWFC 0xFDD, F, ACCESS
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
13216  0EDA     MOVLW 0xDA
1321A  FF8F     NOP
1321C  FFD9     NOP
1321E  0EDB     MOVLW 0xDB
13222  FF8F     NOP
13224  FFDA     NOP
13226  0E04     MOVLW 0x4
13228  5EDE     SUBWF 0xFDE, F, ACCESS
1322A  0E00     MOVLW 0x0
1322C  5ADD     SUBWFB 0xFDD, F, ACCESS
13230  FF78     NOP
13232  F00B     NOP
13236  FF74     NOP
13238  F00C     NOP
1323C  F02F     NOP
1323E  FFD9     NOP
13242  F033     NOP
13244  FFDA     NOP
13248  FF78     NOP
1324A  F009     NOP
1324E  FF78     NOP
13250  F00A     NOP
13254  FF78     NOP
13256  F00B     NOP
1325A  FF78     NOP
1325C  F00C     NOP
1325E  5009     MOVF ltemp2, W, ACCESS
13260  6E11     MOVWF lltemp2, ACCESS
13262  500A     MOVF ttemp3, W, ACCESS
13264  6E12     MOVWF 0x12, ACCESS
13266  500B     MOVF wtemp5, W, ACCESS
13268  6E13     MOVWF 0x13, ACCESS
1326A  500C     MOVF 0xC, W, ACCESS
1326C  6E14     MOVWF 0x14, ACCESS
1326E  D714     BRA 0x3098
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
1341:                      *fmt += CSTRLEN("zx");
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
1343:                                  
1344:                      return xtoa(fp, llu, c);
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
13270  0EDC     MOVLW 0xDC
13274  FF8F     NOP
13276  FFD9     NOP
13278  0EDD     MOVLW 0xDD
1327C  FF8F     NOP
1327E  FFDA     NOP
13282  FF7B     NOP
13284  FFF6     NOP
13288  FF77     NOP
1328A  FFF7     NOP
1328C  0E00     MOVLW 0x0
1328E  6EF8     MOVWF 0xFF8, ACCESS
13290  0008     TBLRD*
13292  50F5     MOVF 0xFF5, W, ACCESS
13294  0A25     XORLW 0x25
13296  A4D8     BTFSS 0xFD8, 2, ACCESS
13298  D01A     BRA 0x32CE
1351:                      ++*fmt;
1329A  0EDC     MOVLW 0xDC
1329E  FF8F     NOP
132A0  FFD9     NOP
132A2  0EDD     MOVLW 0xDD
132A6  FF8F     NOP
132A8  FFDA     NOP
132AA  2ADE     INCF 0xFDE, F, ACCESS
132AC  0E00     MOVLW 0x0
132AE  22DD     ADDWFC 0xFDD, F, ACCESS
1352:                      fputc((int)'%', fp);
132B0  0EDE     MOVLW 0xDE
132B4  FF8F     NOP
132B6  FFE6     NOP
132BA  FF8F     NOP
132BC  FFE6     NOP
132BE  0E25     MOVLW 0x25
132C0  6EE6     MOVWF 0xFE6, ACCESS
132C2  0E00     MOVLW 0x0
132C4  6EE6     MOVWF 0xFE6, ACCESS
132C6  ECD0     CALL 0x197A0, 0
132C8  F0CB     NOP
1353:                      return 1;
132CA  0E01     MOVLW 0x1
132CC  D00C     BRA 0x32E6
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
132CE  0EDC     MOVLW 0xDC
132D2  FF8F     NOP
132D4  FFD9     NOP
132D6  0EDD     MOVLW 0xDD
132DA  FF8F     NOP
132DC  FFDA     NOP
132DE  2ADE     INCF 0xFDE, F, ACCESS
132E0  0E00     MOVLW 0x0
132E2  22DD     ADDWFC 0xFDD, F, ACCESS
1358:                  return 0;
132E4  0E00     MOVLW 0x0
132E6  6E01     MOVWF ltemp0, ACCESS
132E8  0E00     MOVLW 0x0
132EA  6E02     MOVWF ttemp5, ACCESS
132EC  D02A     BRA 0x3342
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
132EE  0EDE     MOVLW 0xDE
132F2  FF8F     NOP
132F4  FFE6     NOP
132F8  FF8F     NOP
132FA  FFE6     NOP
132FC  0EDA     MOVLW 0xDA
13300  FF8F     NOP
13302  FFD9     NOP
13304  0EDB     MOVLW 0xDB
13308  FF8F     NOP
1330A  FFDA     NOP
1330E  FF7B     NOP
13310  FFF6     NOP
13314  FF77     NOP
13316  FFF7     NOP
13318  0E00     MOVLW 0x0
1331A  6EF8     MOVWF 0xFF8, ACCESS
1331C  0008     TBLRD*
1331E  50F5     MOVF 0xFF5, W, ACCESS
13320  6EE6     MOVWF 0xFE6, ACCESS
13322  0E00     MOVLW 0x0
13324  6EE6     MOVWF 0xFE6, ACCESS
13326  ECD0     CALL 0x197A0, 0
13328  F0CB     NOP
1363:              ++*fmt;
1332A  0EDC     MOVLW 0xDC
1332E  FF8F     NOP
13330  FFD9     NOP
13332  0EDD     MOVLW 0xDD
13336  FF8F     NOP
13338  FFDA     NOP
1333A  2ADE     INCF 0xFDE, F, ACCESS
1333C  0E00     MOVLW 0x0
1333E  22DD     ADDWFC 0xFDD, F, ACCESS
13340  D7C4     BRA 0x32CA
1364:              return 1;
1365:          }
13342  0EDA     MOVLW 0xDA
13344  26E1     ADDWF 0xFE1, F, ACCESS
13346  0EFF     MOVLW 0xFF
13348  22E2     ADDWFC 0xFE2, F, ACCESS
1334A  0012     RETURN 0
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1A63A  52E6     MOVF 0xFE6, F, ACCESS
1A63C  52E6     MOVF 0xFE6, F, ACCESS
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
1A63E  0EFA     MOVLW 0xFA
1A642  FF8C     NOP
1A644  F00B     NOP
1A646  0EFB     MOVLW 0xFB
1A64A  FF8C     NOP
1A64C  F00C     NOP
1A64E  0EFF     MOVLW 0xFF
1A652  F033     NOP
1A654  FFE3     NOP
1A656  0EFE     MOVLW 0xFE
1A65A  F02F     NOP
1A65C  FFE3     NOP
1374:              nout = 0;
1A65E  0100     MOVLB 0x0
1A660  6BC0     CLRF nout, BANKED
1A662  6BC1     CLRF 0xC1, BANKED
1375:              while (*cfmt) {
1A664  D021     BRA 0xA6A8
1A6A8  50E1     MOVF 0xFE1, W, ACCESS
1A6AA  0FFE     ADDLW 0xFE
1A6AC  6ED9     MOVWF 0xFD9, ACCESS
1A6AE  50E2     MOVF 0xFE2, W, ACCESS
1A6B0  6EDA     MOVWF 0xFDA, ACCESS
1A6B2  0EFF     MOVLW 0xFF
1A6B4  22DA     ADDWFC 0xFDA, F, ACCESS
1A6B8  FF7B     NOP
1A6BA  FFF6     NOP
1A6BE  FF77     NOP
1A6C0  FFF7     NOP
1A6C2  0E00     MOVLW 0x0
1A6C4  6EF8     MOVWF 0xFF8, ACCESS
1A6C6  0008     TBLRD*
1A6C8  50F5     MOVF 0xFF5, W, ACCESS
1A6CA  0900     IORLW 0x0
1A6CC  A4D8     BTFSS 0xFD8, 2, ACCESS
1A6CE  D7CB     BRA 0xA666
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
1A666  0EF8     MOVLW 0xF8
1A66A  FF8F     NOP
1A66C  FFE6     NOP
1A670  FF8F     NOP
1A672  FFE6     NOP
1A674  0EFC     MOVLW 0xFC
1A676  24E1     ADDWF 0xFE1, W, ACCESS
1A678  6E01     MOVWF ltemp0, ACCESS
1A67A  0EFF     MOVLW 0xFF
1A67C  20E2     ADDWFC 0xFE2, W, ACCESS
1A67E  6E02     MOVWF ttemp5, ACCESS
1A682  F007     NOP
1A684  FFE6     NOP
1A688  F00B     NOP
1A68A  FFE6     NOP
1A68C  0EF8     MOVLW 0xF8
1A690  FF8F     NOP
1A692  FFE6     NOP
1A696  FF8F     NOP
1A698  FFE6     NOP
1A69A  ECD0     CALL 0x123A0, 0
1A69C  F091     NOP
1A69E  5001     MOVF ltemp0, W, ACCESS
1A6A0  0100     MOVLB 0x0
1A6A2  27C0     ADDWF nout, F, BANKED
1A6A4  5002     MOVF ttemp5, W, ACCESS
1A6A6  23C1     ADDWFC 0xC1, F, BANKED
1377:              }
1378:              return nout;
1A6D2  F300     NOP
1A6D4  F001     NOP
1A6D8  F304     NOP
1A6DA  F002     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
1A6DC  0EF8     MOVLW 0xF8
1A6DE  26E1     ADDWF 0xFE1, F, ACCESS
1A6E0  0EFF     MOVLW 0xFF
1A6E2  22E2     ADDWFC 0xFE2, F, ACCESS
1A6E4  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/awmod.c  -------------------------------------------
1:             // integer signed unsigned modulus
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awmod(signed int divisor, signed int dividend)
6:             #else
7:             __awmod(signed int dividend, signed int divisor)
198C4  52E6     MOVF 0xFE6, F, ACCESS
198C6  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	unsigned char	counter, sign;
11:            
12:            	sign = 0;
198C8  0EFE     MOVLW 0xFE
198CA  6AE3     CLRF 0xFE3, ACCESS
13:            	if(dividend < 0) {
198CC  0EFD     MOVLW 0xFD
198CE  AEE3     BTFSS 0xFE3, 7, ACCESS
198D0  D009     BRA 0x98E4
14:            		dividend = -dividend;
198D2  0EFC     MOVLW 0xFC
198D4  6CE3     NEGF 0xFE3, ACCESS
198D6  0EFD     MOVLW 0xFD
198D8  1EE3     COMF 0xFE3, F, ACCESS
198DA  B0D8     BTFSC 0xFD8, 0, ACCESS
198DC  2AE3     INCF 0xFE3, F, ACCESS
15:            		sign = 1;
198DE  0EFE     MOVLW 0xFE
198E0  6AE3     CLRF 0xFE3, ACCESS
198E2  2AE3     INCF 0xFE3, F, ACCESS
16:            	}
17:            	if(divisor < 0)
198E4  0EFB     MOVLW 0xFB
198E6  AEE3     BTFSS 0xFE3, 7, ACCESS
198E8  D006     BRA 0x98F6
18:            		divisor = -divisor;
198EA  0EFA     MOVLW 0xFA
198EC  6CE3     NEGF 0xFE3, ACCESS
198EE  0EFB     MOVLW 0xFB
198F0  1EE3     COMF 0xFE3, F, ACCESS
198F2  B0D8     BTFSC 0xFD8, 0, ACCESS
198F4  2AE3     INCF 0xFE3, F, ACCESS
19:            	if(divisor != 0) {
198F6  0EFA     MOVLW 0xFA
198FA  FF8C     NOP
198FC  F001     NOP
198FE  0EFB     MOVLW 0xFB
19900  50E3     MOVF 0xFE3, W, ACCESS
19902  1001     IORWF ltemp0, W, ACCESS
19904  B4D8     BTFSC 0xFD8, 2, ACCESS
19906  D053     BRA 0x99AE
20:            		counter = 1;
19908  0EFF     MOVLW 0xFF
1990A  6AE3     CLRF 0xFE3, ACCESS
1990C  D012     BRA 0x9932
21:            		while(((unsigned int)divisor & 0x8000U) == 0) {
19934  0EFB     MOVLW 0xFB
19936  AEE3     BTFSS 0xFE3, 7, ACCESS
19938  D7EA     BRA 0x990E
22:            			divisor <<= 1;
1990E  0EFA     MOVLW 0xFA
19910  50E3     MOVF 0xFE3, W, ACCESS
19912  90D8     BCF 0xFD8, 0, ACCESS
19914  34E8     RLCF 0xFE8, W, ACCESS
19916  6E01     MOVWF ltemp0, ACCESS
19918  0EFA     MOVLW 0xFA
1991C  F007     NOP
1991E  FFE3     NOP
19920  0EFB     MOVLW 0xFB
19922  50E3     MOVF 0xFE3, W, ACCESS
19924  34E8     RLCF 0xFE8, W, ACCESS
19926  6E01     MOVWF ltemp0, ACCESS
19928  0EFB     MOVLW 0xFB
1992C  F007     NOP
1992E  FFE3     NOP
23:            			counter++;
19930  0EFF     MOVLW 0xFF
19932  2AE3     INCF 0xFE3, F, ACCESS
24:            		}
25:            		do {
26:            			if((unsigned int)divisor <= (unsigned int)dividend)
1993A  0EFA     MOVLW 0xFA
1993E  FF8C     NOP
19940  F00B     NOP
19942  0EFB     MOVLW 0xFB
19946  FF8C     NOP
19948  F00C     NOP
1994A  0EFC     MOVLW 0xFC
1994E  FF8C     NOP
19950  F009     NOP
19952  0EFD     MOVLW 0xFD
19956  FF8C     NOP
19958  F00A     NOP
1995A  500B     MOVF wtemp5, W, ACCESS
1995C  5C09     SUBWF ltemp2, W, ACCESS
1995E  500C     MOVF 0xC, W, ACCESS
19960  580A     SUBWFB ttemp3, W, ACCESS
19962  A0D8     BTFSS 0xFD8, 0, ACCESS
19964  D014     BRA 0x998E
27:            				dividend -= divisor;
19966  0EFC     MOVLW 0xFC
19968  50E3     MOVF 0xFE3, W, ACCESS
1996A  6E01     MOVWF ltemp0, ACCESS
1996C  0EFA     MOVLW 0xFA
1996E  50E3     MOVF 0xFE3, W, ACCESS
19970  5E01     SUBWF ltemp0, F, ACCESS
19972  0EFC     MOVLW 0xFC
19976  F007     NOP
19978  FFE3     NOP
1997A  0EFD     MOVLW 0xFD
1997C  50E3     MOVF 0xFE3, W, ACCESS
1997E  6E01     MOVWF ltemp0, ACCESS
19980  0EFB     MOVLW 0xFB
19982  50E3     MOVF 0xFE3, W, ACCESS
19984  5A01     SUBWFB ltemp0, F, ACCESS
19986  0EFD     MOVLW 0xFD
1998A  F007     NOP
1998C  FFE3     NOP
28:            			*(unsigned int *)&divisor >>= 1;
1998E  90D8     BCF 0xFD8, 0, ACCESS
19990  0EFB     MOVLW 0xFB
19992  32E3     RRCF 0xFE3, F, ACCESS
19994  0EFA     MOVLW 0xFA
19996  32E3     RRCF 0xFE3, F, ACCESS
29:            		} while(--counter != 0);
19998  0EFF     MOVLW 0xFF
1999A  50E3     MOVF 0xFE3, W, ACCESS
1999C  6E01     MOVWF ltemp0, ACCESS
1999E  0E01     MOVLW 0x1
199A0  5E01     SUBWF ltemp0, F, ACCESS
199A2  0EFF     MOVLW 0xFF
199A6  F007     NOP
199A8  FFE3     NOP
199AA  A4D8     BTFSS 0xFD8, 2, ACCESS
199AC  D7C6     BRA 0x993A
30:            	}
31:            	if(sign)
199AE  0EFE     MOVLW 0xFE
199B0  50E3     MOVF 0xFE3, W, ACCESS
199B2  B4D8     BTFSC 0xFD8, 2, ACCESS
199B4  D006     BRA 0x99C2
32:            		dividend = -dividend;
199B6  0EFC     MOVLW 0xFC
199B8  6CE3     NEGF 0xFE3, ACCESS
199BA  0EFD     MOVLW 0xFD
199BC  1EE3     COMF 0xFE3, F, ACCESS
199BE  B0D8     BTFSC 0xFD8, 0, ACCESS
199C0  2AE3     INCF 0xFE3, F, ACCESS
33:            	return dividend;
199C2  0EFC     MOVLW 0xFC
199C6  FF8C     NOP
199C8  F001     NOP
199CA  0EFD     MOVLW 0xFD
199CE  FF8C     NOP
199D0  F002     NOP
34:            }
199D2  0EFA     MOVLW 0xFA
199D4  26E1     ADDWF 0xFE1, F, ACCESS
199D6  0EFF     MOVLW 0xFF
199D8  22E2     ADDWFC 0xFE2, F, ACCESS
199DA  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/awdiv.c  -------------------------------------------
1:             // integer signed division
2:             
3:             signed int
4:             #ifdef __PICC__
5:             __awdiv(signed int divisor, signed int dividend)
6:             #else
7:             __awdiv(signed int dividend, signed int divisor)
192AE  52E6     MOVF 0xFE6, F, ACCESS
192B0  52E6     MOVF 0xFE6, F, ACCESS
192B2  52E6     MOVF 0xFE6, F, ACCESS
192B4  52E6     MOVF 0xFE6, F, ACCESS
8:             #endif
9:             {
10:            	signed int	quotient;
11:            	unsigned char	counter, sign;
12:            
13:            	sign = 0;
192B6  0EFE     MOVLW 0xFE
192B8  6AE3     CLRF 0xFE3, ACCESS
14:            	if(divisor < 0) {
192BA  0EF9     MOVLW 0xF9
192BC  AEE3     BTFSS 0xFE3, 7, ACCESS
192BE  D009     BRA 0x92D2
15:            		divisor = -divisor;
192C0  0EF8     MOVLW 0xF8
192C2  6CE3     NEGF 0xFE3, ACCESS
192C4  0EF9     MOVLW 0xF9
192C6  1EE3     COMF 0xFE3, F, ACCESS
192C8  B0D8     BTFSC 0xFD8, 0, ACCESS
192CA  2AE3     INCF 0xFE3, F, ACCESS
16:            		sign = 1;
192CC  0EFE     MOVLW 0xFE
192CE  6AE3     CLRF 0xFE3, ACCESS
192D0  2AE3     INCF 0xFE3, F, ACCESS
17:            	}
18:            	if(dividend < 0) {
192D2  0EFB     MOVLW 0xFB
192D4  AEE3     BTFSS 0xFE3, 7, ACCESS
192D6  D008     BRA 0x92E8
19:            		dividend = -dividend;
192D8  0EFA     MOVLW 0xFA
192DA  6CE3     NEGF 0xFE3, ACCESS
192DC  0EFB     MOVLW 0xFB
192DE  1EE3     COMF 0xFE3, F, ACCESS
192E0  B0D8     BTFSC 0xFD8, 0, ACCESS
192E2  2AE3     INCF 0xFE3, F, ACCESS
20:            		sign ^= 1;
192E4  0EFE     MOVLW 0xFE
192E6  70E3     BTG 0xFE3, 0, ACCESS
21:            	}
22:            	quotient = 0;
192E8  0EFC     MOVLW 0xFC
192EA  6AE3     CLRF 0xFE3, ACCESS
192EC  0EFD     MOVLW 0xFD
192EE  6AE3     CLRF 0xFE3, ACCESS
23:            	if(divisor != 0) {
192F0  0EF8     MOVLW 0xF8
192F4  FF8C     NOP
192F6  F001     NOP
192F8  0EF9     MOVLW 0xF9
192FA  50E3     MOVF 0xFE3, W, ACCESS
192FC  1001     IORWF ltemp0, W, ACCESS
192FE  B4D8     BTFSC 0xFD8, 2, ACCESS
19300  D066     BRA 0x93CE
24:            		counter = 1;
19302  0EFF     MOVLW 0xFF
19304  6AE3     CLRF 0xFE3, ACCESS
19306  D012     BRA 0x932C
25:            		while((divisor & 0x8000U) == 0) {
1932E  0EF9     MOVLW 0xF9
19330  AEE3     BTFSS 0xFE3, 7, ACCESS
19332  D7EA     BRA 0x9308
26:            			divisor <<= 1;
19308  0EF8     MOVLW 0xF8
1930A  50E3     MOVF 0xFE3, W, ACCESS
1930C  90D8     BCF 0xFD8, 0, ACCESS
1930E  34E8     RLCF 0xFE8, W, ACCESS
19310  6E01     MOVWF ltemp0, ACCESS
19312  0EF8     MOVLW 0xF8
19316  F007     NOP
19318  FFE3     NOP
1931A  0EF9     MOVLW 0xF9
1931C  50E3     MOVF 0xFE3, W, ACCESS
1931E  34E8     RLCF 0xFE8, W, ACCESS
19320  6E01     MOVWF ltemp0, ACCESS
19322  0EF9     MOVLW 0xF9
19326  F007     NOP
19328  FFE3     NOP
27:            			counter++;
1932A  0EFF     MOVLW 0xFF
1932C  2AE3     INCF 0xFE3, F, ACCESS
28:            		}
29:            		do {
30:            			quotient <<= 1;
19334  0EFC     MOVLW 0xFC
19336  50E3     MOVF 0xFE3, W, ACCESS
19338  90D8     BCF 0xFD8, 0, ACCESS
1933A  34E8     RLCF 0xFE8, W, ACCESS
1933C  6E01     MOVWF ltemp0, ACCESS
1933E  0EFC     MOVLW 0xFC
19342  F007     NOP
19344  FFE3     NOP
19346  0EFD     MOVLW 0xFD
19348  50E3     MOVF 0xFE3, W, ACCESS
1934A  34E8     RLCF 0xFE8, W, ACCESS
1934C  6E01     MOVWF ltemp0, ACCESS
1934E  0EFD     MOVLW 0xFD
19352  F007     NOP
19354  FFE3     NOP
31:            			if((unsigned int)divisor <= (unsigned int)dividend) {
19356  0EF8     MOVLW 0xF8
1935A  FF8C     NOP
1935C  F00B     NOP
1935E  0EF9     MOVLW 0xF9
19362  FF8C     NOP
19364  F00C     NOP
19366  0EFA     MOVLW 0xFA
1936A  FF8C     NOP
1936C  F009     NOP
1936E  0EFB     MOVLW 0xFB
19372  FF8C     NOP
19374  F00A     NOP
19376  500B     MOVF wtemp5, W, ACCESS
19378  5C09     SUBWF ltemp2, W, ACCESS
1937A  500C     MOVF 0xC, W, ACCESS
1937C  580A     SUBWFB ttemp3, W, ACCESS
1937E  A0D8     BTFSS 0xFD8, 0, ACCESS
19380  D016     BRA 0x93AE
32:            				dividend -= divisor;
19382  0EFA     MOVLW 0xFA
19384  50E3     MOVF 0xFE3, W, ACCESS
19386  6E01     MOVWF ltemp0, ACCESS
19388  0EF8     MOVLW 0xF8
1938A  50E3     MOVF 0xFE3, W, ACCESS
1938C  5E01     SUBWF ltemp0, F, ACCESS
1938E  0EFA     MOVLW 0xFA
19392  F007     NOP
19394  FFE3     NOP
19396  0EFB     MOVLW 0xFB
19398  50E3     MOVF 0xFE3, W, ACCESS
1939A  6E01     MOVWF ltemp0, ACCESS
1939C  0EF9     MOVLW 0xF9
1939E  50E3     MOVF 0xFE3, W, ACCESS
193A0  5A01     SUBWFB ltemp0, F, ACCESS
193A2  0EFB     MOVLW 0xFB
193A6  F007     NOP
193A8  FFE3     NOP
33:            				quotient |= 1;
193AA  0EFC     MOVLW 0xFC
193AC  80E3     BSF 0xFE3, 0, ACCESS
34:            			}
35:            			*(unsigned int *)&divisor >>= 1;
193AE  90D8     BCF 0xFD8, 0, ACCESS
193B0  0EF9     MOVLW 0xF9
193B2  32E3     RRCF 0xFE3, F, ACCESS
193B4  0EF8     MOVLW 0xF8
193B6  32E3     RRCF 0xFE3, F, ACCESS
36:            		} while(--counter != 0);
193B8  0EFF     MOVLW 0xFF
193BA  50E3     MOVF 0xFE3, W, ACCESS
193BC  6E01     MOVWF ltemp0, ACCESS
193BE  0E01     MOVLW 0x1
193C0  5E01     SUBWF ltemp0, F, ACCESS
193C2  0EFF     MOVLW 0xFF
193C6  F007     NOP
193C8  FFE3     NOP
193CA  A4D8     BTFSS 0xFD8, 2, ACCESS
193CC  D7B3     BRA 0x9334
37:            	}
38:            	if(sign)
193CE  0EFE     MOVLW 0xFE
193D0  50E3     MOVF 0xFE3, W, ACCESS
193D2  B4D8     BTFSC 0xFD8, 2, ACCESS
193D4  D006     BRA 0x93E2
39:            		quotient = -quotient;
193D6  0EFC     MOVLW 0xFC
193D8  6CE3     NEGF 0xFE3, ACCESS
193DA  0EFD     MOVLW 0xFD
193DC  1EE3     COMF 0xFE3, F, ACCESS
193DE  B0D8     BTFSC 0xFD8, 0, ACCESS
193E0  2AE3     INCF 0xFE3, F, ACCESS
40:            	return quotient;
193E2  0EFC     MOVLW 0xFC
193E6  FF8C     NOP
193E8  F001     NOP
193EA  0EFD     MOVLW 0xFD
193EE  FF8C     NOP
193F0  F002     NOP
41:            }
193F2  0EF8     MOVLW 0xF8
193F4  26E1     ADDWF 0xFE1, F, ACCESS
193F6  0EFF     MOVLW 0xFF
193F8  22E2     ADDWFC 0xFE2, F, ACCESS
193FA  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/atoi.c  --------------------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
1794E  0E09     MOVLW 0x9
17950  26E1     ADDWF 0xFE1, F, ACCESS
17952  0E00     MOVLW 0x0
17954  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             	int n=0, neg=0;
17956  0EFC     MOVLW 0xFC
17958  6AE3     CLRF 0xFE3, ACCESS
1795A  0EFD     MOVLW 0xFD
1795C  6AE3     CLRF 0xFE3, ACCESS
1795E  0EFE     MOVLW 0xFE
17960  6AE3     CLRF 0xFE3, ACCESS
17962  0EFF     MOVLW 0xFF
17964  6AE3     CLRF 0xFE3, ACCESS
7:             	while (isspace(*s)) s++;
17966  D011     BRA 0x798A
17968  0EF5     MOVLW 0xF5
1796A  50E3     MOVF 0xFE3, W, ACCESS
1796C  0F01     ADDLW 0x1
1796E  6E01     MOVWF ltemp0, ACCESS
17970  0EF5     MOVLW 0xF5
17974  F007     NOP
17976  FFE3     NOP
17978  6A01     CLRF ltemp0, ACCESS
1797A  0EF6     MOVLW 0xF6
1797C  50E3     MOVF 0xFE3, W, ACCESS
1797E  2001     ADDWFC ltemp0, W, ACCESS
17980  6E01     MOVWF ltemp0, ACCESS
17982  0EF6     MOVLW 0xF6
17986  F007     NOP
17988  FFE3     NOP
1798A  0EFB     MOVLW 0xFB
1798C  6AE3     CLRF 0xFE3, ACCESS
1798E  2AE3     INCF 0xFE3, F, ACCESS
17990  50E1     MOVF 0xFE1, W, ACCESS
17992  0FF5     ADDLW 0xF5
17994  6ED9     MOVWF 0xFD9, ACCESS
17996  50E2     MOVF 0xFE2, W, ACCESS
17998  6EDA     MOVWF 0xFDA, ACCESS
1799A  0EFF     MOVLW 0xFF
1799C  22DA     ADDWFC 0xFDA, F, ACCESS
179A0  FF7B     NOP
179A2  FFF6     NOP
179A6  FF77     NOP
179A8  FFF7     NOP
179AA  0E00     MOVLW 0x0
179AC  6EF8     MOVWF 0xFF8, ACCESS
179AE  0008     TBLRD*
179B0  50F5     MOVF 0xFF5, W, ACCESS
179B2  0A20     XORLW 0x20
179B4  B4D8     BTFSC 0xFD8, 2, ACCESS
179B6  D023     BRA 0x79FE
179B8  0EF7     MOVLW 0xF7
179BA  6E0B     MOVWF wtemp5, ACCESS
179BC  0EFF     MOVLW 0xFF
179BE  6E0C     MOVWF 0xC, ACCESS
179C0  50E1     MOVF 0xFE1, W, ACCESS
179C2  0FF5     ADDLW 0xF5
179C4  6ED9     MOVWF 0xFD9, ACCESS
179C6  50E2     MOVF 0xFE2, W, ACCESS
179C8  6EDA     MOVWF 0xFDA, ACCESS
179CA  0EFF     MOVLW 0xFF
179CC  22DA     ADDWFC 0xFDA, F, ACCESS
179D0  FF7B     NOP
179D2  FFF6     NOP
179D6  FF77     NOP
179D8  FFF7     NOP
179DA  0E00     MOVLW 0x0
179DC  6EF8     MOVWF 0xFF8, ACCESS
179DE  0008     TBLRD*
179E0  50F5     MOVF 0xFF5, W, ACCESS
179E2  6E09     MOVWF ltemp2, ACCESS
179E4  6A0A     CLRF ttemp3, ACCESS
179E6  500B     MOVF wtemp5, W, ACCESS
179E8  2609     ADDWF ltemp2, F, ACCESS
179EA  500C     MOVF 0xC, W, ACCESS
179EC  220A     ADDWFC ttemp3, F, ACCESS
179EE  500A     MOVF ttemp3, W, ACCESS
179F0  E104     BNZ 0x79FA
179F2  0E05     MOVLW 0x5
179F4  5C09     SUBWF ltemp2, W, ACCESS
179F6  A0D8     BTFSS 0xFD8, 0, ACCESS
179F8  D002     BRA 0x79FE
179FA  0EFB     MOVLW 0xFB
179FC  6AE3     CLRF 0xFE3, ACCESS
179FE  0EFB     MOVLW 0xFB
17A00  50E3     MOVF 0xFE3, W, ACCESS
17A02  6E0B     MOVWF wtemp5, ACCESS
17A04  6A0C     CLRF 0xC, ACCESS
17A06  0EF9     MOVLW 0xF9
17A0A  F02F     NOP
17A0C  FFE3     NOP
17A0E  0EFA     MOVLW 0xFA
17A12  F033     NOP
17A14  FFE3     NOP
17A16  0EF9     MOVLW 0xF9
17A1A  FF8C     NOP
17A1C  F001     NOP
17A1E  0EFA     MOVLW 0xFA
17A20  50E3     MOVF 0xFE3, W, ACCESS
17A22  1001     IORWF ltemp0, W, ACCESS
17A24  B4D8     BTFSC 0xFD8, 2, ACCESS
17A26  D01F     BRA 0x7A66
17A28  D79F     BRA 0x7968
8:             	switch (*s) {
9:             	case '-': neg=1;
17A2A  0E01     MOVLW 0x1
17A2C  6E0B     MOVWF wtemp5, ACCESS
17A2E  0E00     MOVLW 0x0
17A30  6E0C     MOVWF 0xC, ACCESS
17A32  0EFE     MOVLW 0xFE
17A36  F02F     NOP
17A38  FFE3     NOP
17A3A  0EFF     MOVLW 0xFF
17A3E  F033     NOP
17A40  FFE3     NOP
10:            	case '+': s++;
17A42  0EF5     MOVLW 0xF5
17A44  50E3     MOVF 0xFE3, W, ACCESS
17A46  0F01     ADDLW 0x1
17A48  6E01     MOVWF ltemp0, ACCESS
17A4A  0EF5     MOVLW 0xF5
17A4E  F007     NOP
17A50  FFE3     NOP
17A52  6A01     CLRF ltemp0, ACCESS
17A54  0EF6     MOVLW 0xF6
17A56  50E3     MOVF 0xFE3, W, ACCESS
17A58  2001     ADDWFC ltemp0, W, ACCESS
17A5A  6E01     MOVWF ltemp0, ACCESS
17A5C  0EF6     MOVLW 0xF6
17A60  F007     NOP
17A62  FFE3     NOP
11:            	}
17A64  D053     BRA 0x7B0C
17A66  50E1     MOVF 0xFE1, W, ACCESS
17A68  0FF5     ADDLW 0xF5
17A6A  6ED9     MOVWF 0xFD9, ACCESS
17A6C  50E2     MOVF 0xFE2, W, ACCESS
17A6E  6EDA     MOVWF 0xFDA, ACCESS
17A70  0EFF     MOVLW 0xFF
17A72  22DA     ADDWFC 0xFDA, F, ACCESS
17A76  FF7B     NOP
17A78  FFF6     NOP
17A7C  FF77     NOP
17A7E  FFF7     NOP
17A80  0E00     MOVLW 0x0
17A82  6EF8     MOVWF 0xFF8, ACCESS
17A84  0008     TBLRD*
17A86  50F5     MOVF 0xFF5, W, ACCESS
17A88  6E0B     MOVWF wtemp5, ACCESS
17A8A  6A0C     CLRF 0xC, ACCESS
17A8C  500C     MOVF 0xC, W, ACCESS
17A8E  0A00     XORLW 0x0
17A90  A4D8     BTFSS 0xFD8, 2, ACCESS
17A92  D03C     BRA 0x7B0C
17A94  500B     MOVF wtemp5, W, ACCESS
17A96  0A2B     XORLW 0x2B
17A98  B4D8     BTFSC 0xFD8, 2, ACCESS
17A9A  D7D3     BRA 0x7A42
17A9C  0A06     XORLW 0x6
17A9E  B4D8     BTFSC 0xFD8, 2, ACCESS
17AA0  D7C4     BRA 0x7A2A
17AA2  D034     BRA 0x7B0C
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
17B0C  0ED0     MOVLW 0xD0
17B0E  6E0B     MOVWF wtemp5, ACCESS
17B10  0EFF     MOVLW 0xFF
17B12  6E0C     MOVWF 0xC, ACCESS
17B14  50E1     MOVF 0xFE1, W, ACCESS
17B16  0FF5     ADDLW 0xF5
17B18  6ED9     MOVWF 0xFD9, ACCESS
17B1A  50E2     MOVF 0xFE2, W, ACCESS
17B1C  6EDA     MOVWF 0xFDA, ACCESS
17B1E  0EFF     MOVLW 0xFF
17B20  22DA     ADDWFC 0xFDA, F, ACCESS
17B24  FF7B     NOP
17B26  FFF6     NOP
17B2A  FF77     NOP
17B2C  FFF7     NOP
17B2E  0E00     MOVLW 0x0
17B30  6EF8     MOVWF 0xFF8, ACCESS
17B32  0008     TBLRD*
17B34  50F5     MOVF 0xFF5, W, ACCESS
17B36  6E09     MOVWF ltemp2, ACCESS
17B38  6A0A     CLRF ttemp3, ACCESS
17B3A  500B     MOVF wtemp5, W, ACCESS
17B3C  2609     ADDWF ltemp2, F, ACCESS
17B3E  500C     MOVF 0xC, W, ACCESS
17B40  220A     ADDWFC ttemp3, F, ACCESS
17B42  500A     MOVF ttemp3, W, ACCESS
17B44  E106     BNZ 0x7B52
17B46  0E0A     MOVLW 0xA
17B48  5C09     SUBWF ltemp2, W, ACCESS
17B4A  B0D8     BTFSC 0xFD8, 0, ACCESS
17B4C  D002     BRA 0x7B52
17B4E  0E01     MOVLW 0x1
17B50  D001     BRA 0x7B54
17B52  0E00     MOVLW 0x0
17B54  6E0B     MOVWF wtemp5, ACCESS
17B56  6A0C     CLRF 0xC, ACCESS
17B58  0EF7     MOVLW 0xF7
17B5C  F02F     NOP
17B5E  FFE3     NOP
17B60  0EF8     MOVLW 0xF8
17B64  F033     NOP
17B66  FFE3     NOP
17B68  0EF7     MOVLW 0xF7
17B6C  FF8C     NOP
17B6E  F001     NOP
17B70  0EF8     MOVLW 0xF8
17B72  50E3     MOVF 0xFE3, W, ACCESS
17B74  1001     IORWF ltemp0, W, ACCESS
17B76  A4D8     BTFSS 0xFD8, 2, ACCESS
17B78  D795     BRA 0x7AA4
14:            		n = 10*n - (*s++ - '0');
17AA4  0EFC     MOVLW 0xFC
17AA8  FF8C     NOP
17AAA  F00B     NOP
17AAC  0EFD     MOVLW 0xFD
17AB0  FF8C     NOP
17AB2  F00C     NOP
17AB4  0E0A     MOVLW 0xA
17AB6  020B     MULWF wtemp5, ACCESS
17ABA  FFCC     NOP
17ABC  F009     NOP
17AC0  FFD0     NOP
17AC2  F00A     NOP
17AC4  020C     MULWF 0xC, ACCESS
17AC6  50F3     MOVF 0xFF3, W, ACCESS
17AC8  260A     ADDWF ttemp3, F, ACCESS
17ACA  50E1     MOVF 0xFE1, W, ACCESS
17ACC  0FF5     ADDLW 0xF5
17ACE  6ED9     MOVWF 0xFD9, ACCESS
17AD0  50E2     MOVF 0xFE2, W, ACCESS
17AD2  6EDA     MOVWF 0xFDA, ACCESS
17AD4  0EFF     MOVLW 0xFF
17AD6  22DA     ADDWFC 0xFDA, F, ACCESS
17ADA  FF7B     NOP
17ADC  FFF6     NOP
17AE0  FF77     NOP
17AE2  FFF7     NOP
17AE4  0E00     MOVLW 0x0
17AE6  6EF8     MOVWF 0xFF8, ACCESS
17AE8  0008     TBLRD*
17AEA  50F5     MOVF 0xFF5, W, ACCESS
17AEC  5E09     SUBWF ltemp2, F, ACCESS
17AEE  0E00     MOVLW 0x0
17AF0  5A0A     SUBWFB ttemp3, F, ACCESS
17AF2  0E30     MOVLW 0x30
17AF4  2609     ADDWF ltemp2, F, ACCESS
17AF6  0E00     MOVLW 0x0
17AF8  220A     ADDWFC ttemp3, F, ACCESS
17AFA  0EFC     MOVLW 0xFC
17AFE  F027     NOP
17B00  FFE3     NOP
17B02  0EFD     MOVLW 0xFD
17B06  F02B     NOP
17B08  FFE3     NOP
17B0A  D79B     BRA 0x7A42
15:            	return neg ? n : -n;
17B7A  0EFE     MOVLW 0xFE
17B7E  FF8C     NOP
17B80  F001     NOP
17B82  0EFF     MOVLW 0xFF
17B84  50E3     MOVF 0xFE3, W, ACCESS
17B86  1001     IORWF ltemp0, W, ACCESS
17B88  A4D8     BTFSS 0xFD8, 2, ACCESS
17B8A  D00E     BRA 0x7BA8
17B8C  0EFC     MOVLW 0xFC
17B90  FF8C     NOP
17B92  F001     NOP
17B94  1E01     COMF ltemp0, F, ACCESS
17B96  0EFD     MOVLW 0xFD
17B9A  FF8C     NOP
17B9C  F002     NOP
17B9E  1E02     COMF ttemp5, F, ACCESS
17BA0  2A01     INCF ltemp0, F, ACCESS
17BA2  B4D8     BTFSC 0xFD8, 2, ACCESS
17BA4  2A02     INCF ttemp5, F, ACCESS
17BA6  D008     BRA 0x7BB8
17BA8  0EFC     MOVLW 0xFC
17BAC  FF8C     NOP
17BAE  F001     NOP
17BB0  0EFD     MOVLW 0xFD
17BB4  FF8C     NOP
17BB6  F002     NOP
16:            }
17BB8  0EF5     MOVLW 0xF5
17BBA  26E1     ADDWF 0xFE1, F, ACCESS
17BBC  0EFF     MOVLW 0xFF
17BBE  22E2     ADDWFC 0xFE2, F, ACCESS
17BC0  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/aomod.c  -------------------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
17E08  52E6     MOVF 0xFE6, F, ACCESS
17E0A  52E6     MOVF 0xFE6, F, ACCESS
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
17E0C  0EFE     MOVLW 0xFE
17E0E  6AE3     CLRF 0xFE3, ACCESS
15:            	if(dividend < 0) {
17E10  0EFD     MOVLW 0xFD
17E12  AEE3     BTFSS 0xFE3, 7, ACCESS
17E14  D028     BRA 0x7E66
16:            		dividend = -dividend;
17E16  0EF6     MOVLW 0xF6
17E18  6CE3     NEGF 0xFE3, ACCESS
17E1A  0EF7     MOVLW 0xF7
17E1C  1EE3     COMF 0xFE3, F, ACCESS
17E1E  0EF8     MOVLW 0xF8
17E20  1EE3     COMF 0xFE3, F, ACCESS
17E22  0EF9     MOVLW 0xF9
17E24  1EE3     COMF 0xFE3, F, ACCESS
17E26  0EFA     MOVLW 0xFA
17E28  1EE3     COMF 0xFE3, F, ACCESS
17E2A  0EFB     MOVLW 0xFB
17E2C  1EE3     COMF 0xFE3, F, ACCESS
17E2E  0EFC     MOVLW 0xFC
17E30  1EE3     COMF 0xFE3, F, ACCESS
17E32  0EFD     MOVLW 0xFD
17E34  1EE3     COMF 0xFE3, F, ACCESS
17E36  E314     BNC 0x7E60
17E38  0EF7     MOVLW 0xF7
17E3A  2AE3     INCF 0xFE3, F, ACCESS
17E3C  E311     BNC 0x7E60
17E3E  0EF8     MOVLW 0xF8
17E40  2AE3     INCF 0xFE3, F, ACCESS
17E42  E30E     BNC 0x7E60
17E44  0EF9     MOVLW 0xF9
17E46  2AE3     INCF 0xFE3, F, ACCESS
17E48  E30B     BNC 0x7E60
17E4A  0EFA     MOVLW 0xFA
17E4C  2AE3     INCF 0xFE3, F, ACCESS
17E4E  E308     BNC 0x7E60
17E50  0EFB     MOVLW 0xFB
17E52  2AE3     INCF 0xFE3, F, ACCESS
17E54  E305     BNC 0x7E60
17E56  0EFC     MOVLW 0xFC
17E58  2AE3     INCF 0xFE3, F, ACCESS
17E5A  E302     BNC 0x7E60
17E5C  0EFD     MOVLW 0xFD
17E5E  2AE3     INCF 0xFE3, F, ACCESS
17:            		sign = 1;
17E60  0EFE     MOVLW 0xFE
17E62  6AE3     CLRF 0xFE3, ACCESS
17E64  2AE3     INCF 0xFE3, F, ACCESS
18:            	}
19:            	if(divisor < 0)
17E66  0EF5     MOVLW 0xF5
17E68  AEE3     BTFSS 0xFE3, 7, ACCESS
17E6A  D025     BRA 0x7EB6
20:            		divisor = -divisor;
17E6C  0EEE     MOVLW 0xEE
17E6E  6CE3     NEGF 0xFE3, ACCESS
17E70  0EEF     MOVLW 0xEF
17E72  1EE3     COMF 0xFE3, F, ACCESS
17E74  0EF0     MOVLW 0xF0
17E76  1EE3     COMF 0xFE3, F, ACCESS
17E78  0EF1     MOVLW 0xF1
17E7A  1EE3     COMF 0xFE3, F, ACCESS
17E7C  0EF2     MOVLW 0xF2
17E7E  1EE3     COMF 0xFE3, F, ACCESS
17E80  0EF3     MOVLW 0xF3
17E82  1EE3     COMF 0xFE3, F, ACCESS
17E84  0EF4     MOVLW 0xF4
17E86  1EE3     COMF 0xFE3, F, ACCESS
17E88  0EF5     MOVLW 0xF5
17E8A  1EE3     COMF 0xFE3, F, ACCESS
17E8C  E314     BNC 0x7EB6
17E8E  0EEF     MOVLW 0xEF
17E90  2AE3     INCF 0xFE3, F, ACCESS
17E92  E311     BNC 0x7EB6
17E94  0EF0     MOVLW 0xF0
17E96  2AE3     INCF 0xFE3, F, ACCESS
17E98  E30E     BNC 0x7EB6
17E9A  0EF1     MOVLW 0xF1
17E9C  2AE3     INCF 0xFE3, F, ACCESS
17E9E  E30B     BNC 0x7EB6
17EA0  0EF2     MOVLW 0xF2
17EA2  2AE3     INCF 0xFE3, F, ACCESS
17EA4  E308     BNC 0x7EB6
17EA6  0EF3     MOVLW 0xF3
17EA8  2AE3     INCF 0xFE3, F, ACCESS
17EAA  E305     BNC 0x7EB6
17EAC  0EF4     MOVLW 0xF4
17EAE  2AE3     INCF 0xFE3, F, ACCESS
17EB0  E302     BNC 0x7EB6
17EB2  0EF5     MOVLW 0xF5
17EB4  2AE3     INCF 0xFE3, F, ACCESS
21:            	if(divisor != 0) {
17EB6  0EEE     MOVLW 0xEE
17EB8  50E3     MOVF 0xFE3, W, ACCESS
17EBA  E116     BNZ 0x7EE8
17EBC  0EEF     MOVLW 0xEF
17EBE  50E3     MOVF 0xFE3, W, ACCESS
17EC0  E113     BNZ 0x7EE8
17EC2  0EF0     MOVLW 0xF0
17EC4  50E3     MOVF 0xFE3, W, ACCESS
17EC6  E110     BNZ 0x7EE8
17EC8  0EF1     MOVLW 0xF1
17ECA  50E3     MOVF 0xFE3, W, ACCESS
17ECC  E10D     BNZ 0x7EE8
17ECE  0EF2     MOVLW 0xF2
17ED0  50E3     MOVF 0xFE3, W, ACCESS
17ED2  E10A     BNZ 0x7EE8
17ED4  0EF3     MOVLW 0xF3
17ED6  50E3     MOVF 0xFE3, W, ACCESS
17ED8  E107     BNZ 0x7EE8
17EDA  0EF4     MOVLW 0xF4
17EDC  50E3     MOVF 0xFE3, W, ACCESS
17EDE  E104     BNZ 0x7EE8
17EE0  0EF5     MOVLW 0xF5
17EE2  50E3     MOVF 0xFE3, W, ACCESS
17EE4  B4D8     BTFSC 0xFD8, 2, ACCESS
17EE6  D075     BRA 0x7FD2
22:            		counter = 1;
17EE8  0EFF     MOVLW 0xFF
17EEA  6AE3     CLRF 0xFE3, ACCESS
17EEC  D012     BRA 0x7F12
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
17F14  0EF5     MOVLW 0xF5
17F16  AEE3     BTFSS 0xFE3, 7, ACCESS
17F18  D7EA     BRA 0x7EEE
24:            			divisor <<= 1;
17EEE  90D8     BCF 0xFD8, 0, ACCESS
17EF0  0EEE     MOVLW 0xEE
17EF2  36E3     RLCF 0xFE3, F, ACCESS
17EF4  0EEF     MOVLW 0xEF
17EF6  36E3     RLCF 0xFE3, F, ACCESS
17EF8  0EF0     MOVLW 0xF0
17EFA  36E3     RLCF 0xFE3, F, ACCESS
17EFC  0EF1     MOVLW 0xF1
17EFE  36E3     RLCF 0xFE3, F, ACCESS
17F00  0EF2     MOVLW 0xF2
17F02  36E3     RLCF 0xFE3, F, ACCESS
17F04  0EF3     MOVLW 0xF3
17F06  36E3     RLCF 0xFE3, F, ACCESS
17F08  0EF4     MOVLW 0xF4
17F0A  36E3     RLCF 0xFE3, F, ACCESS
17F0C  0EF5     MOVLW 0xF5
17F0E  36E3     RLCF 0xFE3, F, ACCESS
25:            			counter++;
17F10  0EFF     MOVLW 0xFF
17F12  2AE3     INCF 0xFE3, F, ACCESS
26:            		}
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
17F1A  50E1     MOVF 0xFE1, W, ACCESS
17F1C  0FF6     ADDLW 0xF6
17F1E  6ED9     MOVWF 0xFD9, ACCESS
17F20  50E2     MOVF 0xFE2, W, ACCESS
17F22  6EDA     MOVWF 0xFDA, ACCESS
17F24  0EFF     MOVLW 0xFF
17F26  22DA     ADDWFC 0xFDA, F, ACCESS
17F28  0EEE     MOVLW 0xEE
17F2A  50E3     MOVF 0xFE3, W, ACCESS
17F2C  5CDE     SUBWF 0xFDE, W, ACCESS
17F2E  0EEF     MOVLW 0xEF
17F30  50E3     MOVF 0xFE3, W, ACCESS
17F32  58DE     SUBWFB 0xFDE, W, ACCESS
17F34  0EF0     MOVLW 0xF0
17F36  50E3     MOVF 0xFE3, W, ACCESS
17F38  58DE     SUBWFB 0xFDE, W, ACCESS
17F3A  0EF1     MOVLW 0xF1
17F3C  50E3     MOVF 0xFE3, W, ACCESS
17F3E  58DE     SUBWFB 0xFDE, W, ACCESS
17F40  0EF2     MOVLW 0xF2
17F42  50E3     MOVF 0xFE3, W, ACCESS
17F44  58DE     SUBWFB 0xFDE, W, ACCESS
17F46  0EF3     MOVLW 0xF3
17F48  50E3     MOVF 0xFE3, W, ACCESS
17F4A  58DE     SUBWFB 0xFDE, W, ACCESS
17F4C  0EF4     MOVLW 0xF4
17F4E  50E3     MOVF 0xFE3, W, ACCESS
17F50  58DE     SUBWFB 0xFDE, W, ACCESS
17F52  0EF5     MOVLW 0xF5
17F54  50E3     MOVF 0xFE3, W, ACCESS
17F56  58DE     SUBWFB 0xFDE, W, ACCESS
17F58  A0D8     BTFSS 0xFD8, 0, ACCESS
17F5A  D01F     BRA 0x7F9A
29:            				dividend -= divisor;
17F5C  50E1     MOVF 0xFE1, W, ACCESS
17F5E  0FF6     ADDLW 0xF6
17F60  6ED9     MOVWF 0xFD9, ACCESS
17F62  50E2     MOVF 0xFE2, W, ACCESS
17F64  6EDA     MOVWF 0xFDA, ACCESS
17F66  0EFF     MOVLW 0xFF
17F68  22DA     ADDWFC 0xFDA, F, ACCESS
17F6A  0EEE     MOVLW 0xEE
17F6C  50E3     MOVF 0xFE3, W, ACCESS
17F6E  5EDE     SUBWF 0xFDE, F, ACCESS
17F70  0EEF     MOVLW 0xEF
17F72  50E3     MOVF 0xFE3, W, ACCESS
17F74  5ADE     SUBWFB 0xFDE, F, ACCESS
17F76  0EF0     MOVLW 0xF0
17F78  50E3     MOVF 0xFE3, W, ACCESS
17F7A  5ADE     SUBWFB 0xFDE, F, ACCESS
17F7C  0EF1     MOVLW 0xF1
17F7E  50E3     MOVF 0xFE3, W, ACCESS
17F80  5ADE     SUBWFB 0xFDE, F, ACCESS
17F82  0EF2     MOVLW 0xF2
17F84  50E3     MOVF 0xFE3, W, ACCESS
17F86  5ADE     SUBWFB 0xFDE, F, ACCESS
17F88  0EF3     MOVLW 0xF3
17F8A  50E3     MOVF 0xFE3, W, ACCESS
17F8C  5ADE     SUBWFB 0xFDE, F, ACCESS
17F8E  0EF4     MOVLW 0xF4
17F90  50E3     MOVF 0xFE3, W, ACCESS
17F92  5ADE     SUBWFB 0xFDE, F, ACCESS
17F94  0EF5     MOVLW 0xF5
17F96  50E3     MOVF 0xFE3, W, ACCESS
17F98  5ADE     SUBWFB 0xFDE, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
17F9A  90D8     BCF 0xFD8, 0, ACCESS
17F9C  0EF5     MOVLW 0xF5
17F9E  32E3     RRCF 0xFE3, F, ACCESS
17FA0  0EF4     MOVLW 0xF4
17FA2  32E3     RRCF 0xFE3, F, ACCESS
17FA4  0EF3     MOVLW 0xF3
17FA6  32E3     RRCF 0xFE3, F, ACCESS
17FA8  0EF2     MOVLW 0xF2
17FAA  32E3     RRCF 0xFE3, F, ACCESS
17FAC  0EF1     MOVLW 0xF1
17FAE  32E3     RRCF 0xFE3, F, ACCESS
17FB0  0EF0     MOVLW 0xF0
17FB2  32E3     RRCF 0xFE3, F, ACCESS
17FB4  0EEF     MOVLW 0xEF
17FB6  32E3     RRCF 0xFE3, F, ACCESS
17FB8  0EEE     MOVLW 0xEE
17FBA  32E3     RRCF 0xFE3, F, ACCESS
31:            		} while(--counter != 0);
17FBC  0EFF     MOVLW 0xFF
17FBE  50E3     MOVF 0xFE3, W, ACCESS
17FC0  6E01     MOVWF ltemp0, ACCESS
17FC2  0E01     MOVLW 0x1
17FC4  5E01     SUBWF ltemp0, F, ACCESS
17FC6  0EFF     MOVLW 0xFF
17FCA  F007     NOP
17FCC  FFE3     NOP
17FCE  A4D8     BTFSS 0xFD8, 2, ACCESS
17FD0  D7A4     BRA 0x7F1A
32:            	}
33:            	if(sign)
17FD2  0EFE     MOVLW 0xFE
17FD4  50E3     MOVF 0xFE3, W, ACCESS
17FD6  B4D8     BTFSC 0xFD8, 2, ACCESS
17FD8  D025     BRA 0x8024
34:            		dividend = -dividend;
17FDA  0EF6     MOVLW 0xF6
17FDC  6CE3     NEGF 0xFE3, ACCESS
17FDE  0EF7     MOVLW 0xF7
17FE0  1EE3     COMF 0xFE3, F, ACCESS
17FE2  0EF8     MOVLW 0xF8
17FE4  1EE3     COMF 0xFE3, F, ACCESS
17FE6  0EF9     MOVLW 0xF9
17FE8  1EE3     COMF 0xFE3, F, ACCESS
17FEA  0EFA     MOVLW 0xFA
17FEC  1EE3     COMF 0xFE3, F, ACCESS
17FEE  0EFB     MOVLW 0xFB
17FF0  1EE3     COMF 0xFE3, F, ACCESS
17FF2  0EFC     MOVLW 0xFC
17FF4  1EE3     COMF 0xFE3, F, ACCESS
17FF6  0EFD     MOVLW 0xFD
17FF8  1EE3     COMF 0xFE3, F, ACCESS
17FFA  E314     BNC 0x8024
17FFC  0EF7     MOVLW 0xF7
17FFE  2AE3     INCF 0xFE3, F, ACCESS
18000  E311     BNC 0x8024
18002  0EF8     MOVLW 0xF8
18004  2AE3     INCF 0xFE3, F, ACCESS
18006  E30E     BNC 0x8024
18008  0EF9     MOVLW 0xF9
1800A  2AE3     INCF 0xFE3, F, ACCESS
1800C  E30B     BNC 0x8024
1800E  0EFA     MOVLW 0xFA
18010  2AE3     INCF 0xFE3, F, ACCESS
18012  E308     BNC 0x8024
18014  0EFB     MOVLW 0xFB
18016  2AE3     INCF 0xFE3, F, ACCESS
18018  E305     BNC 0x8024
1801A  0EFC     MOVLW 0xFC
1801C  2AE3     INCF 0xFE3, F, ACCESS
1801E  E302     BNC 0x8024
18020  0EFD     MOVLW 0xFD
18022  2AE3     INCF 0xFE3, F, ACCESS
35:            	return dividend;
18024  0EF6     MOVLW 0xF6
18026  24E1     ADDWF 0xFE1, W, ACCESS
18028  6ED9     MOVWF 0xFD9, ACCESS
1802A  0EFF     MOVLW 0xFF
1802C  20E2     ADDWFC 0xFE2, W, ACCESS
1802E  6EDA     MOVWF 0xFDA, ACCESS
18030  0E08     MOVLW 0x8
18032  6E01     MOVWF ltemp0, ACCESS
18034  0EF6     MOVLW 0xF6
18038  FF7B     NOP
1803A  FFE3     NOP
1803C  28E8     INCF 0xFE8, W, ACCESS
1803E  2E01     DECFSZ ltemp0, F, ACCESS
18040  D7FA     BRA 0x8036
36:            }
18042  52E5     MOVF 0xFE5, F, ACCESS
18044  52E5     MOVF 0xFE5, F, ACCESS
18046  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/aodiv.c  -------------------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
176CE  0E0A     MOVLW 0xA
176D0  26E1     ADDWF 0xFE1, F, ACCESS
176D2  0E00     MOVLW 0x0
176D4  22E2     ADDWFC 0xFE2, F, ACCESS
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
176D6  0EFE     MOVLW 0xFE
176D8  6AE3     CLRF 0xFE3, ACCESS
16:            	if(divisor < 0) {
176DA  0EED     MOVLW 0xED
176DC  AEE3     BTFSS 0xFE3, 7, ACCESS
176DE  D028     BRA 0x7730
17:            		divisor = -divisor;
176E0  0EE6     MOVLW 0xE6
176E2  6CE3     NEGF 0xFE3, ACCESS
176E4  0EE7     MOVLW 0xE7
176E6  1EE3     COMF 0xFE3, F, ACCESS
176E8  0EE8     MOVLW 0xE8
176EA  1EE3     COMF 0xFE3, F, ACCESS
176EC  0EE9     MOVLW 0xE9
176EE  1EE3     COMF 0xFE3, F, ACCESS
176F0  0EEA     MOVLW 0xEA
176F2  1EE3     COMF 0xFE3, F, ACCESS
176F4  0EEB     MOVLW 0xEB
176F6  1EE3     COMF 0xFE3, F, ACCESS
176F8  0EEC     MOVLW 0xEC
176FA  1EE3     COMF 0xFE3, F, ACCESS
176FC  0EED     MOVLW 0xED
176FE  1EE3     COMF 0xFE3, F, ACCESS
17700  E314     BNC 0x772A
17702  0EE7     MOVLW 0xE7
17704  2AE3     INCF 0xFE3, F, ACCESS
17706  E311     BNC 0x772A
17708  0EE8     MOVLW 0xE8
1770A  2AE3     INCF 0xFE3, F, ACCESS
1770C  E30E     BNC 0x772A
1770E  0EE9     MOVLW 0xE9
17710  2AE3     INCF 0xFE3, F, ACCESS
17712  E30B     BNC 0x772A
17714  0EEA     MOVLW 0xEA
17716  2AE3     INCF 0xFE3, F, ACCESS
17718  E308     BNC 0x772A
1771A  0EEB     MOVLW 0xEB
1771C  2AE3     INCF 0xFE3, F, ACCESS
1771E  E305     BNC 0x772A
17720  0EEC     MOVLW 0xEC
17722  2AE3     INCF 0xFE3, F, ACCESS
17724  E302     BNC 0x772A
17726  0EED     MOVLW 0xED
17728  2AE3     INCF 0xFE3, F, ACCESS
18:            		sign = 1;
1772A  0EFE     MOVLW 0xFE
1772C  6AE3     CLRF 0xFE3, ACCESS
1772E  2AE3     INCF 0xFE3, F, ACCESS
19:            	}
20:            	if(dividend < 0) {
17730  0EF5     MOVLW 0xF5
17732  AEE3     BTFSS 0xFE3, 7, ACCESS
17734  D027     BRA 0x7784
21:            		dividend = -dividend;
17736  0EEE     MOVLW 0xEE
17738  6CE3     NEGF 0xFE3, ACCESS
1773A  0EEF     MOVLW 0xEF
1773C  1EE3     COMF 0xFE3, F, ACCESS
1773E  0EF0     MOVLW 0xF0
17740  1EE3     COMF 0xFE3, F, ACCESS
17742  0EF1     MOVLW 0xF1
17744  1EE3     COMF 0xFE3, F, ACCESS
17746  0EF2     MOVLW 0xF2
17748  1EE3     COMF 0xFE3, F, ACCESS
1774A  0EF3     MOVLW 0xF3
1774C  1EE3     COMF 0xFE3, F, ACCESS
1774E  0EF4     MOVLW 0xF4
17750  1EE3     COMF 0xFE3, F, ACCESS
17752  0EF5     MOVLW 0xF5
17754  1EE3     COMF 0xFE3, F, ACCESS
17756  E314     BNC 0x7780
17758  0EEF     MOVLW 0xEF
1775A  2AE3     INCF 0xFE3, F, ACCESS
1775C  E311     BNC 0x7780
1775E  0EF0     MOVLW 0xF0
17760  2AE3     INCF 0xFE3, F, ACCESS
17762  E30E     BNC 0x7780
17764  0EF1     MOVLW 0xF1
17766  2AE3     INCF 0xFE3, F, ACCESS
17768  E30B     BNC 0x7780
1776A  0EF2     MOVLW 0xF2
1776C  2AE3     INCF 0xFE3, F, ACCESS
1776E  E308     BNC 0x7780
17770  0EF3     MOVLW 0xF3
17772  2AE3     INCF 0xFE3, F, ACCESS
17774  E305     BNC 0x7780
17776  0EF4     MOVLW 0xF4
17778  2AE3     INCF 0xFE3, F, ACCESS
1777A  E302     BNC 0x7780
1777C  0EF5     MOVLW 0xF5
1777E  2AE3     INCF 0xFE3, F, ACCESS
22:            		sign ^= 1;
17780  0EFE     MOVLW 0xFE
17782  70E3     BTG 0xFE3, 0, ACCESS
23:            	}
24:            	quotient = 0;
17784  0E07     MOVLW 0x7
17786  6E01     MOVWF ltemp0, ACCESS
17788  0EF6     MOVLW 0xF6
1778A  6AE3     CLRF 0xFE3, ACCESS
1778C  2AE8     INCF 0xFE8, F, ACCESS
1778E  0601     DECF ltemp0, F, ACCESS
17790  E2FC     BC 0x778A
25:            	if(divisor != 0) {
17792  0EE6     MOVLW 0xE6
17794  50E3     MOVF 0xFE3, W, ACCESS
17796  E116     BNZ 0x77C4
17798  0EE7     MOVLW 0xE7
1779A  50E3     MOVF 0xFE3, W, ACCESS
1779C  E113     BNZ 0x77C4
1779E  0EE8     MOVLW 0xE8
177A0  50E3     MOVF 0xFE3, W, ACCESS
177A2  E110     BNZ 0x77C4
177A4  0EE9     MOVLW 0xE9
177A6  50E3     MOVF 0xFE3, W, ACCESS
177A8  E10D     BNZ 0x77C4
177AA  0EEA     MOVLW 0xEA
177AC  50E3     MOVF 0xFE3, W, ACCESS
177AE  E10A     BNZ 0x77C4
177B0  0EEB     MOVLW 0xEB
177B2  50E3     MOVF 0xFE3, W, ACCESS
177B4  E107     BNZ 0x77C4
177B6  0EEC     MOVLW 0xEC
177B8  50E3     MOVF 0xFE3, W, ACCESS
177BA  E104     BNZ 0x77C4
177BC  0EED     MOVLW 0xED
177BE  50E3     MOVF 0xFE3, W, ACCESS
177C0  B4D8     BTFSC 0xFD8, 2, ACCESS
177C2  D088     BRA 0x78D4
26:            		counter = 1;
177C4  0EFF     MOVLW 0xFF
177C6  6AE3     CLRF 0xFE3, ACCESS
177C8  D012     BRA 0x77EE
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
177F0  0EED     MOVLW 0xED
177F2  AEE3     BTFSS 0xFE3, 7, ACCESS
177F4  D7EA     BRA 0x77CA
28:            			divisor <<= 1;
177CA  90D8     BCF 0xFD8, 0, ACCESS
177CC  0EE6     MOVLW 0xE6
177CE  36E3     RLCF 0xFE3, F, ACCESS
177D0  0EE7     MOVLW 0xE7
177D2  36E3     RLCF 0xFE3, F, ACCESS
177D4  0EE8     MOVLW 0xE8
177D6  36E3     RLCF 0xFE3, F, ACCESS
177D8  0EE9     MOVLW 0xE9
177DA  36E3     RLCF 0xFE3, F, ACCESS
177DC  0EEA     MOVLW 0xEA
177DE  36E3     RLCF 0xFE3, F, ACCESS
177E0  0EEB     MOVLW 0xEB
177E2  36E3     RLCF 0xFE3, F, ACCESS
177E4  0EEC     MOVLW 0xEC
177E6  36E3     RLCF 0xFE3, F, ACCESS
177E8  0EED     MOVLW 0xED
177EA  36E3     RLCF 0xFE3, F, ACCESS
29:            			counter++;
177EC  0EFF     MOVLW 0xFF
177EE  2AE3     INCF 0xFE3, F, ACCESS
30:            		}
31:            		do {
32:            			quotient <<= 1;
177F6  90D8     BCF 0xFD8, 0, ACCESS
177F8  0EF6     MOVLW 0xF6
177FA  36E3     RLCF 0xFE3, F, ACCESS
177FC  0EF7     MOVLW 0xF7
177FE  36E3     RLCF 0xFE3, F, ACCESS
17800  0EF8     MOVLW 0xF8
17802  36E3     RLCF 0xFE3, F, ACCESS
17804  0EF9     MOVLW 0xF9
17806  36E3     RLCF 0xFE3, F, ACCESS
17808  0EFA     MOVLW 0xFA
1780A  36E3     RLCF 0xFE3, F, ACCESS
1780C  0EFB     MOVLW 0xFB
1780E  36E3     RLCF 0xFE3, F, ACCESS
17810  0EFC     MOVLW 0xFC
17812  36E3     RLCF 0xFE3, F, ACCESS
17814  0EFD     MOVLW 0xFD
17816  36E3     RLCF 0xFE3, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
17818  50E1     MOVF 0xFE1, W, ACCESS
1781A  0FEE     ADDLW 0xEE
1781C  6ED9     MOVWF 0xFD9, ACCESS
1781E  50E2     MOVF 0xFE2, W, ACCESS
17820  6EDA     MOVWF 0xFDA, ACCESS
17822  0EFF     MOVLW 0xFF
17824  22DA     ADDWFC 0xFDA, F, ACCESS
17826  0EE6     MOVLW 0xE6
17828  50E3     MOVF 0xFE3, W, ACCESS
1782A  5CDE     SUBWF 0xFDE, W, ACCESS
1782C  0EE7     MOVLW 0xE7
1782E  50E3     MOVF 0xFE3, W, ACCESS
17830  58DE     SUBWFB 0xFDE, W, ACCESS
17832  0EE8     MOVLW 0xE8
17834  50E3     MOVF 0xFE3, W, ACCESS
17836  58DE     SUBWFB 0xFDE, W, ACCESS
17838  0EE9     MOVLW 0xE9
1783A  50E3     MOVF 0xFE3, W, ACCESS
1783C  58DE     SUBWFB 0xFDE, W, ACCESS
1783E  0EEA     MOVLW 0xEA
17840  50E3     MOVF 0xFE3, W, ACCESS
17842  58DE     SUBWFB 0xFDE, W, ACCESS
17844  0EEB     MOVLW 0xEB
17846  50E3     MOVF 0xFE3, W, ACCESS
17848  58DE     SUBWFB 0xFDE, W, ACCESS
1784A  0EEC     MOVLW 0xEC
1784C  50E3     MOVF 0xFE3, W, ACCESS
1784E  58DE     SUBWFB 0xFDE, W, ACCESS
17850  0EED     MOVLW 0xED
17852  50E3     MOVF 0xFE3, W, ACCESS
17854  58DE     SUBWFB 0xFDE, W, ACCESS
17856  A0D8     BTFSS 0xFD8, 0, ACCESS
17858  D021     BRA 0x789C
34:            				dividend -= divisor;
1785A  50E1     MOVF 0xFE1, W, ACCESS
1785C  0FEE     ADDLW 0xEE
1785E  6ED9     MOVWF 0xFD9, ACCESS
17860  50E2     MOVF 0xFE2, W, ACCESS
17862  6EDA     MOVWF 0xFDA, ACCESS
17864  0EFF     MOVLW 0xFF
17866  22DA     ADDWFC 0xFDA, F, ACCESS
17868  0EE6     MOVLW 0xE6
1786A  50E3     MOVF 0xFE3, W, ACCESS
1786C  5EDE     SUBWF 0xFDE, F, ACCESS
1786E  0EE7     MOVLW 0xE7
17870  50E3     MOVF 0xFE3, W, ACCESS
17872  5ADE     SUBWFB 0xFDE, F, ACCESS
17874  0EE8     MOVLW 0xE8
17876  50E3     MOVF 0xFE3, W, ACCESS
17878  5ADE     SUBWFB 0xFDE, F, ACCESS
1787A  0EE9     MOVLW 0xE9
1787C  50E3     MOVF 0xFE3, W, ACCESS
1787E  5ADE     SUBWFB 0xFDE, F, ACCESS
17880  0EEA     MOVLW 0xEA
17882  50E3     MOVF 0xFE3, W, ACCESS
17884  5ADE     SUBWFB 0xFDE, F, ACCESS
17886  0EEB     MOVLW 0xEB
17888  50E3     MOVF 0xFE3, W, ACCESS
1788A  5ADE     SUBWFB 0xFDE, F, ACCESS
1788C  0EEC     MOVLW 0xEC
1788E  50E3     MOVF 0xFE3, W, ACCESS
17890  5ADE     SUBWFB 0xFDE, F, ACCESS
17892  0EED     MOVLW 0xED
17894  50E3     MOVF 0xFE3, W, ACCESS
17896  5ADE     SUBWFB 0xFDE, F, ACCESS
35:            				quotient |= 1;
17898  0EF6     MOVLW 0xF6
1789A  80E3     BSF 0xFE3, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
1789C  90D8     BCF 0xFD8, 0, ACCESS
1789E  0EED     MOVLW 0xED
178A0  32E3     RRCF 0xFE3, F, ACCESS
178A2  0EEC     MOVLW 0xEC
178A4  32E3     RRCF 0xFE3, F, ACCESS
178A6  0EEB     MOVLW 0xEB
178A8  32E3     RRCF 0xFE3, F, ACCESS
178AA  0EEA     MOVLW 0xEA
178AC  32E3     RRCF 0xFE3, F, ACCESS
178AE  0EE9     MOVLW 0xE9
178B0  32E3     RRCF 0xFE3, F, ACCESS
178B2  0EE8     MOVLW 0xE8
178B4  32E3     RRCF 0xFE3, F, ACCESS
178B6  0EE7     MOVLW 0xE7
178B8  32E3     RRCF 0xFE3, F, ACCESS
178BA  0EE6     MOVLW 0xE6
178BC  32E3     RRCF 0xFE3, F, ACCESS
38:            		} while(--counter != 0);
178BE  0EFF     MOVLW 0xFF
178C0  50E3     MOVF 0xFE3, W, ACCESS
178C2  6E01     MOVWF ltemp0, ACCESS
178C4  0E01     MOVLW 0x1
178C6  5E01     SUBWF ltemp0, F, ACCESS
178C8  0EFF     MOVLW 0xFF
178CC  F007     NOP
178CE  FFE3     NOP
178D0  A4D8     BTFSS 0xFD8, 2, ACCESS
178D2  D791     BRA 0x77F6
39:            	}
40:            	if(sign)
178D4  0EFE     MOVLW 0xFE
178D6  50E3     MOVF 0xFE3, W, ACCESS
178D8  B4D8     BTFSC 0xFD8, 2, ACCESS
178DA  D025     BRA 0x7926
41:            		quotient = -quotient;
178DC  0EF6     MOVLW 0xF6
178DE  6CE3     NEGF 0xFE3, ACCESS
178E0  0EF7     MOVLW 0xF7
178E2  1EE3     COMF 0xFE3, F, ACCESS
178E4  0EF8     MOVLW 0xF8
178E6  1EE3     COMF 0xFE3, F, ACCESS
178E8  0EF9     MOVLW 0xF9
178EA  1EE3     COMF 0xFE3, F, ACCESS
178EC  0EFA     MOVLW 0xFA
178EE  1EE3     COMF 0xFE3, F, ACCESS
178F0  0EFB     MOVLW 0xFB
178F2  1EE3     COMF 0xFE3, F, ACCESS
178F4  0EFC     MOVLW 0xFC
178F6  1EE3     COMF 0xFE3, F, ACCESS
178F8  0EFD     MOVLW 0xFD
178FA  1EE3     COMF 0xFE3, F, ACCESS
178FC  E314     BNC 0x7926
178FE  0EF7     MOVLW 0xF7
17900  2AE3     INCF 0xFE3, F, ACCESS
17902  E311     BNC 0x7926
17904  0EF8     MOVLW 0xF8
17906  2AE3     INCF 0xFE3, F, ACCESS
17908  E30E     BNC 0x7926
1790A  0EF9     MOVLW 0xF9
1790C  2AE3     INCF 0xFE3, F, ACCESS
1790E  E30B     BNC 0x7926
17910  0EFA     MOVLW 0xFA
17912  2AE3     INCF 0xFE3, F, ACCESS
17914  E308     BNC 0x7926
17916  0EFB     MOVLW 0xFB
17918  2AE3     INCF 0xFE3, F, ACCESS
1791A  E305     BNC 0x7926
1791C  0EFC     MOVLW 0xFC
1791E  2AE3     INCF 0xFE3, F, ACCESS
17920  E302     BNC 0x7926
17922  0EFD     MOVLW 0xFD
17924  2AE3     INCF 0xFE3, F, ACCESS
42:            	return quotient;
17926  0EF6     MOVLW 0xF6
17928  24E1     ADDWF 0xFE1, W, ACCESS
1792A  6ED9     MOVWF 0xFD9, ACCESS
1792C  0EFF     MOVLW 0xFF
1792E  20E2     ADDWFC 0xFE2, W, ACCESS
17930  6EDA     MOVWF 0xFDA, ACCESS
17932  0E08     MOVLW 0x8
17934  6E01     MOVWF ltemp0, ACCESS
17936  0EEE     MOVLW 0xEE
1793A  FF7B     NOP
1793C  FFE3     NOP
1793E  28E8     INCF 0xFE8, W, ACCESS
17940  2E01     DECFSZ ltemp0, F, ACCESS
17942  D7FA     BRA 0x7938
43:            }
17944  0EF6     MOVLW 0xF6
17946  26E1     ADDWF 0xFE1, F, ACCESS
17948  0EFF     MOVLW 0xFF
1794A  22E2     ADDWFC 0xFE2, F, ACCESS
1794C  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/abs.c  ---------------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
1B538  0EFF     MOVLW 0xFF
1B53A  BEE3     BTFSC 0xFE3, 7, ACCESS
1B53C  D007     BRA 0xB54C
1B53E  0EFF     MOVLW 0xFF
1B540  50E3     MOVF 0xFE3, W, ACCESS
1B542  E112     BNZ 0xB568
1B544  0EFE     MOVLW 0xFE
1B546  04E3     DECF 0xFE3, W, ACCESS
1B548  B0D8     BTFSC 0xFD8, 0, ACCESS
1B54A  D00E     BRA 0xB568
1B54C  0EFE     MOVLW 0xFE
1B550  FF8C     NOP
1B552  F001     NOP
1B554  1E01     COMF ltemp0, F, ACCESS
1B556  0EFF     MOVLW 0xFF
1B55A  FF8C     NOP
1B55C  F002     NOP
1B55E  1E02     COMF ttemp5, F, ACCESS
1B560  2A01     INCF ltemp0, F, ACCESS
1B562  B4D8     BTFSC 0xFD8, 2, ACCESS
1B564  2A02     INCF ttemp5, F, ACCESS
1B566  D008     BRA 0xB578
1B568  0EFE     MOVLW 0xFE
1B56C  FF8C     NOP
1B56E  F001     NOP
1B570  0EFF     MOVLW 0xFF
1B574  FF8C     NOP
1B576  F002     NOP
4:             }
1B578  52E5     MOVF 0xFE5, F, ACCESS
1B57A  52E5     MOVF 0xFE5, F, ACCESS
1B57C  0012     RETURN 0
---  /opt/microchip/xc8/v2.10/pic/sources/c99/common/__fpclassifyf.c  -----------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             int __fpclassifyf(float x)
189DA  0E06     MOVLW 0x6
189DC  26E1     ADDWF 0xFE1, F, ACCESS
189DE  0E00     MOVLW 0x0
189E0  22E2     ADDWFC 0xFE2, F, ACCESS
5:             {
6:             	union {float f; uint32_t i;} u = {x};
189E4  F208     NOP
189E6  F009     NOP
189EA  F20C     NOP
189EC  F00A     NOP
189F0  F210     NOP
189F2  F00B     NOP
189F6  F214     NOP
189F8  F00C     NOP
189FA  0EFA     MOVLW 0xFA
189FE  F027     NOP
18A00  FFE3     NOP
18A02  0EFB     MOVLW 0xFB
18A06  F02B     NOP
18A08  FFE3     NOP
18A0A  0EFC     MOVLW 0xFC
18A0E  F02F     NOP
18A10  FFE3     NOP
18A12  0EFD     MOVLW 0xFD
18A16  F033     NOP
18A18  FFE3     NOP
18A1A  0EF6     MOVLW 0xF6
18A1E  FF8C     NOP
18A20  F009     NOP
18A22  0EF7     MOVLW 0xF7
18A26  FF8C     NOP
18A28  F00A     NOP
18A2A  0EF8     MOVLW 0xF8
18A2E  FF8C     NOP
18A30  F00B     NOP
18A32  0EF9     MOVLW 0xF9
18A36  FF8C     NOP
18A38  F00C     NOP
18A3A  0EFA     MOVLW 0xFA
18A3E  F027     NOP
18A40  FFE3     NOP
18A42  0EFB     MOVLW 0xFB
18A46  F02B     NOP
18A48  FFE3     NOP
18A4A  0EFC     MOVLW 0xFC
18A4E  F02F     NOP
18A50  FFE3     NOP
18A52  0EFD     MOVLW 0xFD
18A56  F033     NOP
18A58  FFE3     NOP
7:             	int e = u.i>>23 & 0xff;
18A5A  0EFA     MOVLW 0xFA
18A5E  FF8C     NOP
18A60  F009     NOP
18A62  0EFB     MOVLW 0xFB
18A66  FF8C     NOP
18A68  F00A     NOP
18A6A  0EFC     MOVLW 0xFC
18A6E  FF8C     NOP
18A70  F00B     NOP
18A72  0EFD     MOVLW 0xFD
18A76  FF8C     NOP
18A78  F00C     NOP
18A7A  0E18     MOVLW 0x18
18A7C  D005     BRA 0x8A88
18A7E  90D8     BCF 0xFD8, 0, ACCESS
18A80  320C     RRCF 0xC, F, ACCESS
18A82  320B     RRCF wtemp5, F, ACCESS
18A84  320A     RRCF ttemp3, F, ACCESS
18A86  3209     RRCF ltemp2, F, ACCESS
18A88  2EE8     DECFSZ 0xFE8, F, ACCESS
18A8A  D7F9     BRA 0x8A7E
18A8E  F024     NOP
18A90  F007     NOP
18A94  F028     NOP
18A96  F008     NOP
18A98  0EFF     MOVLW 0xFF
18A9A  1607     ANDWF ttemp2, F, ACCESS
18A9C  0E00     MOVLW 0x0
18A9E  1608     ANDWF 0x8, F, ACCESS
18AA0  0EFE     MOVLW 0xFE
18AA4  F01F     NOP
18AA6  FFE3     NOP
18AA8  0EFF     MOVLW 0xFF
18AAC  F023     NOP
18AAE  FFE3     NOP
8:             	if (!e) return u.i<<1 ? FP_SUBNORMAL : FP_ZERO;
18AB0  0EFE     MOVLW 0xFE
18AB4  FF8C     NOP
18AB6  F001     NOP
18AB8  0EFF     MOVLW 0xFF
18ABA  50E3     MOVF 0xFE3, W, ACCESS
18ABC  1001     IORWF ltemp0, W, ACCESS
18ABE  A4D8     BTFSS 0xFD8, 2, ACCESS
18AC0  D023     BRA 0x8B08
18AC2  0EFA     MOVLW 0xFA
18AC6  FF8C     NOP
18AC8  F009     NOP
18ACA  0EFB     MOVLW 0xFB
18ACE  FF8C     NOP
18AD0  F00A     NOP
18AD2  0EFC     MOVLW 0xFC
18AD6  FF8C     NOP
18AD8  F00B     NOP
18ADA  0EFD     MOVLW 0xFD
18ADE  FF8C     NOP
18AE0  F00C     NOP
18AE2  90D8     BCF 0xFD8, 0, ACCESS
18AE4  3409     RLCF ltemp2, W, ACCESS
18AE6  6E05     MOVWF ltemp1, ACCESS
18AE8  340A     RLCF ttemp3, W, ACCESS
18AEA  6E06     MOVWF 0x6, ACCESS
18AEC  340B     RLCF wtemp5, W, ACCESS
18AEE  6E07     MOVWF ttemp2, ACCESS
18AF0  340C     RLCF 0xC, W, ACCESS
18AF2  6E08     MOVWF 0x8, ACCESS
18AF4  5005     MOVF ltemp1, W, ACCESS
18AF6  1006     IORWF 0x6, W, ACCESS
18AF8  1007     IORWF ttemp2, W, ACCESS
18AFA  1008     IORWF 0x8, W, ACCESS
18AFC  A4D8     BTFSS 0xFD8, 2, ACCESS
18AFE  D002     BRA 0x8B04
18B00  0E02     MOVLW 0x2
18B02  D02E     BRA 0x8B60
18B04  0E03     MOVLW 0x3
18B06  D02C     BRA 0x8B60
9:             	if (e==0xff) return u.i<<9 ? FP_NAN : FP_INFINITE;
18B08  0EFE     MOVLW 0xFE
18B0A  28E3     INCF 0xFE3, W, ACCESS
18B0C  E128     BNZ 0x8B5E
18B0E  0EFF     MOVLW 0xFF
18B10  50E3     MOVF 0xFE3, W, ACCESS
18B12  A4D8     BTFSS 0xFD8, 2, ACCESS
18B14  D024     BRA 0x8B5E
18B16  0EFA     MOVLW 0xFA
18B1A  FF8C     NOP
18B1C  F009     NOP
18B1E  0EFB     MOVLW 0xFB
18B22  FF8C     NOP
18B24  F00A     NOP
18B26  0EFC     MOVLW 0xFC
18B2A  FF8C     NOP
18B2C  F00B     NOP
18B2E  0EFD     MOVLW 0xFD
18B32  FF8C     NOP
18B34  F00C     NOP
18B36  0E09     MOVLW 0x9
18B38  90D8     BCF 0xFD8, 0, ACCESS
18B3A  3609     RLCF ltemp2, F, ACCESS
18B3C  360A     RLCF ttemp3, F, ACCESS
18B3E  360B     RLCF wtemp5, F, ACCESS
18B40  360C     RLCF 0xC, F, ACCESS
18B42  2EE8     DECFSZ 0xFE8, F, ACCESS
18B44  D7F9     BRA 0x8B38
18B46  5009     MOVF ltemp2, W, ACCESS
18B48  100A     IORWF ttemp3, W, ACCESS
18B4A  100B     IORWF wtemp5, W, ACCESS
18B4C  100C     IORWF 0xC, W, ACCESS
18B4E  A4D8     BTFSS 0xFD8, 2, ACCESS
18B50  D002     BRA 0x8B56
18B52  0E01     MOVLW 0x1
18B54  D001     BRA 0x8B58
18B56  0E00     MOVLW 0x0
18B58  6E01     MOVWF ltemp0, ACCESS
18B5A  6A02     CLRF ttemp5, ACCESS
18B5C  D004     BRA 0x8B66
10:            	return FP_NORMAL;
18B5E  0E04     MOVLW 0x4
18B60  6E01     MOVWF ltemp0, ACCESS
18B62  0E00     MOVLW 0x0
18B64  6E02     MOVWF ttemp5, ACCESS
11:            }
18B66  0EF6     MOVLW 0xF6
18B68  26E1     ADDWF 0xFE1, F, ACCESS
18B6A  0EFF     MOVLW 0xFF
18B6C  22E2     ADDWFC 0xFE2, F, ACCESS
18B6E  0012     RETURN 0
